

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favico.jpg">
  <link rel="icon" href="/img/favico.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smooth">
  <meta name="keywords" content="">
  
    <meta name="description" content="2022年再带你重新梳理一遍 从输入URL到页面显示 这道基本前端面试必考的面试真题，吃透了就再也不怕这道题型啦！">
<meta property="og:type" content="article">
<meta property="og:title" content="【offer 收割机之面试必备】（建议收藏）从 URL 输入到页面展现的全过程">
<meta property="og:url" content="http://example.com/2022/03/17/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89%E4%BB%8E%20URL%20%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="Smooth个人博客">
<meta property="og:description" content="2022年再带你重新梳理一遍 从输入URL到页面显示 这道基本前端面试必考的面试真题，吃透了就再也不怕这道题型啦！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/URL.jpg">
<meta property="article:published_time" content="2022-03-17T03:54:29.000Z">
<meta property="article:modified_time" content="2022-03-22T08:17:19.959Z">
<meta property="article:author" content="Smooth">
<meta property="article:tag" content="面试系列">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="浏览器原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/URL.jpg">
  
  
  <title>【offer 收割机之面试必备】（建议收藏）从 URL 输入到页面展现的全过程 - Smooth个人博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.org/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading2.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smooth&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/URL.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          <span id="subtitle" title="【offer 收割机之面试必备】（建议收藏）从 URL 输入到页面展现的全过程">
            
          </span>
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Smooth
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-17 11:54" pubdate>
          2022年3月17日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          82 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">【offer 收割机之面试必备】（建议收藏）从 URL 输入到页面展现的全过程</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年3月22日 下午
                  
                
              </p>
            
            <div class="markdown-body">
              
              <blockquote>
<p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 本篇文章是我在复习该知识点时，查看了多篇文章之后，结合我自己的个人思考与理解汇聚而成的精华<br /> 🙌 如文章有误，恳请评论区指正，谢谢！<br /> ❤ 写作不易，「点赞」+「收藏」+「转发」 谢谢支持！</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/editor/drafts/7075290588198731790">原文章链接</a></p>
<h2 id="正文开始前你需知道的"><a href="#正文开始前你需知道的" class="headerlink" title="正文开始前你需知道的"></a>正文开始前你需知道的</h2><p>从输入URL到页面显示不仅仅是一道经典的面试题，这个知识点中涉及到了非常广泛的知识点，因此面试官可以通过这个问题有点到面的向候选人发起提问，来看看面试者在计算机网络和浏览器这方面知识的广度和深度。</p>
<p><strong>废话不多说，下面就开始吧！</strong><br><br></br></p>
<h2 id="一、用户输入阶段"><a href="#一、用户输入阶段" class="headerlink" title="一、用户输入阶段"></a>一、用户输入阶段</h2><blockquote>
<p>用户在地址栏输入内容之后，浏览器会首先判断用户输入的是合法的URL还是搜索内容，如果是搜索内容就合成URL，如果是合法的URL就开始进行加载。</p>
</blockquote>
<p>在这里，要明确我们具体要查找的东西到底是什么</p>
<h3 id="搜索内容"><a href="#搜索内容" class="headerlink" title="搜索内容"></a>搜索内容</h3><p>我们要搜索一些内容，例如去百度搜索引擎进行百度查找<strong>某个问题的答案</strong>，那么浏览器就会自动调用默认搜索引擎进行<strong>关键字</strong>的查找</p>
<h3 id="域名解析对应的-IP"><a href="#域名解析对应的-IP" class="headerlink" title="域名解析对应的 IP"></a>域名解析对应的 IP</h3><p>如果是合法的 URL，说明我们想通过该 URL(统一资源定位符) 查找到对应服务器上的该资源，那么要查找的实质就是 该域名解析后所对应的 IP 地址，即 <strong>域名与 IP 地址的一个映射关系</strong>。</p>
<p><strong>后面篇幅重点讲到的都是第二种情况，后续篇幅中我将其简称为 <code>映射关系</code></strong><br><br></br></p>
<h2 id="二、发起URL请求阶段"><a href="#二、发起URL请求阶段" class="headerlink" title="二、发起URL请求阶段"></a>二、发起URL请求阶段</h2><blockquote>
<p><strong>下面对发起URL请求阶段进行详细展开</strong></p>
</blockquote>
<h3 id="1-构建请求行"><a href="#1-构建请求行" class="headerlink" title="1. 构建请求行"></a>1. 构建请求行</h3><p>浏览器进程首先会构建请求行信息，然后通过进程间通信IPC将URL请求发送给网络进程。<br><br></br></p>
<h3 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h3><ol>
<li><p>先找浏览器本地的缓存</p>
</li>
<li><p>找操作系统 hosts 文件的缓存</p>
</li>
<li><p>以上两步都没找到需要的资源，就要进行网络请求啦，开始跟外界打交道，去<strong>本地 DNS 服务器</strong>（local DNS）进行查找，如果本地 DNS 服务器的缓存中已经存在该映射关系，那么直接返回，否则继续进行后续步骤（<strong>99% 的 DNS 解析到这一步就结束了，因为一般 <code>local DNS</code> 中存在大量映射关系缓存</strong>）。</p>
</li>
<li><p>本地 DNS 服务器作为代理服务器，向它上面的根域名服务器建立 TCP 连接后发出请求，根域名服务器返回<strong>查询域的主域名服务器</strong>（即 <code>gTLD</code>，像 <code>.COM</code>、 <code>.CN</code> 这种顶级域名）。</p>
</li>
<li><p>本地 DNS 服务器拿到后向 <code>gTLD</code> 发请求，<code>gTLD</code> 是可以找到你想查找域名的 <code>Name Server</code> 地址的，本地 DNS 服务器向 <code>Name Server</code> 地址发送请求，拿到该域名对应的 IP 和 TTL（time to live，即<strong>域名解析结果在DNS服务器中存活的时间</strong>），然后将结果先是自己做一个缓存（根据 TTL 设置映射存活时间），然后返回给浏览器，DNS 解析结束</p>
</li>
</ol>
<blockquote>
<p><strong>Name Server 概念</strong><br />服务商提供的服务器地址，比如你在阿里云注册的域名，那查找就是去阿里云的服务器查，因为你是去域名提供商的服务器发请求，那肯定是能拿到对应的ip地址的<br><br></br></p>
</blockquote>
<h3 id="3-等待-TCP-队列"><a href="#3-等待-TCP-队列" class="headerlink" title="3. 等待 TCP 队列"></a>3. 等待 TCP 队列</h3><p>chrome 有个机制，同一个域名同时最多只能建立6个TCP连接，如果超过这个数量的连接必须要进入排队等待状态。</p>
<blockquote>
<p>知识巩固<br />对于多路复用，http 1.1 采取<strong>建立多个 TCP 连接</strong>，http 2.0 采用建立<strong>一个</strong> TCP 连接<strong>并行发起多个请求</strong><br><br></br></p>
</blockquote>
<h3 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h3><p>通过TCP三次握手与服务器建立连接，然后进行数据传输。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f919eafbf848ab88f7281f1f212579~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"></p>
<p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<blockquote>
<p><strong>A：我要跟你建立连接，你那边接受得到我的请求吗？<br />B：接收到啦！没问题，但得向你确认下，证明这是你真实的要准备跟我建立的连接，而不是你很久之前发过的<br />A：对，没问题，这是我刚发给你的</strong><br><br></br></p>
</blockquote>
<h4 id="为什么要三次握手？两次可以吗？"><a href="#为什么要三次握手？两次可以吗？" class="headerlink" title="为什么要三次握手？两次可以吗？"></a>为什么要三次握手？两次可以吗？</h4><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>具体例子如下</p>
<blockquote>
<p><strong>已失效的连接请求报文段</strong> 的产生在这样一种情况下：client 发出的<strong>第一个</strong>连接请求报文段<strong>并没有丢失</strong>，而是在某个网络结点长时间的<strong>滞留</strong>了，以致<strong>延误</strong>到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的<strong>一个新的连接请求</strong>。于是就向 client 发出确认报文段，<strong>同意建立连接</strong>。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在 client 并没有发出<strong>新的建立连接</strong>请求，<strong>因此不会理睬 server 的确认</strong>，也不会向 server 发送数据。但 serve r却以为新的运输连接已经建立，并<strong>一直等待</strong> client 发来数据。这样，server 的很多资源就<strong>白白浪费掉</strong>了。采用“三次握手”的办法可以<strong>防止上述现象发生</strong>。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，<strong>就知道 client 并没有要求建立连接</strong>。”</p>
</blockquote>
<h4 id="四次握手可以吗？"><a href="#四次握手可以吗？" class="headerlink" title="四次握手可以吗？"></a>四次握手可以吗？</h4><p>可以但没必要</p>
<p>四次握手只是将第二次握手分解为了以下两个步骤</p>
<ol>
<li>先发送确认位 ACK &#x3D; 1，然后确认号 ack &#x3D; x + 1</li>
<li>再发送同步位 SYN &#x3D; 1，和序号 seq &#x3D; y<br><br></br><h3 id="5-查找缓存"><a href="#5-查找缓存" class="headerlink" title="5. 查找缓存"></a>5. 查找缓存</h3>建立好 TCP 连接后，会再次进行查找缓存，即我们熟知的 <strong>强制缓存</strong> 和 <strong>协商缓存</strong> ，如果找到了，服务器会返回 <strong>304 状态码</strong> 和 对应的缓存资源，而<strong>不会</strong>向服务器发送请求获取对应资源。</li>
</ol>
<p>首先进行 <strong>强制缓存</strong> 查找，才到 <strong>协商缓存</strong></p>
<ul>
<li><p>浏览器首次加载资源成功时，服务器返回 200，此时浏览器不仅将资源下载下来，而且把 response 的 header(里面的 date 属性非常重要，用来计算第二次相同资源时当前时间和 date 的时间差)一并缓存;</p>
</li>
<li><p>下一次加载资源时，首先要经过强缓存的处理。<strong>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 Expires 和 Cache-Control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信</strong>。其中 <code>Cache-Control</code> 的优先级最高，如果 <code>Cache-Control：no-cache</code>，就直接进入到协商缓存的步骤了，如果 <code>Cache-Control：max-age=xxx</code>,就会先比较当前时间和上一次返回 200 时的时间差，如果没有超过 max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有 <code>Cache-Control</code>，会取 <code>Expires</code> 的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存;</p>
</li>
<li><p>协商缓存阶段，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求，前者优先级大于第二个，所以先讲第一个对应关系 请求头的 <code>If-None-Match</code> 和 响应头的 <code>Etag</code>。服务器会比较这两个字段值，如果相同，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 <code>Etag</code> 值并返回 200。</p>
</li>
<li><p>协商缓存第二个对应关系是 <code>If-Modified-Since</code> 和 <code>Last-modified</code>，如果客户端发送的 If-Modified-Since 的值跟服务器端获取的文件<strong>最近改动的时间</strong>，一致则命中协商缓存，返回 304；不一致则返回新的 <code>Last-modified</code> 和文件并返回 200;</p>
</li>
</ul>
<h4 id="为什么协商缓存中-Etag-优先级大于-Last-modified-？"><a href="#为什么协商缓存中-Etag-优先级大于-Last-modified-？" class="headerlink" title="为什么协商缓存中 Etag 优先级大于 Last-modified ？"></a>为什么协商缓存中 Etag 优先级大于 Last-modified ？</h4><p> 因为后者是标识着资源的最后修改时间(<strong>不准确，因为修改了文件并不代表文件内容发生改变，可能改变后又撤销了</strong>)，前者可以理解为是一个<strong>资源唯一标识符</strong>，是服务器通过内置算法根据文件内容生成的 <code>hash</code> 值，所以<strong>更准确</strong>，当然，因为计算所以<strong>性能消耗更大</strong>，不太推荐使用 <code>Etag</code></p>
<h4 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h4><blockquote>
<p><strong>什么是 <code>from disk cache</code> 和 <code>from memory cache</code>，什么时候会触发？</strong></p>
</blockquote>
<ul>
<li>强缓存会触发，大致解释如下：</li>
</ul>
<ol>
<li><p>先查找内存，如果内存中存在，从内存中加载；</p>
</li>
<li><p>如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；</p>
</li>
<li><p>如果硬盘中未查找到，那就进行网络请求；</p>
</li>
<li><p>加载到的资源缓存到硬盘和内存；</p>
</li>
</ol>
<blockquote>
<p><strong>什么是启发式缓存，在什么条件下触发？</strong></p>
</blockquote>
<p><strong>启发式缓存:</strong></p>
<p>如果响应中未显示 <code>Expires</code>，<code>Cache-Control：max-age</code> 或 <code>Cache-Control：s-maxage</code>，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 <code>Date</code> 减去 <code>Last-Modified</code> 值的 <strong>10%</strong> 作为缓存时间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-type">Date</span> 减去 <span class="hljs-keyword">Last</span><span class="hljs-operator">-</span>Modified 值的 <span class="hljs-number">10</span><span class="hljs-operator">%</span> 作为缓存时间。<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-type">Date</span>：创建报文的日期时间, <span class="hljs-keyword">Last</span><span class="hljs-operator">-</span>Modified 服务器声明文档最后被修改时间<br>  response_is_fresh <span class="hljs-operator">=</span>  <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,（<span class="hljs-type">Date</span> <span class="hljs-operator">-</span>  <span class="hljs-keyword">Last</span><span class="hljs-operator">-</span>Modified)) <span class="hljs-operator">%</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>看到这里是不是感觉有点累了？坚持住！后面还有更丰富的知识等着你去探索！</strong><br><br></br></p>
</blockquote>
<h3 id="6-发起HTTP请求"><a href="#6-发起HTTP请求" class="headerlink" title="6. 发起HTTP请求"></a>6. 发起HTTP请求</h3><p>浏览器首先会向服务器发送请求行，请求行中包含了请求方法、请求 URI 和 HTTP 版本，还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核、请求域名、Cookie 等信息。<br><br></br></p>
<h3 id="7-服务器处理请求"><a href="#7-服务器处理请求" class="headerlink" title="7. 服务器处理请求"></a>7. 服务器处理请求</h3><p>服务器首先返回相应行，包括协议版本和状态码，然后会返回响应头包含返回的数据类型，服务器要在客户端保存的 <code>Cookie</code> 等，一般来说是返回 <code>HTML</code>、<code>CSS</code>、<code>JS</code>、<code>Image</code> 文件<br><br></br></p>
<h3 id="8-断开TCP连接"><a href="#8-断开TCP连接" class="headerlink" title="8. 断开TCP连接"></a>8. 断开TCP连接</h3><p>数据传输完成后，通过四次挥手来断开连接。</p>
<p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c110ff90ddc49809ade8d67d263de00~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"></p>
<p><strong>第一次挥手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
<p><strong>第二次挥手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
<p><strong>第三次挥手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
<p><strong>第四次挥手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<blockquote>
<p><strong>A：我要断开连接啦<br />B：好的，你先断开，等我把我这边的数据传完给你我再断<br />过了一会儿，等B传完后<br />B：我传完啦，我也可以断开跟你的连接了，听到了吗<br />A：知道你也断开连接啦，你先断，我过 2MSL 再断，不然怕你听不见我跟你说的话</strong><br><br></br></p>
</blockquote>
<h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>TCP 协议是一种面向连接的、可靠的、基于<strong>字节流</strong>的运输层通信协议。TCP 是全双工模式，这就意味着，当主机1发出FIN 报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 ACK 报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了 FIN 报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>
<h4 id="为什么要等待-2MSL？"><a href="#为什么要等待-2MSL？" class="headerlink" title="为什么要等待 2MSL？"></a>为什么要等待 2MSL？</h4><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。<br>原因有二：</p>
<ul>
<li>保证TCP协议的全双工连接能够<strong>可靠关闭</strong></li>
<li>保证这次连接的<strong>重复数据段</strong>从网络中消失</li>
</ul>
<p>第一点：如果主机1直接 CLOSED 了，那么由于 IP 协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的 ACK。那么主机2就会在超时之后继续发送 FIN，此时由于主机1已经 CLOSED 了，就找不到与重发的 FIN 对应的连接。所以，主机1不是直接进入 CLOSED，而是要保持 TIME_WAIT，当再次收到FIN的时候，能够保证对方收到 ACK，最后正确的关闭连接。</p>
<p>第二点：如果主机1直接 CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP 协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以 TCP 连接还要在 TIME_WAIT 状态等待2倍 MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<blockquote>
<p><strong>关于三握四挥的内容，在谢希仁的《计算机网络》一书中讲的非常透彻，有时间的可以进行查阅</strong></p>
</blockquote>
<p><br></br></p>
<h2 id="三、准备渲染进程阶段"><a href="#三、准备渲染进程阶段" class="headerlink" title="三、准备渲染进程阶段"></a>三、准备渲染进程阶段</h2><ol>
<li>网络进程将获取的数据进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器去下载，如果是 text&#x2F;html 类型，就通知浏览器进程获取到的是 HTML，准备渲染进程。</li>
<li>一般情况下浏览器的一个 tab 页面对应一个渲染进程，如果从当前页面打开的新页面并且属于同一站点，这种情况会复用渲染进程，其他情况则需要创建新的渲染进程。</li>
</ol>
<blockquote>
<p>有需要的小伙伴可以了解一下 <strong>安全沙箱</strong> 和 <strong>站点隔离</strong> 的概念</p>
</blockquote>
<h2 id="四、提交文档阶段"><a href="#四、提交文档阶段" class="headerlink" title="四、提交文档阶段"></a>四、提交文档阶段</h2><ol>
<li>渲染进程准备好之后，浏览器会发出提交文档的消息给<strong>渲染进程</strong>，渲染进程收到消息后，会和<strong>网络进程</strong>建立数据传输的管道（IPC），文档数据传输完成后，渲染进程会返回确认提交的消息给<strong>浏览器进程</strong>。</li>
<li>浏览器收到确认提交的消息后，会更新浏览器的页面状态，包括了安全状态，地址栏的URL，前进后退的历史状态，并<strong>更新 web 页面为空白</strong>。</li>
</ol>
<h2 id="五、页面渲染阶段"><a href="#五、页面渲染阶段" class="headerlink" title="五、页面渲染阶段"></a>五、页面渲染阶段</h2><h3 id="简单来说，可以总结为如下阶段"><a href="#简单来说，可以总结为如下阶段" class="headerlink" title="简单来说，可以总结为如下阶段"></a><strong>简单来说，可以总结为如下阶段</strong></h3><blockquote>
<p>返回 html 之后，会解析 html,然后 cssom + domTree &#x3D; html，然后布局和绘制</p>
</blockquote>
<ul>
<li>构建 DOM 树(DOM tree)：从上到下解析 HTML 文档生成 DOM 节点树（DOM tree），也叫内容树（content tree）；</li>
<li>构建 CSSOM(CSS Object Model)树：加载解析样式生成 CSSOM 树；</li>
<li>执行 JavaScript：加载并执行 JavaScript 代码（包括内联代码或外联JavaScript文件）；</li>
<li>构建渲染树(render tree)：根据 DOM 树和 CSSOM 树,生成渲染树(render tree)；</li>
<li>渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。</li>
<li>布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；</li>
<li>绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；</li>
</ul>
<h3 id="详细展开"><a href="#详细展开" class="headerlink" title="详细展开"></a><strong>详细展开</strong></h3><ol>
<li><p>文档提交之后，渲染进程将开始<strong>页面解析</strong>并加载子资源。</p>
</li>
<li><p>构建 DOM 树：HTML 经过解析后输出的是一个以 document 为顶层节点的树状结构的 DOM。</p>
</li>
<li><p>样式计算：将从 link 标签引入的外部样式，style 标签里的样式和元素身上的样式转换成浏览器能够理解的样式表，然后将样式表中的属性值进行标准化，例如 color:red 转换为 color 的 rgb 形式，然后根据 CSS 的继承和层叠规则计算出 DOM 树种每个节点的具体样式。</p>
</li>
<li><p>布局阶段：会生成一棵只包含可见元素的布局树，然后根据布局树的每个节点计算出其具体位置和大小。</p>
</li>
<li><p>分层：对页面种的复杂效果例如 3D 转换，页面滚动或者z轴排序等生成图层树。</p>
</li>
<li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程中。</p>
</li>
<li><p>光栅化：优先选择可视窗口内的图块来生成位图数据。</p>
</li>
<li><p>合成：所有图块都被光栅话之后开始显示页面。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>可以总结为如下：1.网络线程获取 html 数据后，通过 IPC 将数据传给渲染器进程的主线程，主线程将 html 解析构建 dom 树，然后进行样式计算。根据 dom 树和生成好的样式生成 layout tree ，通过遍历 layout tree 生成绘制顺序表，接着遍历 layout tree 生成 layer tree。2.主线程将 layer tree 和绘制顺序信息一起传给合成器线程，合成器线程按照规则进行分图层，并把图层分为更小的图块 tiles 传给栅格线程进行栅格化。3.栅格化完成后合成器线程会收到栅格化线程传过来的 draw quads 图块信息，根据这些信息，合成器线上合成了一个合成器帧。然后将该合成器帧通过 IPC 传给浏览器进程，浏览器进程再传到 gpu 进行渲染，最后就展示在屏幕上了。</p>
<h3 id="关于页面渲染阻塞"><a href="#关于页面渲染阻塞" class="headerlink" title="关于页面渲染阻塞"></a>关于页面渲染阻塞</h3><p>由于浏览器解析并渲染 DOM 元素占用的是主线程，对于图片、CSS 等文件在下载时不会阻塞浏览器渲染，但 JS 就不一样了，浏览器遇到 <code>&lt;script&gt;</code> 标签引入的 JS 时，会停止渲染，等 JS 文件下载并执行完后，才将主线程控制器归还给浏览器进行继续渲染</p>
<h4 id="导致的问题"><a href="#导致的问题" class="headerlink" title="导致的问题"></a>导致的问题</h4><p>由上面描述可知，<strong>浏览器渲染(布局和绘制)</strong> 和 JS 文件的<strong>处理</strong>都要占用主线程，但如果 JS 文件特别大，下载和执行占用的时间非常长，<strong>我们都知道一个知识点，当页面以每秒60帧的频率刷新，才不会让用户感受到页面卡顿</strong>。在浏览器要绘制下一帧页面时，无法及时将浏览器主线程控制权归还，那么就会导致无法及时绘制下一帧的问题，这时对于我们用户来说的直观感受就是，<strong>出现页面卡顿</strong>。</p>
<p><strong>每一帧绘制结束后，还有剩余时间</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe779052dbf4b3d832a453490cbcb86~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"></p>
<p><strong>当 JS 过大</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6844f2fc8a4b2dac5e4367e9e72789~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"><br><br></br></p>
<h4 id="有什么解决方案呢？"><a href="#有什么解决方案呢？" class="headerlink" title="有什么解决方案呢？"></a>有什么解决方案呢？</h4><p>可以先自己思考，过一段时间后再去查看后面的 RQ1 获得解决方案</p>
<blockquote>
<p>关于浏览器渲染过程，推荐观看 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x54y1B7RE">此视频</a><br><br></br></p>
</blockquote>
<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="A-amp-Q1：浏览器渲染卡顿的解决方法"><a href="#A-amp-Q1：浏览器渲染卡顿的解决方法" class="headerlink" title="A &amp; Q1：浏览器渲染卡顿的解决方法"></a>A &amp; Q1：浏览器渲染卡顿的解决方法</h3><h4 id="1-可以通过-requestAnimationFrame-来解决"><a href="#1-可以通过-requestAnimationFrame-来解决" class="headerlink" title="1. 可以通过 requestAnimationFrame() 来解决"></a>1. <strong>可以通过 <code>requestAnimationFrame()</code> 来解决</strong></h4><p>这是浏览器的官方 API，此方法会在每一帧被调用，通过 API 的回调，我们可以把 JS 运行任务分成一些更小的任务快（分到每一帧），在每一帧时间用完前暂停 JS 执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制</p>
<p><strong>React 最新的渲染引擎 React Fiber 就是用到了这个 API 做了很多优化（时间分片）</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/459881fadc66431f83796d65f90504d6~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e52946b40143aba2e11e820d1f1108~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"></p>
<h4 id="2-为-lt-script-gt-标签加上-async-或-defer-属性"><a href="#2-为-lt-script-gt-标签加上-async-或-defer-属性" class="headerlink" title="2. 为 &lt;script&gt; 标签加上 async 或 defer 属性"></a>2. 为 <code>&lt;script&gt;</code> 标签加上 <code>async</code> 或 <code>defer</code> 属性</h4><ul>
<li><p><code>async</code>：异步执行，当浏览器在渲染时，可以同时下载<code>&lt;script&gt;</code> 对应的 <code>JS</code> 文件，当下载结束后，才停止浏览器渲染，执行完 JS 后，再继续渲染</p>
</li>
<li><p><code>defer</code>：延迟执行，当浏览器全部页面布局绘制完成，才下载并执行 JS 文件</p>
</li>
</ul>
<h4 id="3-这里就要提到-CSS-中的一个动画属性-transform-了"><a href="#3-这里就要提到-CSS-中的一个动画属性-transform-了" class="headerlink" title="3. 这里就要提到 CSS 中的一个动画属性 transform 了"></a>3. 这里就要提到 CSS 中的一个动画属性 <code>transform</code> 了</h4><p>由于栅格化的整个流程是不占用主线程的，只在下面的 <strong>合成器线程 + 栅格线程</strong>中执行，意味着它<strong>无需和 JS 抢夺主线程</strong>，我们如果反复进行重排和重绘，可能会导致掉帧，这是因为有可能 <strong>JS 执行阻塞了主线程</strong>，而经 <code>transform</code> 实现的动画<strong>不会经过布局和绘制</strong>，而是直接运行在合成器线程和栅格线程，所以不会受到主线程中 JS 执行的影响，所以节省了很多时间，减轻了主线程的压力。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490b1a9e5e6d46e38ced9826ab5a50fb~tplv-k3u1fbpfcp-watermark.image" srcset="/img/loading2.gif" lazyload alt="image.png"><br><br></br></p>
<h3 id="A-amp-Q2：cssom-渲染会不会阻塞-dom-渲染，会不会阻塞-dom-树建立？"><a href="#A-amp-Q2：cssom-渲染会不会阻塞-dom-渲染，会不会阻塞-dom-树建立？" class="headerlink" title="A &amp; Q2：cssom 渲染会不会阻塞 dom 渲染，会不会阻塞 dom 树建立？"></a>A &amp; Q2：cssom 渲染会不会阻塞 dom 渲染，会不会阻塞 dom 树建立？</h3><p>会，不会。</p>
<p>当一个样式表被后台下载时，JavaScript 仍然可以执行，因为主线程没有被加载的样式表所阻挡。如果我们的 JavaScript 程序访问 DOM 元素的 CSS 属性（通过 CSSOM API），<br>我们会得到一个合适的值（根据 CSSOM 的当前状态）。但是一旦样式表被下载和解析，导致 CSSOM 更新，我们的 JavaScript 现在有一个过时的元素的 CSS 值，<br>因为新的 CSSOM 更新可能已经改变了该 DOM 元素的 CSS 属性。由于这个原因，在下载样式表的时候<strong>执行 JavaScript 是不安全的，而 JS 通常会有些操作影响 dom 渲染</strong>。</p>
<p>就像 async 或 defer 属性使 script 元素不阻塞解析一样，外部的样式表也可以通过 media 属性使其不阻塞渲染。使用 media 属性值，浏览器可以智能地决定何时去加载样式表<br><br></br></p>
<h3 id="A-amp-Q3：页面渲染优化的方法"><a href="#A-amp-Q3：页面渲染优化的方法" class="headerlink" title="A &amp; Q3：页面渲染优化的方法"></a>A &amp; Q3：页面渲染优化的方法</h3><ul>
<li>HTML文档结构层次尽量少，最好不深于六层；</li>
<li>脚本尽量后放，放在前即可；</li>
<li>少量首屏样式内联放在标签内；</li>
<li>样式结构层次尽量简单；</li>
<li>在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；</li>
<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>
<li>动画尽量使用在绝对定位或固定定位的元素上；</li>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li>
<li>尽量缓存DOM查找，查找器尽量简洁；</li>
<li>涉及多域名的网站，可以开启域名预解析</li>
</ul>
<h3 id="A-amp-Q4：强缓存和协商缓存发生在那个阶段？"><a href="#A-amp-Q4：强缓存和协商缓存发生在那个阶段？" class="headerlink" title="A &amp; Q4：强缓存和协商缓存发生在那个阶段？"></a>A &amp; Q4：强缓存和协商缓存发生在那个阶段？</h3><blockquote>
<p>强缓存和协商缓存发生在发起 URL 请求阶段，在这个阶段构建请求行之后会查找缓存。</p>
</blockquote>
<h3 id="A-amp-Q5：DNS解析中端口需要DNS解析吗？"><a href="#A-amp-Q5：DNS解析中端口需要DNS解析吗？" class="headerlink" title="A &amp; Q5：DNS解析中端口需要DNS解析吗？"></a>A &amp; Q5：DNS解析中端口需要DNS解析吗？</h3><blockquote>
<p>不需要，因为 HTTP 默认的是80端口，HTTPS 默认的是443端口，如果要指定端口可以直接在 URL 里面添加。</p>
</blockquote>
<h3 id="A-amp-Q6：上述哪些阶段可以优化？"><a href="#A-amp-Q6：上述哪些阶段可以优化？" class="headerlink" title="A &amp; Q6：上述哪些阶段可以优化？"></a>A &amp; Q6：上述哪些阶段可以优化？</h3><h4 id="1-优化-DNS-查询：DNS-预解析"><a href="#1-优化-DNS-查询：DNS-预解析" class="headerlink" title="1.  优化 DNS 查询：DNS 预解析"></a>1.  优化 DNS 查询：DNS 预解析</h4><p>前端的 <code>DNS</code> 优化，可以在 <code>html</code> 页面头部写入 <code>DNS</code> 缓存地址，比如</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;meta http-equiv<span class="hljs-operator">=</span><span class="hljs-string">&quot;x-dns-prefetch-control&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;on&quot;</span> /&gt;<br>&lt;link rel<span class="hljs-operator">=</span><span class="hljs-string">&quot;dns-prefetch&quot;</span> href<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://bdimg.share.baidu.com&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<h4 id="2-优化TCP连接：可以通过请求头-keep-alive-来优化。"><a href="#2-优化TCP连接：可以通过请求头-keep-alive-来优化。" class="headerlink" title="2.  优化TCP连接：可以通过请求头 keep-alive 来优化。"></a>2.  优化TCP连接：可以通过请求头 keep-alive 来优化。</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">keep-alive</span><span class="hljs-punctuation">: </span>connection<br></code></pre></td></tr></table></figure>

<p>在本次 TCP 请求结束后，不主动断开，下次还需要 TCP 连接时就省了，直接在这个 TCP 管道进行传输即可</p>
<blockquote>
<p><strong>即节省了进行三次握手的建立 TCP 连接过程</strong></p>
</blockquote>
<h4 id="3-优化-HTTP-响应报文：通过-CDN-和-Gzip-压缩。"><a href="#3-优化-HTTP-响应报文：通过-CDN-和-Gzip-压缩。" class="headerlink" title="3.  优化 HTTP 响应报文：通过 CDN 和 Gzip 压缩。"></a>3.  优化 HTTP 响应报文：通过 CDN 和 Gzip 压缩。</h4><p><br></br></p>
<h3 id="A-amp-Q7：常见-http-请求报文头有哪些？"><a href="#A-amp-Q7：常见-http-请求报文头有哪些？" class="headerlink" title="A &amp; Q7：常见 http 请求报文头有哪些？"></a>A &amp; Q7：常见 http 请求报文头有哪些？</h3><ul>
<li><code>User-Agent</code> 浏览器类型</li>
<li><code>Content-Type</code>  报文类型</li>
<li><code>Connection</code>  完成传输是否关闭 TCP 连接</li>
<li><code>Host</code>  访问主机域名</li>
<li><code>Content-Length</code>  内容长度</li>
<li><code>Accept</code>  允许接收的数据类型</li>
<li><code>Accept-Language</code>  允许接收的语言</li>
<li><code>Cookie</code>  用户标识符</li>
<li><code>cache-control</code>  强缓存限制条件，存活时间</li>
<li><code>expires</code>  强缓存限制条件，被上面的替代了</li>
<li><code>etag</code>  协商缓存限制条件，过期的时刻</li>
<li><code>last-modified</code>  协商缓存限制条件，最后修改时间</li>
<li><code>date</code>  时间</li>
</ul>
<p>等等，还有很多，就不一一列举了<br><br></br></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我是 Smoothzjc，致力于产出更多且不仅限于前端方面的优质文章</p>
<p>大家也可以关注我的公众号 @ <strong>Smooth前端成长记录</strong>，及时通过移动端获取到最新文章消息！</p>
<p>写作不易，<strong>「点赞」+「收藏」+「转发」</strong> 谢谢支持❤</p>
<h2 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7065882915791437855">《都2022年了还不考虑来学React Hook吗？6k字带你从入门到吃透》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7068256695620730910">《一份不可多得的 Webpack 学习指南（1万字长文带你入门 Webpack 并掌握常用的进阶配置）》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7071052780063948837">《【offer 收割机之 CSS 回顾系列】请你解释一下什么是 BFC ？他的应用场景有哪些？》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7064515729298554887">《Github + hexo 实现自己的个人博客、配置主题（超详细）》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7064024606276845581">《10分钟让你彻底理解如何配置子域名来部署多个项目》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7064005333437382670">《一文理解配置伪静态解决 部署项目刷新页面404问题</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7060803746560737293">《带你3分钟掌握常见的水平垂直居中面试题》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993934486954049550">《【建议收藏】长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993350461172482078">《浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)》</a></p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-chain-item">计算机网络</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" class="category-chain-item">浏览器原理</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/">#面试系列</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
        <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">#浏览器原理</a>
      
    </div>
  
</div>


              
  

  <p class="note note-warning" style="font-weight: 600">
    作者：Smooth<br /><br />
    文章链接：http://example.com/2022/03/17/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89%E4%BB%8E%20URL%20%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/<br /><br />
    版权说明：本博客所有文章除特别声明外，均采用 CC BY-SA 4.0 协议 ，转载请注明出处！
  </p>
  <br />
  <!-- <div class="license-box my-3">
    <div class="license-title">
      <div>【offer 收割机之面试必备】（建议收藏）从 URL 输入到页面展现的全过程</div>
      <div>http://example.com/2022/03/17/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89%E4%BB%8E%20URL%20%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smooth</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月17日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div> -->




              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/20/%E9%80%9A%E8%BF%87%20React15%20~%2017%20%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%AD%E4%BB%A3%E6%9D%A5%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%20Fiber/" title="通过 React15 ~ 17 的优化迭代来简单聊聊 Fiber">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">通过 React15 ~ 17 的优化迭代来简单聊聊 Fiber</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/16/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%20CSS%20%E5%9B%9E%E9%A1%BE%E7%B3%BB%E5%88%97%E3%80%91%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%20BFC%20%EF%BC%9F%E4%BB%96%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" title="【offer 收割机之 CSS 回顾系列】请你解释一下什么是 BFC ？他的应用场景有哪些？">
                        <span class="hidden-mobile">【offer 收割机之 CSS 回顾系列】请你解释一下什么是 BFC ？他的应用场景有哪些？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.staticfile.org/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"GyO1gYwBSAE9WDPDP832Neqt-gzGzoHsz","appKey":"AAsGHr7sWjnMsyKVxj62V6IJ","path":"window.location.pathname","placeholder":"请不要奢侈你的评论ヾﾉ≧∀≦)o","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://juejin.cn/user/1302297507801358" target="_blank" rel="nofollow noopener"><span>掘金 | </span></a> <a href="https://i.csdn.net/#/user-center/profile" target="_blank" rel="nofollow noopener"><span>CSDN</span></a> 
      <!--《添加网站运行时间 -->
<br/>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

<script>
var now = new Date(); 

function createtime() {
    //此处修改你的建站时间或者网站上线时间
    var grt = new Date('02/10/2022 8:00:00');
    now.setTime(now.getTime() + 250);
    days = (now - grt) / 1000 / 60 / 60 / 24;

    dnum = Math.floor(days);
    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
        hnum = "0" + hnum;
    }
    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
        mnum = "0" + mnum;
    }
    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
        snum = "0" + snum;
    }
    document.getElementById("timeDate").innerHTML = "🚀 &nbsp本站已安全运行 " + dnum + " 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()", 250);
</script>

<!-- 添加网站运行时间》-->

    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2021153967"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading2.gif" lazyload alt="police-icon"/>
          
          <span>粤ICP备2021153967号-1</span>
        </a>
      </span>
    
  
</div>

  
  
</div>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  
    <script  src="/js/img-lazyload.js" ></script>
  



  <script  src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var title = subtitle.title;
      
        typing(title);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  





  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/jingtaisidai.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
</html>
