<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通过 React15 ~ 17 的优化迭代来简单聊聊 Fiber</title>
    <link href="/2022/03/20/%E9%80%9A%E8%BF%87%20React15%20~%2017%20%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%AD%E4%BB%A3%E6%9D%A5%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%20Fiber/"/>
    <url>/2022/03/20/%E9%80%9A%E8%BF%87%20React15%20~%2017%20%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%AD%E4%BB%A3%E6%9D%A5%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%20Fiber/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 本篇文章是我在复习 Fiber 时，查看了多篇文章之后，结合成的精华<br /> 🙌 如文章有误，恳请评论区指正，谢谢！<br /> ❤ 写作不易，「点赞」+「收藏」+「转发」 谢谢支持！</strong></strong></p></blockquote><p><a href="https://juejin.cn/editor/drafts/7077477610871062536">原文章链接</a></p><h2 id="React渲染页面的两个阶段"><a href="#React渲染页面的两个阶段" class="headerlink" title="React渲染页面的两个阶段"></a>React渲染页面的两个阶段</h2><p>首先，明确两个阶段，有助于后面对文章的理解</p><ol><li>调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，<strong>得到新的更新队列</strong>。</li><li>渲染阶段（commit）：这个阶段 React 会遍历更新队列，<strong>将其所有的变更一次性更新到DOM上</strong>。</li></ol><h3 id="React-15-架构"><a href="#React-15-架构" class="headerlink" title="React 15 架构"></a>React 15 架构</h3><p>React15架构可以分为两层：</p><ul><li>Reconciler（协调器）—— 负责找出变化的组件；</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上；</li></ul><p>  在React15及以前，Reconciler采用递归的方式创建虚拟DOM，<strong>递归过程是不能中断的</strong>。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。</p><p>  为了解决这个问题，React16将递归的无法中断的更新重构为<strong>异步的可中断更新</strong>，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的 <strong>Fiber 架构</strong>应运而生。</p><h3 id="React-16-架构"><a href="#React-16-架构" class="headerlink" title="React 16 架构"></a>React 16 架构</h3><p>  为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现Concurrent Mode（并发模式）。</p><p>  从v15到v16，React团队花了两年时间将源码架构中的Stack Reconciler重构为Fiber Reconciler。</p><p>React16架构可以分为三层：</p><ul><li>Scheduler（调度器）—— <strong>调度任务的优先级</strong>，高优任务优先进入Reconciler；</li><li>Reconciler（协调器）—— 负责找出变化的组件：<strong>更新工作从递归变成了可以中断的循环过程。Reconciler内部采用了Fiber的架构</strong>；</li><li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上。</li></ul><h3 id="React-17-优化"><a href="#React-17-优化" class="headerlink" title="React 17 优化"></a>React 17 优化</h3><p>  React16的<strong>expirationTimes模型</strong>只能区分是否<code>&gt;=expirationTimes</code>决定节点是否更新。React17的<strong>lanes模型</strong>可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。</p><blockquote><p>Lane用<strong>二进制位</strong>表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“<strong>赛道</strong>”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。</p></blockquote><p>Concurrent Mode的目的是实现一套可中断&#x2F;恢复的更新机制。其由两部分组成：</p><ul><li>一套协程架构：Fiber Reconciler</li><li>基于协程架构的启发式更新算法：控制协程架构工作方式的算法</li></ul><h2 id="什么是-Fiber"><a href="#什么是-Fiber" class="headerlink" title="什么是 Fiber"></a>什么是 Fiber</h2><p>  Fiber 的英文含义是“纤维”，它是比线程（Thread）更细的线，比线程（Thread）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（Cooperative）编程模型（协程），帮助开发者用一种【既模块化又协作化】的方式来编排代码。</p><p>  在 React 中，<strong>Fiber 就是 React 16 实现的一套新的更新机制，让 React 的更新过程变得可控，避免了之前采用递归需要一气呵成影响性能的做法</strong>。</p><h3 id="React-Fiber-中的时间分片"><a href="#React-Fiber-中的时间分片" class="headerlink" title="React Fiber 中的时间分片"></a>React Fiber 中的时间分片</h3><p>  把一个<strong>耗时长的任务分成很多小片</strong>，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都<strong>给其他任务一个执行的机会</strong>，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</p><p>  React Fiber 把更新过程<strong>碎片化</strong>，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p><h3 id="Fiber-Reconciler"><a href="#Fiber-Reconciler" class="headerlink" title="Fiber Reconciler"></a>Fiber Reconciler</h3><h4 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h4><p>  在 React Fiber 中<strong>用链表遍历的方式替代了 React 16 之前的栈递归方案</strong>。在 React 16 中使用了大量的链表。</p><ul><li>使用多向链表的形式替代了原来的树结构；</li></ul><p>链表相比顺序结构数据格式的<strong>好处</strong>就是：</p><ol><li>操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。</li><li>不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。</li></ol><p>但链表也不是完美的，<strong>缺点</strong>就是：</p><ol><li>比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。</li><li>不能自由读取，必须找到他的上一个节点。</li></ol><p>  React 用<strong>空间换时间</strong>，更高效的操作可以方便根据优先级进行操作。同时<strong>可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用</strong>。</p><h2 id="你对-React-Fiber-的了解？为什么要使用-Fiber？"><a href="#你对-React-Fiber-的了解？为什么要使用-Fiber？" class="headerlink" title="你对 React Fiber 的了解？为什么要使用 Fiber？"></a>你对 React Fiber 的了解？为什么要使用 Fiber？</h2><p><strong>因此，这个问题可以如下回答</strong></p><p>对于 Fiber，首先我先说一下为什么要使用他，首先 React 更新视图分为<strong>两个大阶段</strong>，第一个是基于 Reconciler 数据结构的调度阶段，第二个是渲染阶段。<strong>在 React15 及之前的版本</strong>，调度阶段采用的是 Stack Reconciler，即使用的是栈的数据结构，在渲染阶段采用的是递归进行更新。由于 React 将<strong>视图看作</strong>是一个个函数执行的结果，而每个页面又包含多个视图，会让栈中的函数层级非常深，而递归得一次性将这些函数运行完，容易造成 16.6ms 内<strong>无法及时执行完这些渲染更新</strong>，而无法在下一帧及时将控制权交还给渲染进程，无法及时绘制下一帧造成浏览器页面卡顿。</p><p>为了让更新过程变得可控，React16 采用的是 Fiber Reconciler ，核心思想是时间分片的思想，将一个大任务分解成多个小任务，当执行完每个小任务的更新时，能将控制权<strong>交还给浏览器负责任务调度的模块</strong>，这样可以在有紧急任务时进行执行，而不用“一心一意”执行更新。Fiber Reconciler 采用的是链表结构，通过指针可以将父节点、兄弟节点、子结点连接起来，好处是可以简化更新过程，<strong>变换一下链表指针就行</strong>，劣势是得知道某个结点的上一个结点才能进行更新，是一个典型的空间换时间的方法。</p><p>对于 React17，由于 React16 只能知道某个结点是否要更新，但 React17 能通过指定<strong>某个更新区间并设置优先级</strong>进行更新，能更加准确的将 React 更新过程分为三个阶段，第一是分配优先级阶段，第二个调度阶段，第三个是渲染阶段，让 React 可以处理更细粒度的更新。</p><p><strong>总结来说就是，Fiber 是 React16 实现的一套新的更新机制，让 React 的更新过程变得可控，避免了之前采用递归需要一气呵成影响性能的做法</strong><br><br></br></p><blockquote><p>版权说明：文章参考自 <a href="https://juejin.cn/post/6984949525928476703">React Fiber很难？六个问题助你理解 React Fiber</a></p></blockquote><p><br></br></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我是 Smoothzjc，致力于产出更多且不仅限于前端方面的优质文章</p><p>大家也可以关注我的公众号 @ <strong>Smooth前端成长记录</strong>，及时通过移动端获取到最新文章消息！</p><p>写作不易，<strong>「点赞」+「收藏」+「转发」</strong> 谢谢支持❤</p><h2 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h2><p><a href="https://juejin.cn/post/7065882915791437855">《都2022年了还不考虑来学React Hook吗？6k字带你从入门到吃透》</a></p><p><a href="https://juejin.cn/post/7068256695620730910">《一份不可多得的 Webpack 学习指南（1万字长文带你入门 Webpack 并掌握常用的进阶配置）》</a></p><p><a href="https://juejin.cn/post/7075290663998193694">《（建议收藏）从 URL 输入到页面展现的全过程》</a></p><p><a href="https://juejin.cn/post/7071052780063948837">《【offer 收割机之 CSS 回顾系列】请你解释一下什么是 BFC ？他的应用场景有哪些？》</a></p><p><a href="https://juejin.cn/post/7064515729298554887">《Github + hexo 实现自己的个人博客、配置主题（超详细）》</a></p><p><a href="https://juejin.cn/post/7064024606276845581">《10分钟让你彻底理解如何配置子域名来部署多个项目》</a></p><p><a href="https://juejin.cn/post/7064005333437382670">《一文理解配置伪静态解决 部署项目刷新页面404问题</a></p><p><a href="https://juejin.cn/post/7060803746560737293">《带你3分钟掌握常见的水平垂直居中面试题》</a></p><p><a href="https://juejin.cn/post/6993934486954049550">《【建议收藏】长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群》</a></p><p><a href="https://juejin.cn/post/6993350461172482078">《浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)》</a>8)</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【offer 收割机之面试必备】（建议收藏）从 URL 输入到页面展现的全过程</title>
    <link href="/2022/03/17/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89%E4%BB%8E%20URL%20%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/03/17/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E3%80%91%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%89%E4%BB%8E%20URL%20%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%8E%B0%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 本篇文章是我在复习该知识点时，查看了多篇文章之后，结合我自己的个人思考与理解汇聚而成的精华<br /> 🙌 如文章有误，恳请评论区指正，谢谢！<br /> ❤ 写作不易，「点赞」+「收藏」+「转发」 谢谢支持！</strong></p></blockquote><p><a href="https://juejin.cn/editor/drafts/7075290588198731790">原文章链接</a></p><h2 id="正文开始前你需知道的"><a href="#正文开始前你需知道的" class="headerlink" title="正文开始前你需知道的"></a>正文开始前你需知道的</h2><p>从输入URL到页面显示不仅仅是一道经典的面试题，这个知识点中涉及到了非常广泛的知识点，因此面试官可以通过这个问题有点到面的向候选人发起提问，来看看面试者在计算机网络和浏览器这方面知识的广度和深度。</p><p><strong>废话不多说，下面就开始吧！</strong><br><br></br></p><h2 id="一、用户输入阶段"><a href="#一、用户输入阶段" class="headerlink" title="一、用户输入阶段"></a>一、用户输入阶段</h2><blockquote><p>用户在地址栏输入内容之后，浏览器会首先判断用户输入的是合法的URL还是搜索内容，如果是搜索内容就合成URL，如果是合法的URL就开始进行加载。</p></blockquote><p>在这里，要明确我们具体要查找的东西到底是什么</p><h3 id="搜索内容"><a href="#搜索内容" class="headerlink" title="搜索内容"></a>搜索内容</h3><p>我们要搜索一些内容，例如去百度搜索引擎进行百度查找<strong>某个问题的答案</strong>，那么浏览器就会自动调用默认搜索引擎进行<strong>关键字</strong>的查找</p><h3 id="域名解析对应的-IP"><a href="#域名解析对应的-IP" class="headerlink" title="域名解析对应的 IP"></a>域名解析对应的 IP</h3><p>如果是合法的 URL，说明我们想通过该 URL(统一资源定位符) 查找到对应服务器上的该资源，那么要查找的实质就是 该域名解析后所对应的 IP 地址，即 <strong>域名与 IP 地址的一个映射关系</strong>。</p><p><strong>后面篇幅重点讲到的都是第二种情况，后续篇幅中我将其简称为 <code>映射关系</code></strong><br><br></br></p><h2 id="二、发起URL请求阶段"><a href="#二、发起URL请求阶段" class="headerlink" title="二、发起URL请求阶段"></a>二、发起URL请求阶段</h2><blockquote><p><strong>下面对发起URL请求阶段进行详细展开</strong></p></blockquote><h3 id="1-构建请求行"><a href="#1-构建请求行" class="headerlink" title="1. 构建请求行"></a>1. 构建请求行</h3><p>浏览器进程首先会构建请求行信息，然后通过进程间通信IPC将URL请求发送给网络进程。<br><br></br></p><h3 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h3><ol><li><p>先找浏览器本地的缓存</p></li><li><p>找操作系统 hosts 文件的缓存</p></li><li><p>以上两步都没找到需要的资源，就要进行网络请求啦，开始跟外界打交道，去<strong>本地 DNS 服务器</strong>（local DNS）进行查找，如果本地 DNS 服务器的缓存中已经存在该映射关系，那么直接返回，否则继续进行后续步骤（<strong>99% 的 DNS 解析到这一步就结束了，因为一般 <code>local DNS</code> 中存在大量映射关系缓存</strong>）。</p></li><li><p>本地 DNS 服务器作为代理服务器，向它上面的根域名服务器建立 TCP 连接后发出请求，根域名服务器返回<strong>查询域的主域名服务器</strong>（即 <code>gTLD</code>，像 <code>.COM</code>、 <code>.CN</code> 这种顶级域名）。</p></li><li><p>本地 DNS 服务器拿到后向 <code>gTLD</code> 发请求，<code>gTLD</code> 是可以找到你想查找域名的 <code>Name Server</code> 地址的，本地 DNS 服务器向 <code>Name Server</code> 地址发送请求，拿到该域名对应的 IP 和 TTL（time to live，即<strong>域名解析结果在DNS服务器中存活的时间</strong>），然后将结果先是自己做一个缓存（根据 TTL 设置映射存活时间），然后返回给浏览器，DNS 解析结束</p></li></ol><blockquote><p><strong>Name Server 概念</strong><br />服务商提供的服务器地址，比如你在阿里云注册的域名，那查找就是去阿里云的服务器查，因为你是去域名提供商的服务器发请求，那肯定是能拿到对应的ip地址的<br><br></br></p></blockquote><h3 id="3-等待-TCP-队列"><a href="#3-等待-TCP-队列" class="headerlink" title="3. 等待 TCP 队列"></a>3. 等待 TCP 队列</h3><p>chrome 有个机制，同一个域名同时最多只能建立6个TCP连接，如果超过这个数量的连接必须要进入排队等待状态。</p><blockquote><p>知识巩固<br />对于多路复用，http 1.1 采取<strong>建立多个 TCP 连接</strong>，http 2.0 采用建立<strong>一个</strong> TCP 连接<strong>并行发起多个请求</strong><br><br></br></p></blockquote><h3 id="4-建立-TCP-连接"><a href="#4-建立-TCP-连接" class="headerlink" title="4. 建立 TCP 连接"></a>4. 建立 TCP 连接</h3><p>通过TCP三次握手与服务器建立连接，然后进行数据传输。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f919eafbf848ab88f7281f1f212579~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p><p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p><p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><blockquote><p><strong>A：我要跟你建立连接，你那边接受得到我的请求吗？<br />B：接收到啦！没问题，但得向你确认下，证明这是你真实的要准备跟我建立的连接，而不是你很久之前发过的<br />A：对，没问题，这是我刚发给你的</strong><br><br></br></p></blockquote><h4 id="为什么要三次握手？两次可以吗？"><a href="#为什么要三次握手？两次可以吗？" class="headerlink" title="为什么要三次握手？两次可以吗？"></a>为什么要三次握手？两次可以吗？</h4><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子如下</p><blockquote><p><strong>已失效的连接请求报文段</strong> 的产生在这样一种情况下：client 发出的<strong>第一个</strong>连接请求报文段<strong>并没有丢失</strong>，而是在某个网络结点长时间的<strong>滞留</strong>了，以致<strong>延误</strong>到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的<strong>一个新的连接请求</strong>。于是就向 client 发出确认报文段，<strong>同意建立连接</strong>。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在 client 并没有发出<strong>新的建立连接</strong>请求，<strong>因此不会理睬 server 的确认</strong>，也不会向 server 发送数据。但 serve r却以为新的运输连接已经建立，并<strong>一直等待</strong> client 发来数据。这样，server 的很多资源就<strong>白白浪费掉</strong>了。采用“三次握手”的办法可以<strong>防止上述现象发生</strong>。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，<strong>就知道 client 并没有要求建立连接</strong>。”</p></blockquote><h4 id="四次握手可以吗？"><a href="#四次握手可以吗？" class="headerlink" title="四次握手可以吗？"></a>四次握手可以吗？</h4><p>可以但没必要</p><p>四次握手只是将第二次握手分解为了以下两个步骤</p><ol><li>先发送确认位 ACK &#x3D; 1，然后确认号 ack &#x3D; x + 1</li><li>再发送同步位 SYN &#x3D; 1，和序号 seq &#x3D; y<br><br></br><h3 id="5-查找缓存"><a href="#5-查找缓存" class="headerlink" title="5. 查找缓存"></a>5. 查找缓存</h3>建立好 TCP 连接后，会再次进行查找缓存，即我们熟知的 <strong>强制缓存</strong> 和 <strong>协商缓存</strong> ，如果找到了，服务器会返回 <strong>304 状态码</strong> 和 对应的缓存资源，而<strong>不会</strong>向服务器发送请求获取对应资源。</li></ol><p>首先进行 <strong>强制缓存</strong> 查找，才到 <strong>协商缓存</strong></p><ul><li><p>浏览器首次加载资源成功时，服务器返回 200，此时浏览器不仅将资源下载下来，而且把 response 的 header(里面的 date 属性非常重要，用来计算第二次相同资源时当前时间和 date 的时间差)一并缓存;</p></li><li><p>下一次加载资源时，首先要经过强缓存的处理。<strong>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 Expires 和 Cache-Control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信</strong>。其中 <code>Cache-Control</code> 的优先级最高，如果 <code>Cache-Control：no-cache</code>，就直接进入到协商缓存的步骤了，如果 <code>Cache-Control：max-age=xxx</code>,就会先比较当前时间和上一次返回 200 时的时间差，如果没有超过 max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有 <code>Cache-Control</code>，会取 <code>Expires</code> 的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存;</p></li><li><p>协商缓存阶段，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求，前者优先级大于第二个，所以先讲第一个对应关系 请求头的 <code>If-None-Match</code> 和 响应头的 <code>Etag</code>。服务器会比较这两个字段值，如果相同，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 <code>Etag</code> 值并返回 200。</p></li><li><p>协商缓存第二个对应关系是 <code>If-Modified-Since</code> 和 <code>Last-modified</code>，如果客户端发送的 If-Modified-Since 的值跟服务器端获取的文件<strong>最近改动的时间</strong>，一致则命中协商缓存，返回 304；不一致则返回新的 <code>Last-modified</code> 和文件并返回 200;</p></li></ul><h4 id="为什么协商缓存中-Etag-优先级大于-Last-modified-？"><a href="#为什么协商缓存中-Etag-优先级大于-Last-modified-？" class="headerlink" title="为什么协商缓存中 Etag 优先级大于 Last-modified ？"></a>为什么协商缓存中 Etag 优先级大于 Last-modified ？</h4><p> 因为后者是标识着资源的最后修改时间(<strong>不准确，因为修改了文件并不代表文件内容发生改变，可能改变后又撤销了</strong>)，前者可以理解为是一个<strong>资源唯一标识符</strong>，是服务器通过内置算法根据文件内容生成的 <code>hash</code> 值，所以<strong>更准确</strong>，当然，因为计算所以<strong>性能消耗更大</strong>，不太推荐使用 <code>Etag</code></p><h4 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h4><blockquote><p><strong>什么是 <code>from disk cache</code> 和 <code>from memory cache</code>，什么时候会触发？</strong></p></blockquote><ul><li>强缓存会触发，大致解释如下：</li></ul><ol><li><p>先查找内存，如果内存中存在，从内存中加载；</p></li><li><p>如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；</p></li><li><p>如果硬盘中未查找到，那就进行网络请求；</p></li><li><p>加载到的资源缓存到硬盘和内存；</p></li></ol><blockquote><p><strong>什么是启发式缓存，在什么条件下触发？</strong></p></blockquote><p><strong>启发式缓存:</strong></p><p>如果响应中未显示 <code>Expires</code>，<code>Cache-Control：max-age</code> 或 <code>Cache-Control：s-maxage</code>，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。通常会根据响应头中的2个时间字段 <code>Date</code> 减去 <code>Last-Modified</code> 值的 <strong>10%</strong> 作为缓存时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-type">Date</span> 减去 <span class="hljs-keyword">Last</span><span class="hljs-operator">-</span>Modified 值的 <span class="hljs-number">10</span><span class="hljs-operator">%</span> 作为缓存时间。<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-type">Date</span>：创建报文的日期时间, <span class="hljs-keyword">Last</span><span class="hljs-operator">-</span>Modified 服务器声明文档最后被修改时间<br>  response_is_fresh <span class="hljs-operator">=</span>  <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,（<span class="hljs-type">Date</span> <span class="hljs-operator">-</span>  <span class="hljs-keyword">Last</span><span class="hljs-operator">-</span>Modified)) <span class="hljs-operator">%</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>看到这里是不是感觉有点累了？坚持住！后面还有更丰富的知识等着你去探索！</strong><br><br></br></p></blockquote><h3 id="6-发起HTTP请求"><a href="#6-发起HTTP请求" class="headerlink" title="6. 发起HTTP请求"></a>6. 发起HTTP请求</h3><p>浏览器首先会向服务器发送请求行，请求行中包含了请求方法、请求 URI 和 HTTP 版本，还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核、请求域名、Cookie 等信息。<br><br></br></p><h3 id="7-服务器处理请求"><a href="#7-服务器处理请求" class="headerlink" title="7. 服务器处理请求"></a>7. 服务器处理请求</h3><p>服务器首先返回相应行，包括协议版本和状态码，然后会返回响应头包含返回的数据类型，服务器要在客户端保存的 <code>Cookie</code> 等，一般来说是返回 <code>HTML</code>、<code>CSS</code>、<code>JS</code>、<code>Image</code> 文件<br><br></br></p><h3 id="8-断开TCP连接"><a href="#8-断开TCP连接" class="headerlink" title="8. 断开TCP连接"></a>8. 断开TCP连接</h3><p>数据传输完成后，通过四次挥手来断开连接。</p><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c110ff90ddc49809ade8d67d263de00~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>第一次挥手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次挥手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p><strong>第三次挥手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p><strong>第四次挥手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><blockquote><p><strong>A：我要断开连接啦<br />B：好的，你先断开，等我把我这边的数据传完给你我再断<br />过了一会儿，等B传完后<br />B：我传完啦，我也可以断开跟你的连接了，听到了吗<br />A：知道你也断开连接啦，你先断，我过 2MSL 再断，不然怕你听不见我跟你说的话</strong><br><br></br></p></blockquote><h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>TCP 协议是一种面向连接的、可靠的、基于<strong>字节流</strong>的运输层通信协议。TCP 是全双工模式，这就意味着，当主机1发出FIN 报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 ACK 报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了 FIN 报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h4 id="为什么要等待-2MSL？"><a href="#为什么要等待-2MSL？" class="headerlink" title="为什么要等待 2MSL？"></a>为什么要等待 2MSL？</h4><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。<br>原因有二：</p><ul><li>保证TCP协议的全双工连接能够<strong>可靠关闭</strong></li><li>保证这次连接的<strong>重复数据段</strong>从网络中消失</li></ul><p>第一点：如果主机1直接 CLOSED 了，那么由于 IP 协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的 ACK。那么主机2就会在超时之后继续发送 FIN，此时由于主机1已经 CLOSED 了，就找不到与重发的 FIN 对应的连接。所以，主机1不是直接进入 CLOSED，而是要保持 TIME_WAIT，当再次收到FIN的时候，能够保证对方收到 ACK，最后正确的关闭连接。</p><p>第二点：如果主机1直接 CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP 协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以 TCP 连接还要在 TIME_WAIT 状态等待2倍 MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><blockquote><p><strong>关于三握四挥的内容，在谢希仁的《计算机网络》一书中讲的非常透彻，有时间的可以进行查阅</strong></p></blockquote><p><br></br></p><h2 id="三、准备渲染进程阶段"><a href="#三、准备渲染进程阶段" class="headerlink" title="三、准备渲染进程阶段"></a>三、准备渲染进程阶段</h2><ol><li>网络进程将获取的数据进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器去下载，如果是 text&#x2F;html 类型，就通知浏览器进程获取到的是 HTML，准备渲染进程。</li><li>一般情况下浏览器的一个 tab 页面对应一个渲染进程，如果从当前页面打开的新页面并且属于同一站点，这种情况会复用渲染进程，其他情况则需要创建新的渲染进程。</li></ol><blockquote><p>有需要的小伙伴可以了解一下 <strong>安全沙箱</strong> 和 <strong>站点隔离</strong> 的概念</p></blockquote><h2 id="四、提交文档阶段"><a href="#四、提交文档阶段" class="headerlink" title="四、提交文档阶段"></a>四、提交文档阶段</h2><ol><li>渲染进程准备好之后，浏览器会发出提交文档的消息给<strong>渲染进程</strong>，渲染进程收到消息后，会和<strong>网络进程</strong>建立数据传输的管道（IPC），文档数据传输完成后，渲染进程会返回确认提交的消息给<strong>浏览器进程</strong>。</li><li>浏览器收到确认提交的消息后，会更新浏览器的页面状态，包括了安全状态，地址栏的URL，前进后退的历史状态，并<strong>更新 web 页面为空白</strong>。</li></ol><h2 id="五、页面渲染阶段"><a href="#五、页面渲染阶段" class="headerlink" title="五、页面渲染阶段"></a>五、页面渲染阶段</h2><h3 id="简单来说，可以总结为如下阶段"><a href="#简单来说，可以总结为如下阶段" class="headerlink" title="简单来说，可以总结为如下阶段"></a><strong>简单来说，可以总结为如下阶段</strong></h3><blockquote><p>返回 html 之后，会解析 html,然后 cssom + domTree &#x3D; html，然后布局和绘制</p></blockquote><ul><li>构建 DOM 树(DOM tree)：从上到下解析 HTML 文档生成 DOM 节点树（DOM tree），也叫内容树（content tree）；</li><li>构建 CSSOM(CSS Object Model)树：加载解析样式生成 CSSOM 树；</li><li>执行 JavaScript：加载并执行 JavaScript 代码（包括内联代码或外联JavaScript文件）；</li><li>构建渲染树(render tree)：根据 DOM 树和 CSSOM 树,生成渲染树(render tree)；</li><li>渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。</li><li>布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；</li><li>绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；</li></ul><h3 id="详细展开"><a href="#详细展开" class="headerlink" title="详细展开"></a><strong>详细展开</strong></h3><ol><li><p>文档提交之后，渲染进程将开始<strong>页面解析</strong>并加载子资源。</p></li><li><p>构建 DOM 树：HTML 经过解析后输出的是一个以 document 为顶层节点的树状结构的 DOM。</p></li><li><p>样式计算：将从 link 标签引入的外部样式，style 标签里的样式和元素身上的样式转换成浏览器能够理解的样式表，然后将样式表中的属性值进行标准化，例如 color:red 转换为 color 的 rgb 形式，然后根据 CSS 的继承和层叠规则计算出 DOM 树种每个节点的具体样式。</p></li><li><p>布局阶段：会生成一棵只包含可见元素的布局树，然后根据布局树的每个节点计算出其具体位置和大小。</p></li><li><p>分层：对页面种的复杂效果例如 3D 转换，页面滚动或者z轴排序等生成图层树。</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程中。</p></li><li><p>光栅化：优先选择可视窗口内的图块来生成位图数据。</p></li><li><p>合成：所有图块都被光栅话之后开始显示页面。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>可以总结为如下：1.网络线程获取 html 数据后，通过 IPC 将数据传给渲染器进程的主线程，主线程将 html 解析构建 dom 树，然后进行样式计算。根据 dom 树和生成好的样式生成 layout tree ，通过遍历 layout tree 生成绘制顺序表，接着遍历 layout tree 生成 layer tree。2.主线程将 layer tree 和绘制顺序信息一起传给合成器线程，合成器线程按照规则进行分图层，并把图层分为更小的图块 tiles 传给栅格线程进行栅格化。3.栅格化完成后合成器线程会收到栅格化线程传过来的 draw quads 图块信息，根据这些信息，合成器线上合成了一个合成器帧。然后将该合成器帧通过 IPC 传给浏览器进程，浏览器进程再传到 gpu 进行渲染，最后就展示在屏幕上了。</p><h3 id="关于页面渲染阻塞"><a href="#关于页面渲染阻塞" class="headerlink" title="关于页面渲染阻塞"></a>关于页面渲染阻塞</h3><p>由于浏览器解析并渲染 DOM 元素占用的是主线程，对于图片、CSS 等文件在下载时不会阻塞浏览器渲染，但 JS 就不一样了，浏览器遇到 <code>&lt;script&gt;</code> 标签引入的 JS 时，会停止渲染，等 JS 文件下载并执行完后，才将主线程控制器归还给浏览器进行继续渲染</p><h4 id="导致的问题"><a href="#导致的问题" class="headerlink" title="导致的问题"></a>导致的问题</h4><p>由上面描述可知，<strong>浏览器渲染(布局和绘制)</strong> 和 JS 文件的<strong>处理</strong>都要占用主线程，但如果 JS 文件特别大，下载和执行占用的时间非常长，<strong>我们都知道一个知识点，当页面以每秒60帧的频率刷新，才不会让用户感受到页面卡顿</strong>。在浏览器要绘制下一帧页面时，无法及时将浏览器主线程控制权归还，那么就会导致无法及时绘制下一帧的问题，这时对于我们用户来说的直观感受就是，<strong>出现页面卡顿</strong>。</p><p><strong>每一帧绘制结束后，还有剩余时间</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe779052dbf4b3d832a453490cbcb86~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>当 JS 过大</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6844f2fc8a4b2dac5e4367e9e72789~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br></p><h4 id="有什么解决方案呢？"><a href="#有什么解决方案呢？" class="headerlink" title="有什么解决方案呢？"></a>有什么解决方案呢？</h4><p>可以先自己思考，过一段时间后再去查看后面的 RQ1 获得解决方案</p><blockquote><p>关于浏览器渲染过程，推荐观看 <a href="https://www.bilibili.com/video/BV1x54y1B7RE">此视频</a><br><br></br></p></blockquote><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="A-amp-Q1：浏览器渲染卡顿的解决方法"><a href="#A-amp-Q1：浏览器渲染卡顿的解决方法" class="headerlink" title="A &amp; Q1：浏览器渲染卡顿的解决方法"></a>A &amp; Q1：浏览器渲染卡顿的解决方法</h3><h4 id="1-可以通过-requestAnimationFrame-来解决"><a href="#1-可以通过-requestAnimationFrame-来解决" class="headerlink" title="1. 可以通过 requestAnimationFrame() 来解决"></a>1. <strong>可以通过 <code>requestAnimationFrame()</code> 来解决</strong></h4><p>这是浏览器的官方 API，此方法会在每一帧被调用，通过 API 的回调，我们可以把 JS 运行任务分成一些更小的任务快（分到每一帧），在每一帧时间用完前暂停 JS 执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制</p><p><strong>React 最新的渲染引擎 React Fiber 就是用到了这个 API 做了很多优化（时间分片）</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/459881fadc66431f83796d65f90504d6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e52946b40143aba2e11e820d1f1108~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="2-为-lt-script-gt-标签加上-async-或-defer-属性"><a href="#2-为-lt-script-gt-标签加上-async-或-defer-属性" class="headerlink" title="2. 为 &lt;script&gt; 标签加上 async 或 defer 属性"></a>2. 为 <code>&lt;script&gt;</code> 标签加上 <code>async</code> 或 <code>defer</code> 属性</h4><ul><li><p><code>async</code>：异步执行，当浏览器在渲染时，可以同时下载<code>&lt;script&gt;</code> 对应的 <code>JS</code> 文件，当下载结束后，才停止浏览器渲染，执行完 JS 后，再继续渲染</p></li><li><p><code>defer</code>：延迟执行，当浏览器全部页面布局绘制完成，才下载并执行 JS 文件</p></li></ul><h4 id="3-这里就要提到-CSS-中的一个动画属性-transform-了"><a href="#3-这里就要提到-CSS-中的一个动画属性-transform-了" class="headerlink" title="3. 这里就要提到 CSS 中的一个动画属性 transform 了"></a>3. 这里就要提到 CSS 中的一个动画属性 <code>transform</code> 了</h4><p>由于栅格化的整个流程是不占用主线程的，只在下面的 <strong>合成器线程 + 栅格线程</strong>中执行，意味着它<strong>无需和 JS 抢夺主线程</strong>，我们如果反复进行重排和重绘，可能会导致掉帧，这是因为有可能 <strong>JS 执行阻塞了主线程</strong>，而经 <code>transform</code> 实现的动画<strong>不会经过布局和绘制</strong>，而是直接运行在合成器线程和栅格线程，所以不会受到主线程中 JS 执行的影响，所以节省了很多时间，减轻了主线程的压力。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490b1a9e5e6d46e38ced9826ab5a50fb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br></p><h3 id="A-amp-Q2：cssom-渲染会不会阻塞-dom-渲染，会不会阻塞-dom-树建立？"><a href="#A-amp-Q2：cssom-渲染会不会阻塞-dom-渲染，会不会阻塞-dom-树建立？" class="headerlink" title="A &amp; Q2：cssom 渲染会不会阻塞 dom 渲染，会不会阻塞 dom 树建立？"></a>A &amp; Q2：cssom 渲染会不会阻塞 dom 渲染，会不会阻塞 dom 树建立？</h3><p>会，不会。</p><p>当一个样式表被后台下载时，JavaScript 仍然可以执行，因为主线程没有被加载的样式表所阻挡。如果我们的 JavaScript 程序访问 DOM 元素的 CSS 属性（通过 CSSOM API），<br>我们会得到一个合适的值（根据 CSSOM 的当前状态）。但是一旦样式表被下载和解析，导致 CSSOM 更新，我们的 JavaScript 现在有一个过时的元素的 CSS 值，<br>因为新的 CSSOM 更新可能已经改变了该 DOM 元素的 CSS 属性。由于这个原因，在下载样式表的时候<strong>执行 JavaScript 是不安全的，而 JS 通常会有些操作影响 dom 渲染</strong>。</p><p>就像 async 或 defer 属性使 script 元素不阻塞解析一样，外部的样式表也可以通过 media 属性使其不阻塞渲染。使用 media 属性值，浏览器可以智能地决定何时去加载样式表<br><br></br></p><h3 id="A-amp-Q3：页面渲染优化的方法"><a href="#A-amp-Q3：页面渲染优化的方法" class="headerlink" title="A &amp; Q3：页面渲染优化的方法"></a>A &amp; Q3：页面渲染优化的方法</h3><ul><li>HTML文档结构层次尽量少，最好不深于六层；</li><li>脚本尽量后放，放在前即可；</li><li>少量首屏样式内联放在标签内；</li><li>样式结构层次尽量简单；</li><li>在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；</li><li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li><li>动画尽量使用在绝对定位或固定定位的元素上；</li><li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li><li>尽量缓存DOM查找，查找器尽量简洁；</li><li>涉及多域名的网站，可以开启域名预解析</li></ul><h3 id="A-amp-Q4：强缓存和协商缓存发生在那个阶段？"><a href="#A-amp-Q4：强缓存和协商缓存发生在那个阶段？" class="headerlink" title="A &amp; Q4：强缓存和协商缓存发生在那个阶段？"></a>A &amp; Q4：强缓存和协商缓存发生在那个阶段？</h3><blockquote><p>强缓存和协商缓存发生在发起 URL 请求阶段，在这个阶段构建请求行之后会查找缓存。</p></blockquote><h3 id="A-amp-Q5：DNS解析中端口需要DNS解析吗？"><a href="#A-amp-Q5：DNS解析中端口需要DNS解析吗？" class="headerlink" title="A &amp; Q5：DNS解析中端口需要DNS解析吗？"></a>A &amp; Q5：DNS解析中端口需要DNS解析吗？</h3><blockquote><p>不需要，因为 HTTP 默认的是80端口，HTTPS 默认的是443端口，如果要指定端口可以直接在 URL 里面添加。</p></blockquote><h3 id="A-amp-Q6：上述哪些阶段可以优化？"><a href="#A-amp-Q6：上述哪些阶段可以优化？" class="headerlink" title="A &amp; Q6：上述哪些阶段可以优化？"></a>A &amp; Q6：上述哪些阶段可以优化？</h3><h4 id="1-优化-DNS-查询：DNS-预解析"><a href="#1-优化-DNS-查询：DNS-预解析" class="headerlink" title="1.  优化 DNS 查询：DNS 预解析"></a>1.  优化 DNS 查询：DNS 预解析</h4><p>前端的 <code>DNS</code> 优化，可以在 <code>html</code> 页面头部写入 <code>DNS</code> 缓存地址，比如</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;meta http-equiv<span class="hljs-operator">=</span><span class="hljs-string">&quot;x-dns-prefetch-control&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;on&quot;</span> /&gt;<br>&lt;link rel<span class="hljs-operator">=</span><span class="hljs-string">&quot;dns-prefetch&quot;</span> href<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://bdimg.share.baidu.com&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="2-优化TCP连接：可以通过请求头-keep-alive-来优化。"><a href="#2-优化TCP连接：可以通过请求头-keep-alive-来优化。" class="headerlink" title="2.  优化TCP连接：可以通过请求头 keep-alive 来优化。"></a>2.  优化TCP连接：可以通过请求头 keep-alive 来优化。</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">keep-alive</span><span class="hljs-punctuation">: </span>connection<br></code></pre></td></tr></table></figure><p>在本次 TCP 请求结束后，不主动断开，下次还需要 TCP 连接时就省了，直接在这个 TCP 管道进行传输即可</p><blockquote><p><strong>即节省了进行三次握手的建立 TCP 连接过程</strong></p></blockquote><h4 id="3-优化-HTTP-响应报文：通过-CDN-和-Gzip-压缩。"><a href="#3-优化-HTTP-响应报文：通过-CDN-和-Gzip-压缩。" class="headerlink" title="3.  优化 HTTP 响应报文：通过 CDN 和 Gzip 压缩。"></a>3.  优化 HTTP 响应报文：通过 CDN 和 Gzip 压缩。</h4><p><br></br></p><h3 id="A-amp-Q7：常见-http-请求报文头有哪些？"><a href="#A-amp-Q7：常见-http-请求报文头有哪些？" class="headerlink" title="A &amp; Q7：常见 http 请求报文头有哪些？"></a>A &amp; Q7：常见 http 请求报文头有哪些？</h3><ul><li><code>User-Agent</code> 浏览器类型</li><li><code>Content-Type</code>  报文类型</li><li><code>Connection</code>  完成传输是否关闭 TCP 连接</li><li><code>Host</code>  访问主机域名</li><li><code>Content-Length</code>  内容长度</li><li><code>Accept</code>  允许接收的数据类型</li><li><code>Accept-Language</code>  允许接收的语言</li><li><code>Cookie</code>  用户标识符</li><li><code>cache-control</code>  强缓存限制条件，存活时间</li><li><code>expires</code>  强缓存限制条件，被上面的替代了</li><li><code>etag</code>  协商缓存限制条件，过期的时刻</li><li><code>last-modified</code>  协商缓存限制条件，最后修改时间</li><li><code>date</code>  时间</li></ul><p>等等，还有很多，就不一一列举了<br><br></br></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我是 Smoothzjc，致力于产出更多且不仅限于前端方面的优质文章</p><p>大家也可以关注我的公众号 @ <strong>Smooth前端成长记录</strong>，及时通过移动端获取到最新文章消息！</p><p>写作不易，<strong>「点赞」+「收藏」+「转发」</strong> 谢谢支持❤</p><h2 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h2><p><a href="https://juejin.cn/post/7065882915791437855">《都2022年了还不考虑来学React Hook吗？6k字带你从入门到吃透》</a></p><p><a href="https://juejin.cn/post/7068256695620730910">《一份不可多得的 Webpack 学习指南（1万字长文带你入门 Webpack 并掌握常用的进阶配置）》</a></p><p><a href="https://juejin.cn/post/7071052780063948837">《【offer 收割机之 CSS 回顾系列】请你解释一下什么是 BFC ？他的应用场景有哪些？》</a></p><p><a href="https://juejin.cn/post/7064515729298554887">《Github + hexo 实现自己的个人博客、配置主题（超详细）》</a></p><p><a href="https://juejin.cn/post/7064024606276845581">《10分钟让你彻底理解如何配置子域名来部署多个项目》</a></p><p><a href="https://juejin.cn/post/7064005333437382670">《一文理解配置伪静态解决 部署项目刷新页面404问题</a></p><p><a href="https://juejin.cn/post/7060803746560737293">《带你3分钟掌握常见的水平垂直居中面试题》</a></p><p><a href="https://juejin.cn/post/6993934486954049550">《【建议收藏】长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群》</a></p><p><a href="https://juejin.cn/post/6993350461172482078">《浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)》</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试系列</tag>
      
      <tag>计算机网络</tag>
      
      <tag>浏览器原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【offer 收割机之 CSS 回顾系列】请你解释一下什么是 BFC ？他的应用场景有哪些？</title>
    <link href="/2022/03/16/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%20CSS%20%E5%9B%9E%E9%A1%BE%E7%B3%BB%E5%88%97%E3%80%91%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%20BFC%20%EF%BC%9F%E4%BB%96%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <url>/2022/03/16/%E3%80%90offer%20%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%20CSS%20%E5%9B%9E%E9%A1%BE%E7%B3%BB%E5%88%97%E3%80%91%E8%AF%B7%E4%BD%A0%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%20BFC%20%EF%BC%9F%E4%BB%96%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 本篇文章将会用大白话的方式带你彻底掌握 BFC，从此面试不再惧怕 BFC 的提问！<br /> 🙌 如文章有误，恳请评论区指正，谢谢！</strong></p></blockquote><p><a href="https://juejin.cn/editor/drafts/7070860888940478472">原文章链接</a></p><h2 id="一、常见定位方案"><a href="#一、常见定位方案" class="headerlink" title="一、常见定位方案"></a>一、常见定位方案</h2><p>在讲 BFC 之前，我们先来了解一下常见的定位方案，定位方案是控制元素的布局，有三种常见方案:</p><ol><li>普通流 (normal flow)</li></ol><blockquote><p><strong>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</strong></p></blockquote><p>而对于 <code>float</code> 的 <strong>不完全脱离文档流</strong> 和 <code>position: absolute</code> 的完全脱离文档流，指的就是上面这个 HTML 的普通流</p><ol start="2"><li><p><code>float</code> 对于浮动，是指元素先按照普通流的位置出现，然后将元素移动到所在行的最左边或最右边</p></li><li><p><code>absolute</code> 在绝对定位布局中，元素会完全脱离普通流，而元素具体的位置是在相对于不为 static 的第一个父元素 及绝对定位的坐标决定。<br><br></br></p><h2 id="二、BFC-概念"><a href="#二、BFC-概念" class="headerlink" title="二、BFC 概念"></a>二、BFC 概念</h2></li></ol><p>Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><h3 id="所以，BFC-是什么呢？"><a href="#所以，BFC-是什么呢？" class="headerlink" title="所以，BFC 是什么呢？"></a>所以，BFC 是什么呢？</h3><blockquote><p>BFC 是<strong>块级格式化上下文</strong>，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p></blockquote><p><strong>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</strong><br><br></br></p><h2 id="三、BFC-规则"><a href="#三、BFC-规则" class="headerlink" title="三、BFC 规则"></a>三、BFC 规则</h2><ul><li><p>BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)</p></li><li><p>BFC 的区域不会与 float 的元素区域重叠</p></li><li><p><code>BFC</code> 就是一个块级元素，块级元素会在垂直方向一个接一个的排列</p></li><li><p><code>BFC</code> 就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签</p></li><li><p>垂直方向距离由 <code>margin</code> 决定，属于同一个 <code>BFC</code> 的两个相邻标签外边距会发生重叠，属于不同 <code>BFC</code> 的不会重叠</p></li><li><p>计算 <code>BFC</code> 的高度时，浮动元素也参与计算<br><br></br></p><h2 id="四、触发-BFC-的条件"><a href="#四、触发-BFC-的条件" class="headerlink" title="四、触发 BFC 的条件"></a>四、触发 BFC 的条件</h2></li></ul><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><ul><li>body 根元素就是一个 BFC</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cell、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><p><strong>相信大家在看 BFC 文章时经常会看到上面的字眼吧，没有案例不太好理解，下面便给出几个案例带你真正掌握 BFC</strong><br><br></br></p><h2 id="五、BFC-特性及应用"><a href="#五、BFC-特性及应用" class="headerlink" title="五、BFC 特性及应用"></a>五、BFC 特性及应用</h2><p><strong>1. 阻止<code>margin</code>重叠</strong></p><p>对于同一个 BFC 内的两个相邻元素，如果分别设置了上下边距，那么会发生折叠（取大的那个）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;head&gt;<br><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">background</span>: pink;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span>;<br>&#125;<br>&lt;/head&gt;<br>&lt;<span class="hljs-selector-tag">body</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>    &lt;<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">body</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b39c456c2c5f49f2a3ad2e4029f4c170~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器 (这里指 body 元素) ，所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 50px（刚好一个正方形的高度），而不是 100px（两个正方形的高度）。</p><p>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">container</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">child</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">container</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">child</span>&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">background</span>: pink;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候，两个盒子边距就变成了 100px</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc7a233cf34c4a21893c50c088051438~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><br></br></p><p><strong>2. 清除浮动</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下面一个例子</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  </span><br><span class="language-css">  <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b208792aaa2418eaefe4fc562e8eef8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>样例渲染异常的解释：由于容器内元素浮动，脱离了文档流，所以就只有外面容器的 2px 边距高度。</p><p><strong>即方块没有如期将容器撑开</strong><br><br></br></p><h3 id="在这里问大家一个问题：我们在什么场景下会用到浮动呢？"><a href="#在这里问大家一个问题：我们在什么场景下会用到浮动呢？" class="headerlink" title="在这里问大家一个问题：我们在什么场景下会用到浮动呢？"></a>在这里问大家一个问题：我们在什么场景下会用到浮动呢？</h3><p><strong>毫无疑问，就是想用来布局定位的时候啊！</strong></p><p>有了上面的这个回答，我们才知道为什么要清除浮动，因为我们只想使用浮动对页面进行我们所需的布局，但又不想他影响到上下文元素，即<strong>不影响页面的普通流</strong>，那么下面便讲讲这种方法如何实现吧。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>对于上面的例子，如果想内容在设置了浮动的条件下，还能撑开容器高度，那么可以通过触发容器的 BFC，那么容器将会包裹着浮动元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;</span><br><span class="language-css">    <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  </span><br><span class="language-css">  <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d94a04adec074e12b1a49b6c2a4fd2c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br></br><br><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.none</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: grey;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左浮动元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><br>  没设置浮动的元素，我的文字由于环绕没被覆盖，但实际方块被覆盖了<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61eb626c06884dc2a9eb5ea99a8c312a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可以触发第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e4a84528ed47c89614bc02194815be~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.none</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: grey;</span><br><span class="language-css">    <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左浮动元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><br>  没设置浮动的元素，我的文字由于环绕没被覆盖，但实际方块被覆盖了<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>这个方法还可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度即可)。</strong></p></blockquote><p><br></br></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我是 Smoothzjc，致力于产出更多且不仅限于前端方面的优质文章</p><p>写作不易，<strong>「点赞」+「收藏」+「转发」</strong> 谢谢支持❤</p><h2 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h2><p><a href="https://juejin.cn/post/7065882915791437855">《都2022年了还不考虑来学React Hook吗？6k字带你从入门到吃透》</a></p><p><a href="https://juejin.cn/post/7068256695620730910">《一份不可多得的 Webpack 学习指南（1万字长文带你入门 Webpack 并掌握常用的进阶配置）》</a></p><p><a href="https://juejin.cn/post/7064515729298554887">《Github + hexo 实现自己的个人博客、配置主题（超详细）》</a></p><p><a href="https://juejin.cn/post/7064024606276845581">《10分钟让你彻底理解如何配置子域名来部署多个项目》</a></p><p><a href="https://juejin.cn/post/7064005333437382670">《一文理解配置伪静态解决 部署项目刷新页面404问题</a></p><p><a href="https://juejin.cn/post/7060803746560737293">《带你3分钟掌握常见的水平垂直居中面试题》</a></p><p><a href="https://juejin.cn/post/7056073706564648968">《React实战：使用Antd+EMOJIALL 实现emoji表情符号的输入》</a></p><p><a href="https://juejin.cn/post/6993934486954049550">《【建议收藏】长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群》</a></p><p><a href="https://juejin.cn/post/6993350461172482078">《浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)》</a><a href="https://juejin.cn/post/6993350461172482078">https://juejin.cn/post/6993350461172482078</a>)</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>面试系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【带你重刷剑指 Offer 系列】第 19 天 搜索与回溯算法（中等）三题题解一览</title>
    <link href="/2022/03/15/%E3%80%90%E5%B8%A6%E4%BD%A0%E9%87%8D%E5%88%B7%E5%89%91%E6%8C%87%20Offer%20%E7%B3%BB%E5%88%97%E3%80%91%E7%AC%AC%2019%20%E5%A4%A9%20%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89%E4%B8%89%E9%A2%98%E9%A2%98%E8%A7%A3%E4%B8%80%E8%A7%88/"/>
    <url>/2022/03/15/%E3%80%90%E5%B8%A6%E4%BD%A0%E9%87%8D%E5%88%B7%E5%89%91%E6%8C%87%20Offer%20%E7%B3%BB%E5%88%97%E3%80%91%E7%AC%AC%2019%20%E5%A4%A9%20%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89%E4%B8%89%E9%A2%98%E9%A2%98%E8%A7%A3%E4%B8%80%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 本篇文章会对剑指 offer 系列的第19天搜索与回溯算法（中等）三道题做详解<br /> 🙌 如文章有误，恳请评论区指正，谢谢！</strong></p></blockquote><p><a href="https://juejin.cn/post/7070160628714831886">原文章链接</a></p><h1 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h1><h2 id="一、题目描述："><a href="#一、题目描述：" class="headerlink" title="一、题目描述："></a>一、题目描述：</h2><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>原题链接：</strong><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a><br><br></br></p><h2 id="二、题目要求："><a href="#二、题目要求：" class="headerlink" title="二、题目要求："></a>二、题目要求：</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 1：<br><span class="hljs-section">输入: n = 3</span><br><span class="hljs-section">输出: 6</span><br><br>示例 2：<br><span class="hljs-section">输入: n = 9</span><br><span class="hljs-section">输出: 45</span><br></code></pre></td></tr></table></figure><h3 id="考察内容"><a href="#考察内容" class="headerlink" title="考察内容"></a>考察内容</h3><blockquote><p><strong>通过逻辑运算符的短路效应来终止递归</strong><br><br></br></p></blockquote><h2 id="三、思路分析"><a href="#三、思路分析" class="headerlink" title="三、思路分析"></a>三、思路分析</h2><h3 id="这道题考察的思想"><a href="#这道题考察的思想" class="headerlink" title="这道题考察的思想"></a>这道题考察的思想</h3><p>在不使用我们平时做题常用的各种语句的前提下（包括乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）），完成这道不常见的题目。</p><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><ol><li><p>这道题常用的方法就是递归，同样递归确实在思想上是最简单的，但常见递归思路在这题会被卡住，因为我们平时都会通过 if 语句来判断递归终止条件，但此题不能用。</p></li><li><p>既然不能使用上面的那些语句，那平时我写代码时还用到什么语句来进行条件判断呢？</p></li><li><p>答案一下就想到了，没错，就是用逻辑运算符，通过其短路效应来做条件判断进行递归终止。</p></li></ol><h3 id="逻辑运算符的短路效应"><a href="#逻辑运算符的短路效应" class="headerlink" title="逻辑运算符的短路效应"></a>逻辑运算符的短路效应</h3><p>常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 || ”，所谓的短路效应，如下：</p><ul><li><p>if(A &amp;&amp; B) 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false；</p></li><li><p>if(A || B) 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</p></li></ul><p><strong>因此，本题需要实现 “当 n &#x3D; 1时终止递归” 的需求，可通过短路效应实现。</strong><br><br></br></p><h2 id="四、代码讲解"><a href="#四、代码讲解" class="headerlink" title="四、代码讲解"></a>四、代码讲解</h2><p>当 num &#x3D; 1 时 num &gt; 1 不成立 ，此时 “短路” ，终止后续递归，即：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">num</span> &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="更详细解释"><a href="#更详细解释" class="headerlink" title="更详细解释"></a>更详细解释</h3><p>通过 num 值判断要不要继续递归，类似于之前的 if，只不过不同之处是 if 判断为 false 直接返回，函数内后面的语句都不执行，此处 &amp;&amp; 只是决定还要不要继续递归，后面的还是会执行<br><br></br></p><h2 id="五、AC-代码"><a href="#五、AC-代码" class="headerlink" title="五、AC 代码"></a>五、AC 代码</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param &#123;number&#125; n</span><br><span class="hljs-comment"> * @return &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">var</span> sumNums = function(n) &#123;<br>    <span class="hljs-built_in">let</span> res = <span class="hljs-number">0</span>;<br>    const <span class="hljs-built_in">sum</span> = (<span class="hljs-built_in">num</span>) =&gt; &#123;<br>        // 通过 <span class="hljs-built_in">num</span> 值判断要不要继续递归，类似于之前的 <span class="hljs-keyword">if</span>，只不过不同之处是 <span class="hljs-keyword">if</span> 判断为 <span class="hljs-literal">false</span> 直接返回，后面的都不执行，此处 &amp;&amp; 只是决定还要不要继续递归，后面的还是会执行<br>        <span class="hljs-built_in">num</span> &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>);<br>        res += <span class="hljs-built_in">num</span>;<br>        <span class="hljs-built_in">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">sum</span>(n);<br>    <span class="hljs-built_in">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eae18e43c9604d94b2749decede8dcd6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>这题的思维比较跳跃，要求我们跳出常用的语句，用比较难想到的逻辑运算符配合递归求解，总体来说，就是多做题多领略到不同题目的风采吧~</p><p><br></br><br><br></br></p><h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h1><h2 id="一、题目描述：-1"><a href="#一、题目描述：-1" class="headerlink" title="一、题目描述："></a>一、题目描述：</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>原题链接：</strong><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a><br><br></br></p><h2 id="二、题目要求：-1"><a href="#二、题目要求：-1" class="headerlink" title="二、题目要求："></a>二、题目要求：</h2><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce83900622dc431bbc0cd441a2c5a875~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nix">例如，给定如上二叉搜索树:  <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br><br>示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span> <br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br><br>示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><h3 id="考察内容-1"><a href="#考察内容-1" class="headerlink" title="考察内容"></a>考察内容</h3><blockquote><p><strong>二叉搜索树性质 + 迭代</strong><br><br></br></p></blockquote><h2 id="三、思路分析-1"><a href="#三、思路分析-1" class="headerlink" title="三、思路分析"></a>三、思路分析</h2><h3 id="这道题考察的思想-1"><a href="#这道题考察的思想-1" class="headerlink" title="这道题考察的思想"></a>这道题考察的思想</h3><p>了解二叉搜索树这个数据结构，并能通过该结构特质简化此题的求解思路</p><blockquote><p><strong>二叉搜索树性质：对于根节点来说，节点的左子树的所有值都比当前节点要小，节点的右子树的所有值都比当前节点要大</strong></p></blockquote><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>本题给定了两个重要条件：</p><ol><li>树为二叉搜索树</li><li>树的所有节点的值都是<strong>唯一</strong>的。</li></ol><p><strong>根据 二叉搜索树的性质，可以通过迭代对二叉搜索树进行 DFS</strong></p><ul><li>如果 p 和 q 对应的值都比当前节点要大，那么说明应该往右子树继续迭代</li><li>如果 p 和 q 对应的值都比当前节点要小，那么说明应该往左子树继续迭代</li><li>如果 p 和 q 对应的值一<strong>个比当前节点要大，一个要小</strong>，说明开始出现<strong>分岔</strong>了，指针不能单纯地往左子树或右子树继续遍历了，此时就是 p 和 q 的最近公共祖先<br>即：</li><li>若 root.val &lt; p.val，则 p 在 root 右子树 中；</li><li>若 root.val &gt; p.val，则 p 在 root 左子树 中；</li><li>若 root.val &#x3D; p.val，则 p 和 root 指向同一节点；<br><br></br><h2 id="四、代码讲解-1"><a href="#四、代码讲解-1" class="headerlink" title="四、代码讲解"></a>四、代码讲解</h2></li></ul><ol><li>循环搜索： 当节点 now 为空时跳出；</li><li>当 p, q 都在 now 的 右子树 中，则遍历至 now.right；</li><li>当 p, q 都在 now 的 左子树 中，则遍历至 now.left；</li><li>否则，说明找到了 最近公共祖先，跳出（<strong>第一种情况 p 或 q 跟根节点值相同，第二种情况一个比根节点值小，一个大</strong>）。</li><li>返回值： 最近公共祖先 now 。<br><br></br><h2 id="五、AC-代码-1"><a href="#五、AC-代码-1" class="headerlink" title="五、AC 代码"></a>五、AC 代码</h2></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.left = this.right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;TreeNode&#125; root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;TreeNode&#125; p</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;TreeNode&#125; q</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;TreeNode&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lowestCommonAncestor = function(root, p, q) &#123;<br>    let now = root;<br>    <span class="hljs-keyword">while</span>(now) &#123;<br>        <span class="hljs-comment">// 说明 now 指针应该往右子树指，因为要找的两个节点值都比当前根节点值要大</span><br>        <span class="hljs-keyword">if</span>(now.<span class="hljs-keyword">val</span> &lt; p.<span class="hljs-keyword">val</span> &amp;&amp; now.<span class="hljs-keyword">val</span> &lt; q.<span class="hljs-keyword">val</span>) &#123;<br>            now = now.right;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now.<span class="hljs-keyword">val</span> &gt; p.<span class="hljs-keyword">val</span> &amp;&amp; now.<span class="hljs-keyword">val</span> &gt; q.<span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-comment">// 说明 now 指针应该往左子树指，因为要找的两个节点值都比当前根节点值要小</span><br>            now = now.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// p 和 q 的值一大一小，说明当前节点就是最近公共祖先了，因为出现分岔了</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;;<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="时间和空间复杂度-1"><a href="#时间和空间复杂度-1" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe161d1b293644688242651b42811b23~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="六、总结-1"><a href="#六、总结-1" class="headerlink" title="六、总结"></a>六、总结</h2><p>此题要求我们要了解二叉搜索树这个数据结构，并能通过该结构特质简化递归的求解思路</p><p><br></br><br><br></br></p><h1 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h1><h2 id="一、题目描述：-2"><a href="#一、题目描述：-2" class="headerlink" title="一、题目描述："></a>一、题目描述：</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>原题链接：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a><br><br></br></p><h2 id="二、题目要求：-2"><a href="#二、题目要求：-2" class="headerlink" title="二、题目要求："></a>二、题目要求：</h2><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/819a4b24e47a4b9cb477fc28eee34ea1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nix">例如，给定如上二叉搜索树:  <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>]<br><br>示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span>。<br><br>示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><h3 id="考察内容-2"><a href="#考察内容-2" class="headerlink" title="考察内容"></a>考察内容</h3><blockquote><p><strong>先序遍历 + 回溯</strong><br><br></br></p></blockquote><h2 id="三、思路分析-2"><a href="#三、思路分析-2" class="headerlink" title="三、思路分析"></a>三、思路分析</h2><h3 id="这道题考察的思想-2"><a href="#这道题考察的思想-2" class="headerlink" title="这道题考察的思想"></a>这道题考察的思想</h3><p>了解最近公共祖先的意思，并知道有哪几种情况符合</p><h3 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h3><h4 id="首先明确何为最近公共祖先？"><a href="#首先明确何为最近公共祖先？" class="headerlink" title="首先明确何为最近公共祖先？"></a><strong>首先明确何为最近公共祖先？</strong></h4><p>若 root 是 p 和 q 的 最近公共祖先 ，则只可能为以下情况之一：</p><ul><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p &#x3D; root ，且 q 在 root 的左或右子树中；</li><li>q &#x3D; root ，且 p 在 root 的左或右子树中；</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h4><ol><li>使用先序遍历方法对二叉树进行递归遍历，当遇到节点 p 或 q 时直接返回。</li><li>从底至顶回溯，当节点 p, q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root。<br><br></br><h2 id="四、代码讲解-2"><a href="#四、代码讲解-2" class="headerlink" title="四、代码讲解"></a>四、代码讲解</h2><h3 id="对于递归"><a href="#对于递归" class="headerlink" title="对于递归"></a>对于递归</h3></li></ol><p><strong>终止条件</strong></p><ul><li>当越过叶节点，则直接返回 null ；</li><li>当 root 等于 p, q ，则直接返回 root；</li></ul><p><strong>返回值</strong></p><ul><li>首先，对左子树继续进行递归，返回值记为 left；对右子树继续进行递归，返回值记为 right；</li><li>然后，根据 left 和 right，可展开为四种情况：</li><li>当 left 和 right 同时为空 ：说明 root 的左右子树中都不包含 p,q，返回 null 即可；</li><li>当 left 为空 ，right 不为空（或反过来） ：p,q 都不在 root 的左子树中，直接返回 right，对于该情况，还可以细分为两种情况：<ul><li>（1） p 或 q 其中一个在 root 的 右子树 中，假设此时根节点是 p，则 right 指向的就是 q；</li><li>（2） p,q 两节点都在 root 的 右子树 中，此时的 right 指向的就是最近公共祖先节点；</li></ul></li><li>当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 两侧，因此 root 为最近公共祖先，返回 root ；<br><br></br><h2 id="五、AC-代码-2"><a href="#五、AC-代码-2" class="headerlink" title="五、AC 代码"></a>五、AC 代码</h2></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * function TreeNode(val) &#123;<br> *     this.val = val;<br> *     this.<span class="hljs-built_in">left</span> = this.<span class="hljs-built_in">right</span> = null;<br> * &#125;<br> */<br>/**<br> * @param &#123;TreeNode&#125; root<br> * @param &#123;TreeNode&#125; p<br> * @param &#123;TreeNode&#125; q<br> * @<span class="hljs-keyword">return</span> &#123;TreeNode&#125;<br> */<br>var lowestCommonAncestor = function(root, p, q) &#123;<br>    <span class="hljs-keyword">return</span> dfs(root, p, q);<br>&#125;;<br><br>const dfs = (root, p, q) =&gt; &#123;<br>    // 如果结点为空，或结点直接等于 p 或 q 了，直接返回该结点即可(相当于返回空，或 p 或 q)<br>    <span class="hljs-keyword">if</span>(!root |<span class="hljs-type">| root</span> === p |<span class="hljs-type">| root</span> === q) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">left</span> = dfs(root.<span class="hljs-built_in">left</span>, p, q);<br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">right</span> = dfs(root.<span class="hljs-built_in">right</span>, p, q);<br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">right</span> &amp;&amp; !<span class="hljs-built_in">left</span>) &#123;<br>        <span class="hljs-keyword">return</span> null;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">left</span> &amp;&amp; <span class="hljs-built_in">right</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">right</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">right</span> &amp;&amp; <span class="hljs-built_in">left</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="时间和空间复杂度-2"><a href="#时间和空间复杂度-2" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55104b641d6744b3a0e18ef0b1f8253e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="六、总结-2"><a href="#六、总结-2" class="headerlink" title="六、总结"></a>六、总结</h2><p>此题要求我们要了解有哪几种情况符合最近公共祖先，并能通过回溯按指定条件进行返回值</p><p><br></br></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这是我 <strong>「LeetCode」</strong> 系列文章的第 &#96;No.1 篇，系列开始于 <strong>2022&#x2F;03&#x2F;01</strong>。</p><p>在这个系列文章里面，除了会理清解题思路，尽量给出多种解题方式以外，还会探讨本题所涉及的知识点。</p><p>我会争取<strong>每日 2 题，每日一更</strong>，所有的题解均收录于该仓库：<a href="https://link.juejin.cn/?target=https://github.com/Wu-yikun/Leetcode" title="https://gitee.com/zjc13544361063/leet-code">【LeetCode】系列</a></p><p>目前仓库正在加紧更新题解中哈哈，觉得不错的小伙伴可以点个 <strong>star</strong> 支持一下</p><p>写作不易，<strong>「点赞」+「收藏」+「转发」</strong> 谢谢支持❤</p><h2 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h2><p><a href="https://juejin.cn/post/7065882915791437855">《都2022年了还不考虑来学React Hook吗？6k字带你从入门到吃透》</a></p><p><a href="https://juejin.cn/post/7068256695620730910">《一份不可多得的 Webpack 学习指南（1万字长文带你入门 Webpack 并掌握常用的进阶配置）》</a></p><p><a href="https://juejin.cn/post/7064515729298554887">《Github + hexo 实现自己的个人博客、配置主题（超详细）》</a></p><p><a href="https://juejin.cn/post/7064024606276845581">《10分钟让你彻底理解如何配置子域名来部署多个项目》</a></p><p><a href="https://juejin.cn/post/7064005333437382670">《一文理解配置伪静态解决 部署项目刷新页面404问题</a></p><p><a href="https://juejin.cn/post/7060803746560737293">《带你3分钟掌握常见的水平垂直居中面试题》</a></p><p><a href="https://juejin.cn/post/7056073706564648968">《React实战：使用Antd+EMOJIALL 实现emoji表情符号的输入》</a></p><p><a href="https://juejin.cn/post/6993934486954049550">《【建议收藏】长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群》</a></p><p><a href="https://juejin.cn/post/6993350461172482078">《浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)》</a></p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一份不可多得的 Webpack 学习指南（1万字长文带你入门 Webpack 并掌握常用的进阶配置）</title>
    <link href="/2022/03/14/%E4%B8%80%E4%BB%BD%E4%B8%8D%E5%8F%AF%E5%A4%9A%E5%BE%97%E7%9A%84%20Webpack%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%EF%BC%881%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8%20Webpack%20%E5%B9%B6%E6%8E%8C%E6%8F%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE%EF%BC%89/"/>
    <url>/2022/03/14/%E4%B8%80%E4%BB%BD%E4%B8%8D%E5%8F%AF%E5%A4%9A%E5%BE%97%E7%9A%84%20Webpack%20%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97%EF%BC%881%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8%20Webpack%20%E5%B9%B6%E6%8E%8C%E6%8F%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 本篇文章会带你入门 Webpack  并对基本配置以及进阶配置做比较通俗易懂的介绍！<br /> 🙌 如文章有误，恳请评论区指正，谢谢！</strong></p></blockquote><p><strong>自定义 Loader 内容于 2022&#x2F;02&#x2F;25 更新</strong><br /><strong>自定义 Plugin 内容于 2022&#x2F;02&#x2F;26 更新</strong></p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>本教程包管理方式统一使用 <code>npm</code> 进行讲解</p><h2 id="学习背景"><a href="#学习背景" class="headerlink" title="学习背景"></a>学习背景</h2><p>由于在平时使用 vue、react 框架进行项目开发时，vue-cli 和 create-react-app 脚手架已经为你默认配置了 webpack 的常用参数，所以没有额外需求不用另外配置 webpack。</p><p>但在一次项目开发中，突然自己想给项目增加一个优化打包速度和体积的需求，所以就开始学习起了 webpack，逐渐明白了这打包工具的强大之处，在查看了脚手架给我们默认配置好的 webpack 配置文件后，也明白了脚手架这种东西的便捷之处。</p><p>当然，系统学习后 webpack，你也可以做到去阉割脚手架的 webpack 配置文件用不到的一些配置选项，并增加一些你需要的配置，例如优化打包体积、提升打包速度等等。</p><p>此篇文章便为你进行系统地讲解 webpack 的基本使用</p><p><strong>PS：对于 webpack 的配置文件，vue-cli 可以通过修改 vue.config.js 进行配置修改，create-react-app 需要通过 craco 覆盖，或 eject 进行暴露。</strong></p><h2 id="webpack介绍"><a href="#webpack介绍" class="headerlink" title="webpack介绍"></a>webpack介绍</h2><h3 id="webpack-是什么"><a href="#webpack-是什么" class="headerlink" title="webpack 是什么"></a><code>webpack</code> 是什么</h3><p>bundler：模块打包工具<br><br></br></p><h3 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a><code>webpack</code> 作用</h3><p>对项目进行打包，明确项目入口，文件层次结构，翻译代码(将代码翻译成浏览器认识的代码，例如import&#x2F;export)<br><br></br></p><h3 id="webpack-环境配置"><a href="#webpack-环境配置" class="headerlink" title="webpack 环境配置"></a><code>webpack</code> 环境配置</h3><p><code>webpack</code>安装前提：已安装 <code>node</code> (node安装在此不做赘述)，用指令 <code>node -v</code> 和 <code>npm -v</code> 来测试node安装有没成功<br><br></br></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install webpack webpack-cli --save-dev <span class="hljs-regexp">//</span> 推荐，--save-dev结尾(或直接一个 -D)，该项目内安装<br><span class="hljs-built_in">npm</span> install webpack webpack-cli -g <span class="hljs-regexp">//</span> 不推荐，-g结尾，全局安装(如果两个项目用的两个webpack版本，会造成版本冲突)<br><br>安装后查询版本：<br>webpack -v：查找全局的 webpack 版本，非 -g 全局安装是找不到的<br>npx webpack -v：查找该项目下的 webpack 版本<br><br>其他指令：<br><span class="hljs-built_in">npm</span> init -y：初始化 <span class="hljs-built_in">npm</span> 仓库，-y 后缀意思是创建package.json文件时默认所有选项都为<span class="hljs-literal">yes</span><br><span class="hljs-built_in">npm</span> info webpack：查询 webpack 有哪些版本号<br><span class="hljs-built_in">npm</span> install webpack@版本号 webpack-cli -D：安装指定版本号的webpack<br>npx webpack；进行打包<br></code></pre></td></tr></table></figure><p><code>webpack-cli</code> 和 <code>webpack</code> 区别：</p><p><code>webpack-cli</code> 能让我们在命令行运行<code>webpack</code> 相关指令，例如 <code>webpack</code>, <code>npx webpack</code> 等等<br><br></br></p><h3 id="webpack-配置文件"><a href="#webpack-配置文件" class="headerlink" title="webpack 配置文件"></a><code>webpack</code> 配置文件</h3><p>默认配置文件：<code>webpack.config.js</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>    mode: <span class="hljs-string">&quot;production&quot;</span>, <span class="hljs-regexp">//</span> 环境，默认 production 即生产环境，打包出来的文件经过压缩(可以不写)，development没压缩<br>    entry: <span class="hljs-string">&#x27;index.js&#x27;</span>, <span class="hljs-regexp">//</span> 入口文件(要写路径)<br>    output: &#123;  <span class="hljs-regexp">//</span> 出口位置<br>        filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>, <span class="hljs-regexp">//</span> 出口文件名<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;bundle&#x27;</span>), <span class="hljs-regexp">//</span> 出口文件打包到哪个文件夹下，参数(绝对路径根目录下，文件名)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想让 <code>webpack</code> 按其他配置文件规则进行打包，比如叫做 <code>webpackconfig.js</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npx webpack <span class="hljs-comment">--config webpackconfig.js</span><br></code></pre></td></tr></table></figure><h4 id="小问题："><a href="#小问题：" class="headerlink" title="小问题："></a>小问题：</h4><p>为什么使用<code>react</code>、<code>vue</code>框架打包项目文件时不是输入 <code>npx webpack</code> 而是输入 <code>npm start/npm run dev</code>等等？</p><p>原因：更改 <code>package.json</code> 文件里的 scripts 脚本指令(该文件：项目的说明，包括所需依赖、可运行脚本、项目名、版本号等等)</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">&#123;<br>    <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;bundle&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span> // 运行 npm run 脚本名，相当于运行 原始指令，即 `npm run bundle -&gt; webpack`<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回顾：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">webpack index.js <span class="hljs-regexp">//</span> 全局安装 webpack 后，单独对这个js文件进行打包<br>npx webpack index.js <span class="hljs-regexp">//</span> 局部(项目内)安装 webpack 后，单独对这个js文件进行打包<br>npm run bundle -&gt; webpack <span class="hljs-regexp">//</span> 运行脚本，进行 webpack 打包，先在项目内查找webpack进行打包，没有再全局----前两者融合<br></code></pre></td></tr></table></figure><p>后面开始用 <code>npm run bundle</code> 代替 <code>webpack</code> 进行打包<br><br></br></p><h1 id="Webpack-基本概念"><a href="#Webpack-基本概念" class="headerlink" title="Webpack 基本概念"></a>Webpack 基本概念</h1><p><code>webpack</code> 的 <code>Concepts</code> 板块</p><p><a href="https://webpack.docschina.org/concepts/">官方文档</a></p><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><h3 id="Loader-是什么？"><a href="#Loader-是什么？" class="headerlink" title="Loader 是什么？"></a>Loader 是什么？</h3><p>由于 webpack 默认只认识、支持打包js文件，想要拓展其能力进行打包 css文件、图片文件等等，需要安装 Loader 进行拓展</p><h3 id="Loader-的使用"><a href="#Loader-的使用" class="headerlink" title="Loader 的使用"></a>Loader 的使用</h3><p>在 <code>webpack.config.js</code> 的配置文件中进行配置</p><p>在文件中新增 <code>module</code> 字段，<code>module</code> 中新增 <code>rules</code> 的数组，进行一系列规则的配置，<strong>每个规则对象有两个字段</strong></p><p><code>test</code> ：匹配所有以 xxx 为后缀的文件的打包，用正则表达式进行匹配</p><p><code>use</code> ：指明要使用的 loader 名称 ，且要对该 loader 进行安装</p><p>拓展，<code>use</code> 还有 <code>options</code> 可选择字段，<code>name</code> 指明打包后的文件命名，<code>[name].[ext]</code> 代表打包后和打包前 <code>命名</code> 和 <code>后缀</code> 一样</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">&#123;<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: /.jpg$/,<br>                use: &#123;<br>                    loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>                    options: &#123;<br>                        <span class="hljs-comment">// placeholder 占位符</span><br>                        name: <span class="hljs-string">&#x27;[name].[ext]&#x27;</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在项目根目录下使用 <code>npm install loader名字</code> 或 <code>yarn add loader名字</code> 进行所需 loader 的安装<br><br></br></p><h3 id="常用-Loader-推荐"><a href="#常用-Loader-推荐" class="headerlink" title="常用 Loader 推荐"></a>常用 Loader 推荐</h3><p><code>babel-loader</code>、<code>style-loader</code>、<code>css-loader</code>、<code>less-loader</code>、<code>sass-loader</code>、<code>postcss-loader</code>、<code>url-loader</code>、<code>file-loader</code> 等等<br><br></br></p><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片(Images)"></a>图片(Images)</h3><p><strong>打包图片文件</strong></p><p>图片静态资源，所以都对应 <code>file-loader</code> ，且一般项目中这些静态资源被放到 <code>images</code> 文件夹，通过 <code>use</code> 字段配置额外参数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: /.(jpg|png|gif)$/,<br>                use: &#123;<br>                    loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>                    options: &#123;<br>                        name: <span class="hljs-string">&#x27;[name].[ext]&#x27;</span>,<br>                        outputPath: <span class="hljs-string">&#x27;images/&#x27;</span> // 匹配到上面后缀的文件时，都打包到的的文件夹路径<br>                    &#125;<br>                &#125;<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，对于 <code>file-loader</code>，<code>url-loader</code> 会更具拓展性</p><p>推荐用 <code>url-loader</code> 进行替换，因为可以设置<code>limit</code>参数，当图片大于对应字节大小，会打包到指定文件夹目录，若小于，则会生成<code>base64</code>(不会打包图片到文件夹下，而是生成 <code>base64</code> 到 <code>output</code>的<code>js</code>文件里 )</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">module:</span> &#123;<br>        <span class="hljs-attr">rules:</span> [<br>            &#123;<br>                <span class="hljs-attr">test:</span> <span class="hljs-string">/.(jpg|png|gif)$/</span>,<br>                <span class="hljs-attr">use:</span> &#123;<br>                    <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>                    <span class="hljs-attr">options:</span> &#123;<br>                        <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;[name].[ext]&#x27;</span>,<br>                        <span class="hljs-attr">outputPath:</span> <span class="hljs-string">&#x27;images/&#x27;</span>, <span class="hljs-string">//</span> <span class="hljs-string">匹配到上面后缀的文件时，都打包到该文件夹路径</span><br>                        <span class="hljs-attr">limit:</span> <span class="hljs-number">2048</span> <span class="hljs-string">//</span> <span class="hljs-string">指定大小</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="样式-CSS"><a href="#样式-CSS" class="headerlink" title="样式(CSS)"></a>样式(CSS)</h3><h4 id="打包样式文件"><a href="#打包样式文件" class="headerlink" title="打包样式文件"></a>打包样式文件</h4><p>需要 <code>css-loader</code> 和 <code>style-loader</code> ，在 <code>use</code> 字段进行配置</p><p>说明：设置 css 样式后，挂载到 style 的属性上，所以要两个</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>    module: &#123;<br>        rules: [<br>            &#123;<br>                test: /.css$/,<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 <code>scss</code> 文件，除了上面两个 loader 以外，还要在 use 中额外配置 <code>sass-loader</code>，然后安装两个文件</p><p><code>npm install sass-loader node-sass webpack --save-dev</code></p><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><p><code>use</code> 中的 <code>loader</code> 数组，是有打包顺序的，按从右到左，从上到下，即 scss，要先 style，然后 css，最后sass，从右到左</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sml">use: [<span class="hljs-symbol">&#x27;style</span>-loader&#x27;, <span class="hljs-symbol">&#x27;css</span>-loader&#x27;, <span class="hljs-symbol">&#x27;sass</span>-loader&#x27;]<br></code></pre></td></tr></table></figure><h4 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss.loader"></a>postcss.loader</h4><p>对于样式，如果老版本的浏览器可能需要兼容，即在 css 属性中加 <code>-webkit</code> 等前缀，可以通过 <code>postcss.loader</code> 实现，在上面例子在后面加上这个 loader 并进行下载后，新建一个 <code>postcss.config.js</code> 文件进行该 loader 的配置即可</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;<br>    plugins: [<br>        <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="样式拓展"><a href="#样式拓展" class="headerlink" title="样式拓展"></a>样式拓展</h4><p>如何让 webpack 识别 less 文件内再引入的 less 文件，并进行打包？</p><p>如何模块化导出和使用样式？(css in js)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">module:</span> &#123;<br>        <span class="hljs-attr">rules:</span> [<br>            &#123;<br>                <span class="hljs-attr">test:</span> <span class="hljs-string">/.scss$/</span>,<br>                <span class="hljs-attr">use:</span> [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <br>                        &#123;<br>                            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                            <span class="hljs-attr">options:</span> &#123;<br>                                <span class="hljs-attr">importLoaders:</span> <span class="hljs-number">2</span>, <span class="hljs-string">//</span> <span class="hljs-string">允许less文件内引入less文件</span><br>                                <span class="hljs-attr">modules:</span> <span class="hljs-literal">true</span> <span class="hljs-string">//</span> <span class="hljs-string">允许模块化导入导出使用css，css</span> <span class="hljs-string">in</span> <span class="hljs-string">js</span> <span class="hljs-string">同理</span><br>                            &#125;<br>                        &#125;,<br>                        <span class="hljs-string">&#x27;sass-loader,</span><br><span class="hljs-string">                        &#x27;</span><span class="hljs-string">postcss-loader&#x27;</span><br>                    ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="字体-Fonts"><a href="#字体-Fonts" class="headerlink" title="字体(Fonts)"></a>字体(Fonts)</h3><p><strong>打包字体文件(借助iconfont)</strong></p><p>从 iconfont 网站下载对应图标的字体文件并压缩到目录后，会发现由于下载的 <code>iconfont.css</code> 文件内部又引入了 <code>eot、ttf、svg</code>文件，webpack无法识别，引入需给这三个后缀的文件再配置打包规则，用 <code>file-loader</code> 即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>    <span class="hljs-attr">module:</span> &#123;<br>        <span class="hljs-attr">rules:</span> [<br>            &#123;<br>                <span class="hljs-attr">test:</span> <span class="hljs-string">/.scss$/</span>,<br>                <span class="hljs-attr">use:</span> [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <br>                        &#123;<br>                            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                            <span class="hljs-attr">options:</span> &#123;<br>                                <span class="hljs-attr">importLoaders:</span> <span class="hljs-number">2</span>, <span class="hljs-string">//</span> <span class="hljs-string">允许less文件内引入less文件</span><br>                                <span class="hljs-attr">modules:</span> <span class="hljs-literal">true</span> <span class="hljs-string">//</span> <span class="hljs-string">允许模块化导入导出使用css，css</span> <span class="hljs-string">in</span> <span class="hljs-string">js</span> <span class="hljs-string">同理</span><br>                            &#125;<br>                        &#125;,<br>                        <span class="hljs-string">&#x27;sass-loade,</span><br><span class="hljs-string">                        &#x27;</span><span class="hljs-string">postcss-loader&#x27;</span><br>                    ]<br>            &#125;,<br>            &#123;   <span class="hljs-string">//</span> <span class="hljs-string">配置这个规则即可</span><br>                <span class="hljs-attr">test:</span> <span class="hljs-string">/.(eot|ttf|svg)$/</span>,<br>                <span class="hljs-attr">use:</span> &#123;<br>                    <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;file-loader&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="自定义-Loader"><a href="#自定义-Loader" class="headerlink" title="自定义 Loader"></a>自定义 Loader</h3><p>首先明确最基本的，编写 <code>Loader</code> 其实就是编写一个函数并暴露出去给 <code>Webpack</code> 使用</p><p>例如编写一个 <code>replaceLoader</code> ，作用是当遇到某个字符时替换成其他字符，例如遇到 <code>hello</code> 字符串时，替换成 <code>hi</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">// 在根目录的 <span class="hljs-built_in">loaders</span> 文件夹下的 replaceLoader.js    即路径：<span class="hljs-string">&#x27;./loaders/replaceLoader.js&#x27;</span><br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> source.replace(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个简易的 Loader 就写好啦</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>暴露的函数不能写成箭头函数，即不能写成如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// replaceLoader.js</span><br><br>module.exports = <span class="hljs-function">(<span class="hljs-params">source</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于箭头函数没有 <code>this</code> 指针，而 <code>Webpack</code>在使用 <code>Loader</code> 时会做些变更，绑定一些方法到 <code>this</code> 上，所以会没法调用原本属于 <code>this</code> 的一些方法了。</p><p>例如：获取传入 <code>Loader</code> 的参数是通过 <code>this.query</code> 获取</p><p><strong>当然，要用你自定义的 Loader，除了上面的编写 Loader 外，还需要对他进行使用，在 <code>Webpack</code> 配置文件进行相关配置</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua">// webpack.<span class="hljs-built_in">config</span>.js<br><br>const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [&#123;<br>            test: /.js/,<br>            use: [<br>                <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./loaders/replaceLoader.js&#x27;</span>) // 这里要书写该 js 文件的路径<br>            ]<br>        &#125;]<br>    &#125;,<br>    <span class="hljs-built_in">output</span>: &#123;<br>        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果你想往你的自定义 Loader 传入一些参数，传参的方式如下：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs lua">// webpack.<span class="hljs-built_in">config</span>.js<br><br>const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [&#123;<br>            test: /.js/,<br>            use: [<br>                &#123;<br>                    loader: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./loaders/replaceLoader.js&#x27;</span>), // 这里要书写该 js 文件的路径<br>                    options: &#123;<br>                        name: <span class="hljs-string">&#x27;hi&#x27;</span><br>                    &#125;<br>                &#125;<br>            ]<br>        &#125;]<br>    &#125;,<br>    <span class="hljs-built_in">output</span>: &#123;<br>        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，<code>Webpack</code> 在进行打包时，会将 <code>&#123;name: &#39;hi&#39;&#125;</code> 参数传入 <code>replaceLoader.js</code></p><p>在 <code>replaceLoader.js</code> 中，参数的接收形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// replaceLoader.js</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">source</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">query</span>.<span class="hljs-property">name</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，原项目所有 js 文件中的 <code>hello</code> 字符串都被替换成了 <code>hi</code></p><p><strong>这样，一个简易的 <code>Loader</code> 就完成啦</strong><br><br></br></p><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><h5 id="loader-utils"><a href="#loader-utils" class="headerlink" title="loader-utils"></a>loader-utils</h5><p>但有时往自定义 Loader 传参时会比较诡异，例如上述例子，传入的明明是一个对象，但可能变成只有一个字符串 ，此时就需要用到 <code>loader-utils</code> 模块，对传入的参数进行分析，解析成正确的内容</p><p><strong>使用方法</strong></p><p>先运行 <code>npm install loader-utils --save-dev</code> 安装，然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// replaceLoader.js</span><br><br><span class="hljs-keyword">const</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>); <span class="hljs-comment">// 引入该模块</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">const</span> options = loaderUtils.<span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 使用</span><br>    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, options.<span class="hljs-property">name</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h5 id="callback"><a href="#callback" class="headerlink" title="callback()"></a>callback()</h5><p>有时，除了用自定义 Loader 对原项目做出更改以外，如果启用了 <code>sourceMap</code>，还希望 <code>sourceMap</code> 对应的映射也发生更改，</p><p>由于该函数只返回了项目内容的更改，而没返回 <code>sourceMap</code> 的更改，所以要用 <code>callback</code> 做一些配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<br>    <span class="hljs-attr">err</span>: <span class="hljs-title class_">Error</span> | <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Buffer</span>,<br>    sourceMap?: <span class="hljs-title class_">SourceMap</span>,<br>    meta?: <span class="hljs-built_in">any</span><br>)<br></code></pre></td></tr></table></figure><p>通过该函数进行回调，可以返回除了项目内容更改外，还可以返回 sourceMap 、错误、meta 的更改</p><p>由于，我只需要返回项目内容以及 <code>sourceMap</code> 的更改，所以配置示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// replaceLoader.js</span><br><br><span class="hljs-keyword">const</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>); <span class="hljs-comment">// 引入该模块</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">const</span> options = loaderUtils.<span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 使用</span><br>    <span class="hljs-keyword">const</span> result = source.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, options.<span class="hljs-property">name</span>);<br>    <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, result, source);<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h5 id="async"><a href="#async" class="headerlink" title="async()"></a>async()</h5><p>自定义 Loader 中有时会有异步操作，例如设置延时器1s后再进行打包(方便摸鱼)，那如果直接 setTimeout()，设置一个延时器再返回肯定是不行的，会报错无返回内容，因为正常来说是不允许在延时器中返回内容的。</p><p>我们可以通过 async() 来解决，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// replaceLoader.js</span><br><br><span class="hljs-keyword">const</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>); <span class="hljs-comment">// 引入该模块</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">const</span> options = loaderUtils.<span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 使用</span><br>    <span class="hljs-keyword">const</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>();<br>    <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> result = source.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, options.<span class="hljs-property">name</span>);<br>        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, result); <span class="hljs-comment">// 参数同上面的 callback()</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，其实 <code>async()</code> 跟 <code>callback()</code> 很类似，只不过用于异步返回而已<br><br></br></p><h5 id="同时自定义多个-Loader"><a href="#同时自定义多个-Loader" class="headerlink" title="同时自定义多个 Loader"></a>同时自定义多个 Loader</h5><p>例如想实现一个需求：打包后项目先是将项目中的所有字符串 <code>hello</code> 替换成 <code>hi</code>，再把 <code>hi</code> 替换成 <code>Wow</code></p><p>那么就要编写两个 Loader，第一个将 <code>hello</code> 替换成 <code>hi</code>，第二个将 <code>hi</code> 替换成 <code>Wow</code></p><p>第一个 <code>replaceLoader.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// replaceLoader.js</span><br><br><span class="hljs-keyword">const</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>); <span class="hljs-comment">// 引入该模块</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">const</span> options = loaderUtils.<span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 使用</span><br>    <span class="hljs-keyword">const</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>();<br>    <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> result = source.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, options.<span class="hljs-property">name</span>);<br>        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, result); <span class="hljs-comment">// 参数同上面的 callback()</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个 <code>replaceLoader2.js</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// replaceLoader2.js</span><br><br>module.exports = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">return</span> source.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-string">&#x27;wow&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同时对 <code>webpack.config.js</code> 进行配置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs lua">// webpack.<span class="hljs-built_in">config</span>.js<br><br>const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [&#123;<br>            test: /.js/,<br>            use: [<br>                &#123;<br>                    loader: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./loaders/replaceLoader2.js&#x27;</span>)<br>                &#125;,<br>                &#123;<br>                    loader: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./loaders/replaceLoader.js&#x27;</span>) // 这里要书写该 js 文件的路径,<br>                    options: &#123;<br>                        name: <span class="hljs-string">&#x27;hi&#x27;</span><br>                    &#125;<br>                &#125;,<br>            ]<br>        &#125;]<br>    &#125;,<br>    <span class="hljs-built_in">output</span>: &#123;<br>        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>要注意的地方</strong></p><p>由于前面提到 <code>Loader</code> 执行顺序是从下到上，从右到左，所以要将第一个写在下面，第二个写在上面<br><br></br></p><h5 id="Loader-引入转换成官方的引入方式"><a href="#Loader-引入转换成官方的引入方式" class="headerlink" title="Loader 引入转换成官方的引入方式"></a>Loader 引入转换成官方的引入方式</h5><p>在上面的例子中，引入 <code>loader</code> 时，方式都是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">loader: path.<span class="hljs-built_in">resolve</span>(__dirname, <span class="hljs-string">&#x27;./loaders/replaceLoader2.js&#x27;</span>)<br></code></pre></td></tr></table></figure><p>太长了，太麻烦了，不美观，想更换成官方的引入方式，该怎么做呢</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">loader:</span> <span class="hljs-comment">&#x27;replaceLoader2&#x27;</span><br></code></pre></td></tr></table></figure><p><code>Webpack</code> 配置文件中配置 <code>resolveLoader</code> 字段</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua">// webpack.<span class="hljs-built_in">config</span>.js<br><br>const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    &#125;,<br>    resolveLoader: &#123;<br>        modules: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;./loaders&#x27;</span>]<br>    &#125;,<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [&#123;<br>            test: /.js/,<br>            use: [<br>                &#123;<br>                    loader: <span class="hljs-string">&#x27;replaceLoader2&#x27;</span><br>                &#125;,<br>                &#123;<br>                    loader: <span class="hljs-string">&#x27;replaceLoader&#x27;</span>, // 这里要书写该 js 文件的路径,<br>                    options: &#123;<br>                        name: <span class="hljs-string">&#x27;hi&#x27;</span><br>                    &#125;<br>                &#125;,<br>            ]<br>        &#125;]<br>    &#125;,<br>    <span class="hljs-built_in">output</span>: &#123;<br>        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数意思：如果在 <code>node_modules</code> 文件夹下没找到配置的 Loader，那么就会进入同级目录下的 <code>loaders</code> 文件夹进行查找<br><br></br></p><h5 id="更多-Loader-的设计思考"><a href="#更多-Loader-的设计思考" class="headerlink" title="更多 Loader 的设计思考"></a>更多 Loader 的设计思考</h5><p>推荐一些自定义的实用的 loader</p><ol><li>全局异常监控，思路：给所有函数外面包裹 <code>try&#123;&#125; catch(err) &#123;console.log(err)&#125;</code> 语句</li><li>style-loader</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">const</span> style = <span class="hljs-string">`</span><br><span class="hljs-string">        let style = document.createElement(&quot;style&quot;);</span><br><span class="hljs-string">        style.innerHTML = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(source)&#125;</span>;</span><br><span class="hljs-string">        document.head.appendChild(style)</span><br><span class="hljs-string">    `</span><br>    <span class="hljs-keyword">return</span> style;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul><li><p>使用插件让打包更快捷、多样化</p></li><li><p>在打包的某个生命周期，插件会帮助你做一些事情</p></li></ul><p><strong>下面介绍几个常用插件</strong></p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>作用：由于 webpack 默认打包不会生成 index.html 文件， <code>htmlWebpackPlugin</code> 会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中</p><p>插件运行生命周期：打包之后</p><p>参数：对象</p><p><code>template</code> 指定一个模板，打包生成的 html 文件根据这个模板来生成，比如会多生成一个 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">HtmlWebpackPlugin</span>(&#123;</span><br><span class="hljs-function">    <span class="hljs-variable">template</span>: <span class="hljs-string">&#x27;index.html&#x27;</span></span><br><span class="hljs-function">&#125;)</span><br></code></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>作用：打包前删除某个目录下的所有内容，主要用于删除之前的打包内容，防止重复</p><p>插件运行生命周期：打包之前</p><p>参数：数组形式</p><p>[‘要删除的文件夹名’]</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span> <span class="hljs-type">HtmlWebpackPlugin</span>([<span class="hljs-string">&#x27;dist&#x27;</span>])<br></code></pre></td></tr></table></figure><p><br></br></p><h4 id="自定义一个-Plugin"><a href="#自定义一个-Plugin" class="headerlink" title="自定义一个 Plugin"></a>自定义一个 Plugin</h4><p>首先明确最基本的，编写 <code>plugin</code> 其实就是编写一个类并暴露出去给 <code>Webpack</code> 在打包的某个生命周期进行相关操作。</p><p>例如编写一个 <code>copyright-webpack-plugin</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// copyright-webpack-plugin.js  我定义该文件位于根目录的 plugins 文件夹下</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyrightWebpackPlugin</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插件被使用了&#x27;</span>)<br>    &#125;<br>    <br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">CopyrightWebpackPlugin</span>;<br></code></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua">// webpack.<span class="hljs-built_in">config</span>.js<br><br>const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const CopyRightWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./plugins/copyright-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    &#125;,<br>    plugins: [<br>        new CopyRightWebpackPlugin()<br>    ],<br>    <span class="hljs-built_in">output</span>: &#123;<br>        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样，一个简易的 <code>Plugin</code> 就完成啦</strong><br><br></br></p><h4 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h4><h5 id="往插件里传参"><a href="#往插件里传参" class="headerlink" title="往插件里传参"></a>往插件里传参</h5><p>在 Webpack 配置文件创建插件实例时，同时传入参数就行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">plugins: [<br>    new <span class="hljs-built_in">CopyRightWebpackPlugin</span>(&#123;<br>        name: <span class="hljs-string">&#x27;Smoothzjc&#x27;</span><br>    &#125;)<br>],<br><br></code></pre></td></tr></table></figure><p>这样，就可以在类的构造函数中接收到该参数了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyrightWebpackPlugin</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是&#x27;</span>, options.<span class="hljs-property">name</span>)<br>    &#125;<br>    <br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">CopyrightWebpackPlugin</span>;<br></code></pre></td></tr></table></figure><p><br></br></p><h5 id="不同生命周期"><a href="#不同生命周期" class="headerlink" title="不同生命周期"></a>不同生命周期</h5><p>前面我有提到，在打包的某个生命周期，插件会帮助你做一些事情，</p><p>所以我们可以在 <code>Webpack</code> 打包的不同生命周期时，写一些想让 Webpack 帮我们做的事</p><p><strong>常用生命周期：</strong></p><ul><li><code>emit</code> 异步钩子，打包完成准备将打包内容放到生成目录前，即打包完成的最后时刻</li><li><code>compile</code> 同步钩子，准备进行打包前</li></ul><p><strong>下面示例的一些参数解释：</strong></p><p><code>compiler</code> 配置的所有内容，包括打包相关的内容</p><p><code>compilation</code> 本次打包的所有内容</p><p>如果你想在打包完成前新加一个文件到打包目录下，可以配置 <code>compilation</code> 的 <code>assets</code> 属性</p><p><strong>相关代码运行在 <code>apply</code> 属性中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyrightWebpackPlugin</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是&#x27;</span>, options.<span class="hljs-property">name</span>)<br>    &#125;<br>    <br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <br>        <span class="hljs-comment">// 同步钩子 compile</span><br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compile</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;同步钩子 compile 生效&#x27;</span>);<br>        &#125;)<br>    <br>        <span class="hljs-comment">// 异步钩子 emit</span><br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, cb</span>) =&gt;</span> &#123;<br>            compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&#x27;copyright.txt&#x27;</span>] = &#123;<br>                <span class="hljs-comment">// 文件内容配置在 source 属性中，该例子意思是文件内容是一个函数，且返回值是如下</span><br>                <span class="hljs-attr">source</span>: <span class="hljs-title function_">funciton</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;copyright write by Smoothzjc&#x27;</span><br>                &#125;,<br>                <span class="hljs-comment">// 该文件大小</span><br>                <span class="hljs-attr">size</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">28</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 由于异步钩子，所以要运行回调函数</span><br>            <span class="hljs-title function_">cb</span>();<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">CopyrightWebpackPlugin</span>;<br></code></pre></td></tr></table></figure><p><br></br></p><h5 id="编写插件时进行调试"><a href="#编写插件时进行调试" class="headerlink" title="编写插件时进行调试"></a>编写插件时进行调试</h5><p>大部分调试工具都是基于 node 编写，在此我举个例子，如何在编写 <code>plugin</code> 时使用调试工具进行 <code>debug</code></p><ol><li>先添加脚本指令，通过 <code>node</code> 运行调试工具</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// package.json</span><br><br>&#123;<br>    <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;debug&quot;</span>: node --<span class="hljs-keyword">inspect</span> --<span class="hljs-keyword">inspect</span>-brk node_modules<span class="hljs-regexp">/webpack/</span>bin/webpack.js,<br>        <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在需要调试的地方打断点</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyrightWebpackPlugin</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是&#x27;</span>, options.<span class="hljs-property">name</span>)<br>    &#125;<br>    <br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compile</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;compiler&#x27;</span>);<br>        &#125;)<br>    <br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;CopyrightWebpackPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, cb</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">debugger</span>; <span class="hljs-comment">// 在此处打断点</span><br>            compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&#x27;copyright.txt&#x27;</span>] = &#123;<br>                <span class="hljs-comment">// 文件内容配置在 source 属性中，该例子意思是文件内容是一个函数，且返回值是如下</span><br>                <span class="hljs-attr">source</span>: <span class="hljs-title function_">funciton</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;copyright write by Smoothzjc&#x27;</span><br>                &#125;,<br>                <span class="hljs-comment">// 该文件大小</span><br>                <span class="hljs-attr">size</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">28</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 由于异步钩子，所以要运行回调函数</span><br>            <span class="hljs-title function_">cb</span>();<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">CopyrightWebpackPlugin</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>控制台运行 <code>debug</code> 指令 <code>npm run debug</code> 后</p></li><li><p>打开浏览器按 F12 打开控制台，可以在开发者工具左上角看到 node 图标，点击即可进入 webpack 打包时经过的一些页面</p></li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e37566b8407447b7867544babcb6b901~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol start="5"><li>可以将鼠标放上想查看的变量的属性</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6735305f379b45399349cad5afee116c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol start="6"><li>或在右边的 <code>Watch</code> 属性输入想查看的属性名称进行查看</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9b182bd8c1247ed873aa7216ce98b69~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><br></br></p><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>打包的入口文件，并指定打包后生成的 js文件名</p><p>参数：字符串 或 一个对象，默认生成的文件名是 <code>main</code>，即 <code>生成的文件名：&#39;入口文件路径&#39;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span><br>或<br>entry: &#123;<br>    <span class="hljs-selector-tag">main</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span><br>&#125;<br>同时上面跟下面的等价<br></code></pre></td></tr></table></figure><p>同时也可以打包成多个 js 文件，即多入口</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">entry:&#123;<br>    <span class="hljs-selector-tag">main</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    sub: <span class="hljs-string">&#x27;./src/index.js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出js文件名</p><p>参数：</p><ul><li><code>filename</code> 最后打包出来的 js 文件名，可以直接 <code>bundle.js</code> 指定，也可以 <code>[name].js</code> 根据 entry 指定的名字，也可以 <code>[hash].js</code> 根据 entry 指定的哈希值</li><li><code>chunkFilename</code> 通过异步引入的文件的文件名</li></ul><!----><ul><li><code>path</code> 打包后所处文件夹和路径</li></ul><!----><ul><li><code>publicPath</code> 给打包出来的 js 文件的 src 引入路径都加个前缀，一般用于 cdn 配置</li></ul><p><strong>publicPath 详解</strong></p><p>例如：</p><p><code>index.html</code> 中引入 js 板块的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果想将打包后的js 文件都放到 cdn上，减少打包后体积(此时该js就不用放在打包后的文件夹中了)，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://cdn.com.cn/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可配置成如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">publicPath: <span class="hljs-symbol">&#x27;http</span>:<span class="hljs-comment">//cdn.com.cn&#x27;</span><br></code></pre></td></tr></table></figure><p>output配置示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">output: &#123;<br>    publicPath: <span class="hljs-string">&#x27;http://cdn.com.cn&#x27;</span>,<br>    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    chunkFilename: <span class="hljs-string">&#x27;[name].chunk.js&#x27;</span>,<br>    path: path.<span class="hljs-built_in">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>模块引入时的更多拓展操作</p><ul><li><code>extensions</code> 模块引入时的后缀名查找</li><li><code>alias</code> 为路径配置别名</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">resolve: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.css&#x27;</span>, <span class="hljs-string">&#x27;.jpg&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>],<br>    alias: &#123;<br>        <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-string">&#x27;/src/pages&#x27;</span> <span class="hljs-regexp">//</span> 当输入 @ 时，自动替换为 <span class="hljs-regexp">/src/</span>pages<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p>在项目中以下面的方式引入模块时</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child&#x27;</span><br></code></pre></td></tr></table></figure><p>由于没写文件后缀名，会通过上面的配置按序查找，先找 <code>child.css</code> 存不存在如果存在就引入这个，如果不存在，则继续找 <code>child.jpg</code> 存不存在，一直找到 <code>child.jsx</code>，如果还不存在，就会报错</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>为路径配置别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span>: &#123;<br>    <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-string">&#x27;/src/pages&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解释：当输入 @ 时，自动替换为 &#x2F;src&#x2F;pages</p><p>常用场景：当你频繁使用根路径的方式引用某些文件，比如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/src/pages/a.js&#x27;</span>;<br><span class="hljs-keyword">import</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/src/pages/b.js&#x27;</span>;<br><span class="hljs-keyword">import</span> c <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/src/pages/c.js&#x27;</span>;<br><span class="hljs-keyword">import</span> d <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/src/pages/d.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p>写多次 <code>/src/pages</code> 会很麻烦，用 <code>@</code> 代替 <code>/src/pages</code> 会简化了输入，提高开发效率</p><blockquote><p><strong>注意：<code>resolve</code> 要进行合理配置，不然会降低性能，因为如果你要找 <code>child.jsx</code>，按照上面配置，要经过前面三个没必要的步骤</strong><br><br></br></p></blockquote><h2 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h2><p>打包后的文件是否开启映射关系，他知道打包后文件与打包前源代码文件的代码映射</p><p>例如：知道 dist 目录下 main.js 文件96行报错，实际上对应的是 src 目录下 index.js 文件中的第一行</p><p><strong>通常不用开启，默认 <code>none</code> 关闭，因为开启后会减缓打包速度和增大打包体积</strong></p><p>参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">devtool: <span class="hljs-string">&#x27;参数&#x27;</span><br><br><span class="hljs-string">&#x27;none&#x27;</span> <span class="hljs-regexp">//</span> 不开启source-map<br><span class="hljs-string">&#x27;source-map&#x27;</span> <span class="hljs-regexp">//</span> 开启source-map进行映射<br><span class="hljs-string">&#x27;inline-source-map&#x27;</span> <span class="hljs-regexp">//</span> 开启source-map进行映射的前提下，精确到哪一行哪一列<br><span class="hljs-string">&#x27;cheap-source-map&#x27;</span> <span class="hljs-regexp">//</span> 开启source-map进行映射的前提下，只精确到哪一行<br><span class="hljs-string">&#x27;eval&#x27;</span> <span class="hljs-regexp">//</span> 通过 eval 开启映射，效率最快，但不全面<br></code></pre></td></tr></table></figure><p>推荐：</p><p>开发环境：<code>devtool: &#39;cheap-module-eval-source-map&#39;</code></p><p>生产环境(线上环境)：<code>devtool: &#39;cheap-module-source-map&#39;</code></p><p>生产环境一般不用配置 devtool，但如果想报错时快速定位错误，可开启，建议使用上面推荐的参数</p><p><code>mode: &#39;development&#39;</code> 是开发环境</p><p><code>mode: &#39;production&#39;</code> 是生产环境</p><p>更多其他参数查看下表</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/454cc6ebbef548bb91adf970d6daca67~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>SourceMap 配置示例</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golo">devtool: &#x27;cheap-<span class="hljs-keyword">module</span>-source-<span class="hljs-keyword">map</span>&#x27;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="WebpackDevServer"><a href="#WebpackDevServer" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><p>开启一个本地web服务器，可提高开发效率</p><p><code>webpack</code> 指令(一般直接配置第二个脚本就行)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> webpack --watch  保存后自动重新打包<br><span class="hljs-bullet">2.</span> webpack-dev-server  启动一个web服务器，并将对应目录资源进行打开，对应目录资源修改后保存会重新进行打包，且自动对网页进行刷新<br></code></pre></td></tr></table></figure><p>我们下载的每个项目都经过两条指令(安装依赖 + 打包运行)，下面以 create-react-app 脚手架生成的 react 项目为例</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install<br><span class="hljs-built_in">npm</span> run start<br></code></pre></td></tr></table></figure><p>第二步，其实就是运行 <code>WebpackDevServer</code>，你会发现，start 后会直接打开浏览器，且每次保存后都会自动重新打包、重新刷新网页。</p><p><code>WebpackDevServer</code> 隐藏特性：打包后的资源不会生成一个 dist 文件夹，而是将打包后资源放在电脑内存中，能有效提高打包速度</p><p>参数</p><ul><li><code>contentBase</code> 将哪个目录下的文件放到 web 服务器上进行打开</li><li><code>open</code> 是否在打包时同时打开<strong>浏览器</strong>访问项目对应预览 url</li><li><code>port</code> 端口号</li><li><code>proxy</code> 设置代理</li></ul><p>WebpackDevServer 配置示例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">webpackDevServer:</span> &#123;<br>    <span class="hljs-attr">contentBase:</span> <span class="hljs-string">&#x27;./dist&#x27;</span>,<br>    <span class="hljs-attr">open:</span> <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>,<br>    <span class="hljs-attr">proxy:</span> &#123;<br>        <span class="hljs-attr">&#x27;api&#x27;:</span> <span class="hljs-string">&#x27;xxxxx&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拓展内容"><a href="#拓展内容" class="headerlink" title="拓展内容"></a>拓展内容</h4><p>其实相当于自己手写一个 webpack-dev-server，但人家官方已经帮我们写好一个各配置项都齐全的一个了，自己不用手写了，只是带大家进行拓展，理解一下 webpack-dev-server 背后的源码是如何搭配 node 实现的</p><p>在 node 中使用 webpack</p><p>查看<a href="https://webpack.js.org/api/cli/#usage-width-config-file">官方文档</a> 的 <code>Node.js API</code> 板块</p><p>在命令行中使用 webpack</p><p>查看<a href="https://webpack.js.org/api/cli/#usage-width-config-file">官方文档</a> 的 <code>Command Line Interface</code> 板块<br><br></br></p><h2 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h2><h4 id="热模块更新-HMR"><a href="#热模块更新-HMR" class="headerlink" title="热模块更新 HMR"></a>热模块更新 <code>HMR</code></h4><p>当内容发生更改时，只有更改的那部分发生变化，其他已加载的部分不会重新加载(例如修改css样式，只有对应样式更改，js不会改变)</p><p>参数</p><ul><li><code>hot</code> 开启热模块更新</li><li><code>hotOnly</code> 设置为 true 后，无论热更新是否开启，都禁用 <code>webpackDevServer</code> 的保存后自动刷新浏览器功能</li></ul><p>也是配置到 <code>webpackDevServer</code> 里</p><p><code>HMR</code>配置示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">hotOnly</span>: <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()<br>]<br></code></pre></td></tr></table></figure><p>上面是让 <code>HMR</code> 生效，下面是对 <code>HMR</code> 进行使用</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">// 例子：当 number.js 发生更改时，会调用函数<br><span class="hljs-keyword">import</span> number <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./number&#x27;</span>;<br>number();<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">module</span>.hot) &#123;<br>    <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./number&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        number();<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>但上面的 <strong>使用</strong> 一般不用写，因为其实很多地方都已经写好了，内置了 <code>HMR</code> 组件，例如css的话 <code>css-loader</code> 里面给你写好了，vue 的话 <code>vue-loader</code> 里写好了，react 的话 <code>babel-preset</code> 写好了。</p><p>如果你要引入比较冷门的数据文件，没有内置 <code>HMR</code>，就需要写。<br><br></br></p><h2 id="使用-Babel-处理-ES6-语法"><a href="#使用-Babel-处理-ES6-语法" class="headerlink" title="使用 Babel 处理 ES6 语法"></a>使用 Babel 处理 ES6 语法</h2><p><code>babel-loader</code>、<code>@babel/preset-env</code>、<code>@babel/polyfill</code></p><ul><li>babel-loader 的配置选项可以单独写进 <code>.babelrc</code> 文件里</li><li>除了将 ES6 转换成 ES5 还不够，有些低版本浏览器还需要将 Promise、Array.map 注入额外代码，需要引入 <code>@babel/polyfill</code></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@babel</span>/preset-env 的参数<br><br><span class="hljs-attribute">useBuiltIns</span>: <span class="hljs-string">&#x27;usage&#x27;</span> // 对于使用的代码，才转译成 ES5 并打包至 dist 文件夹<br><span class="hljs-attribute">targets</span>: 该代码运行环境，根据环境来判定是否要做 ES6 的转化<br>&#123;<br>    chrome: <span class="hljs-string">&#x27;67&#x27;</span> // 谷歌浏览器版本大于<span class="hljs-number">67</span>，对 ES6 能直接正常编译，所以没必要做 ES5 的转换了<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs gradle">module: &#123;<br>    rules: [<br>        &#123;<br>            test: <span class="hljs-regexp">/.js$/</span>,<br>            <span class="hljs-keyword">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>            loader: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>            <span class="hljs-keyword">options</span>: &#123;<br>                <span class="hljs-comment">// 以下演示两种方案</span><br>                presets: [[<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123;<br>                    targets: &#123;<br>                        edge: <span class="hljs-string">&#x27;17&#x27;</span>,<br>                        firefox: <span class="hljs-string">&#x27;60&#x27;</span>,<br>                        chrome: <span class="hljs-string">&#x27;67&#x27;</span>,<br>                        safari: <span class="hljs-string">&#x27;11.1&#x27;</span><br>                    &#125;,<br>                    useBuiltIns: <span class="hljs-string">&#x27;usage&#x27;</span><br>                &#125;]]<br>                <br>                <span class="hljs-comment">// 以下是生成第三方库或源组件，不希望 babel 污染时才使用，可替换上面的 presets</span><br>                plugins: [[<span class="hljs-string">&quot;babel/plugin-transform-runtime&quot;</span>, &#123;<br>                    <span class="hljs-string">&quot;corejs&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;helpers&quot;</span>: <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-string">&quot;regenerator&quot;</span>: <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-string">&quot;useESModules&quot;</span>: <span class="hljs-keyword">false</span><br>                &#125;]]<br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="如果你想在-react-使用-babel"><a href="#如果你想在-react-使用-babel" class="headerlink" title="如果你想在 react 使用 babel"></a>如果你想在 react 使用 babel</h4><p>实现对 React 框架代码的打包</p><p>下载 <code>@babel/preset-react</code></p><p>.babelrc 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>    presets: [<br>        [<br>            <span class="hljs-string">&quot;babel/preset-env&quot;</span>, &#123;<br>                targets: &#123;<br>                    chrome: <span class="hljs-string">&quot;67&quot;</span>,<br>                &#125;,<br>                useBuiltIns: <span class="hljs-string">&quot;usage&quot;</span><br>            &#125;<br>        ],<br>        &quot;<span class="hljs-keyword">@babel</span>/preset-react&quot;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Webpack-高级概念"><a href="#Webpack-高级概念" class="headerlink" title="Webpack 高级概念"></a>Webpack 高级概念</h1><p><code>webpack</code> 的 <code>Guides</code> 板块</p><p><a href="https://webpack.js.org/guides/">官方文档</a></p><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>只会对引入进行使用的代码进行打包，没引入进行使用的代码不会打包(可减少代码体积)，webpack 2.0 之后默认开启该功能</p><ul><li>只支持 ES Module(静态引入)</li></ul><!----><ul><li>不支持 Common JS(动态引入)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// ESM  支持</span><br><span class="hljs-keyword">const</span> xxx = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// Common JS  不支持</span><br></code></pre></td></tr></table></figure><p>development(开发环境) 默认不打开 <code>Tree Shaking</code></p><p>因为如果开发环境进行调试时，如果每次重新编译打包后的代码都进行了 <code>Tree Shaking</code>，那就会让 debug 时代码行数对不上，不利于调试</p><p>如果你想开发环境打开</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// package.json</span><br>&#123;<br>    <span class="hljs-string">&quot;sideEffects&quot;</span>: <span class="hljs-literal">false</span> 或 数组<br>&#125;<br><br>如果是数组，则配置你不想哪些代码进行 Tree Shaking<br>例如：如果不想 css 文件进行 Tree Shaking，则<br>&#123;<br>    <span class="hljs-string">&quot;sideEffects&quot;</span>: [<span class="hljs-string">&quot;*.css&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="Development-和-Production-模式的区分打包"><a href="#Development-和-Production-模式的区分打包" class="headerlink" title="Development 和 Production 模式的区分打包"></a>Development 和 Production 模式的区分打包</h2><p>通常来说，两个环境的 webpack 配置文件不会有变化，但如果非得区分，可以不同文件形式</p><p><code>webpack.dev.js</code> 根据名字可知，是 development(开发环境)</p><p><code>webpack.proud.js</code> 根据名字可知，是 production(生产环境)</p><p>打包脚本也要更改，如果区别开</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// package.json</span><br>&#123;<br>    <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;dev-build&quot;</span>: webpack <span class="hljs-attr">--config</span> webpack<span class="hljs-selector-class">.dev</span><span class="hljs-selector-class">.js</span>, <span class="hljs-comment">// 相对路径</span><br>        <br>        或<br>        <br>        <span class="hljs-string">&quot;proud-build&quot;</span>: webpack <span class="hljs-attr">--config</span> webpack<span class="hljs-selector-class">.proud</span><span class="hljs-selector-class">.js</span>, <span class="hljs-comment">// 相对路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="Webpack-和-Code-Splitting"><a href="#Webpack-和-Code-Splitting" class="headerlink" title="Webpack 和 Code Splitting"></a>Webpack 和 Code Splitting</h2><h3 id="为什么要进行代码分割？"><a href="#为什么要进行代码分割？" class="headerlink" title="为什么要进行代码分割？"></a>为什么要进行代码分割？</h3><p>如果用户一个页面要加载的 js 文件很大，足足有2MB，那么用户每次访问这个页面，都要加载完2MB的资源页面才能正常显示，但其中可能有很多代码块是当前页面不需要使用的，那么将没使用的代码分割成其他 js 文件，当要使用的时候再进行加载、当页面变更时只有那部分进行重新加载，这样可以大大加快页面加载速度。</p><blockquote><p><strong>即通过配置进行合理的代码分割，能让文件结构更清晰，项目运行更快，比如如果用到 lodash 库，就分割出来。</strong></p></blockquote><p>下面通过一个例子进行解释：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">假设现在有 <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>(<span class="hljs-number">2</span>MB)，里面含有 lodash<span class="hljs-selector-class">.js</span>(<span class="hljs-number">1</span>MB)<br><span class="hljs-number">1</span>. 该种方式<br>首次访问页面时，加载 <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>(<span class="hljs-number">2</span>MB)<br>当页面业务逻辑发生变化时，又要重新加载<span class="hljs-number">2</span>MB内容<br><br><span class="hljs-number">2</span>. 将 lodash<span class="hljs-selector-class">.js</span> 抽离出来，即现在是 <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>(<span class="hljs-number">1</span>MB) 和 lodash<span class="hljs-selector-class">.js</span>(<span class="hljs-number">1</span>MB)<br>由于浏览器的并行机制，首次访问页面时，并行渲染两个<span class="hljs-number">1</span>MB的文件是要比只渲染一个<span class="hljs-number">2</span>MB的文件要快的。<br>其次，当页面业务逻辑发生变化时，只要重新加载 <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>(<span class="hljs-number">1</span>MB) 即可。<br><br></code></pre></td></tr></table></figure><p>同时，如果对于两个文件，如果都有用到某个模块，如果两个文件各自写一次这个模块，就会有重复，此时如果将这个公共模块抽离出来，两个文件分别去引用他，那么就会减少一次该模块的撰写(减少包体积)。</p><blockquote><p><strong>即对代码进行合理分割，还可以加快首屏加载速度，加快重新打包速度(包体积减少)</strong></p></blockquote><p><strong>代码分割：通俗解释就是将一坨代码分割成多个 js 文件</strong></p><p>代码分割自己可以手动，例如我们平时的抽离公共组件，但为什么现在 <code>webpack</code> 几乎跟 <code>Code Splitting</code> 绑定在一起了呢？</p><p>因为 <code>webpack</code>中有一个插件 <code>SplitChunksPlugin</code>，会让代码分割变得非常简单， 这也是 <code>webpack</code> 的一个强大的竞争力点</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// webpack.config.js</span><br>&#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;all&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p><code>Webpack</code> 进行 <code>Code Splitting</code> 有两种方式</p><p><strong>1.  通过配置插件 <code>SplitChunksPlugin</code></strong></p><pre><code class="hljs"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// webpack.config.js</span><br>&#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;all&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>然后编写同步代码<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><span class="hljs-comment">// 编写业务代码</span><br></code></pre></td></tr></table></figure></code></pre><!----><p><strong>2.  通过异步地动态引入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getComponent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        element.<span class="hljs-property">innerHTML</span> = _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;zjc&#x27;</span>, <span class="hljs-string">&#x27;handsome&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">getComponent</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(element);<br>&#125;)<br></code></pre></td></tr></table></figure><p>当然，想要支持异步地动态引入某个模块，需要先下载 <code>babel-plugin-dynamic-import-webpack</code></p><p>然后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-selector-class">.babelrc</span><br>&#123;<br>    presets: [<br>        [<br>            <span class="hljs-string">&quot;@babel/preset-env&quot;</span>, &#123;<br>                targets: &#123;<br>                    chrome: <span class="hljs-string">&quot;67&quot;</span><br>                &#125;,<br>                useBuiltIns: <span class="hljs-string">&#x27;usage&#x27;</span><br>            &#125;<br>        ],<br>        &quot;<span class="hljs-keyword">@babel</span>/preset-react&quot;<br>    ],<br>    <span class="hljs-attribute">plugins</span>: [<span class="hljs-string">&quot;dynamic-import-webpack&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h2><p>该板块会对该插件配置参数进行详解</p><p>重要作用是可以减少包体积，缓存组中的 <code>reuseExistingChunk</code> 属性：开启true后，如果要分割进该组的模块在之前已经被缓存到了某个组内，那就不会再缓存</p><p>配置示例</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">module.exports = &#123;<br>  <span class="hljs-regexp">//</span>...<br>  optimization: &#123;<br>    splitChunks: &#123;<br>      chunks: <span class="hljs-string">&#x27;all&#x27;</span>, <span class="hljs-regexp">//</span> 只对哪些代码进行分割(all 的话全部都，async 的话只对异步代码进行分割)<br>      minSize: <span class="hljs-number">30000</span>, <span class="hljs-regexp">//</span> 要做代码分割的引入库的最小大小，即<span class="hljs-number">30000</span>代表如果你引入的库大小超过<span class="hljs-number">30</span>KB才做代码分割<br>      minRemainingSize: <span class="hljs-number">0</span>,<br>      minChunks: <span class="hljs-number">1</span>, <span class="hljs-regexp">//</span> 一个库被引入至少多少次才做代码分割<br>      maxAsyncRequests: <span class="hljs-number">5</span>, <span class="hljs-regexp">//</span> 同时分割的库数<br>      maxInitialRequests: <span class="hljs-number">3</span>, <span class="hljs-regexp">//</span> 最多能分割出多少个 js 文件<br>      automaticNameDelimiter: <span class="hljs-string">&#x27;~&#x27;</span>, <span class="hljs-regexp">//</span> 代码分割出来的 js 文件名 和下面的组名 用什么符号进行连接<br>      name: <span class="hljs-string">&#x27;true&#x27;</span> <span class="hljs-regexp">//</span> 当为 true 时，下面组的 filename 属性才会生效<br>      enforceSizeThreshold: <span class="hljs-number">50000</span>,<br>      <span class="hljs-regexp">//</span> 缓存组，当打包同步代码时，除了走完上面的设置流程，还会额外再走进下面的组设置，即代码分割进下面符合要求的各组<br>      cacheGroups: &#123;<br>        vendors: &#123;<br>          test: <span class="hljs-regexp">/[\/]node_modules[\/]/</span>, <span class="hljs-regexp">//</span> 只有 node_modules 里面的库被引入时，才做代码分割到 vendor 组<br>          priority: -<span class="hljs-number">10</span>, <span class="hljs-regexp">//</span> 优先级，越大优先级越高<br>          reuseExistingChunk: true,<br>          filename: <span class="hljs-string">&#x27;vendors.js&#x27;</span>, <span class="hljs-regexp">//</span> vendors 组的代码分割都分割到 filename 文件内<br>          name: <span class="hljs-string">&#x27;vendors&#x27;</span> <span class="hljs-regexp">//</span> 生成 vendors.chunk.js，该属性和上面的 filename 写一个就行<br>        &#125;,<br>        default: &#123;<br>          minChunks: <span class="hljs-number">2</span>,<br>          priority: -<span class="hljs-number">20</span>,<br>          reuseExistingChunk: true, <span class="hljs-regexp">//</span> 开启true后，如果要分割进该组的模块在之前已经被缓存到了某个组内，那就不会再缓存<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>更多配置项请看<a href="https://webpack.docschina.org/plugins/split-chunks-plugin">官方文档</a><br><br></br></p><h2 id="Lazy-Loading"><a href="#Lazy-Loading" class="headerlink" title="Lazy Loading"></a>Lazy Loading</h2><p>通过异步地动态引入某个模块，通常在路由配置页面，对引入的组件进行懒加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getComponent</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>        element.<span class="hljs-property">innerHTML</span> = _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;zjc&#x27;</span>, <span class="hljs-string">&#x27;handsome&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">getComponent</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(element);<br>&#125;)<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h2><p>应用 <code>webpack</code> 官方工具 <code>Bundle Analysis</code><br><br></br></p><h2 id="Preloading、Prefetching"><a href="#Preloading、Prefetching" class="headerlink" title="Preloading、Prefetching"></a>Preloading、Prefetching</h2><p><code>Preloading</code> 懒加载，当进行某个事件时，才会引入某个组件，例如点击某个元素时，才会 <code>import</code> 引入组件</p><p><code>PreFetching</code> 预加载，当主页面的核心功能和交互都加载完成后，如果网络空闲，那么就会预先加载某个组件，这样在某个时刻引入该组件时，就能一下子打开</p><p>实现预加载：</p><p><code>webpack</code> 搭配魔法注释，在引入的路径前加上 <code>webpackPrefetch: xxx</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, () =&gt; &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">&#x27;./click.js&#x27;</span>).then((func) =&gt; &#123;<br>        func()<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这也是 <code>webpack</code> 最为推荐的首屏加载优化手段，异步引入 + 预加载<br><br></br></p><h2 id="CSS-文件的代码分割"><a href="#CSS-文件的代码分割" class="headerlink" title="CSS 文件的代码分割"></a>CSS 文件的代码分割</h2><p>前面的 <code>Code splitting</code> 都是针对 js 的，将 js 文件进行代码分割，而打包出来的 css 都在 js 文件里</p><p>如果想 CSS 文件也代码分割出来，可以使用 <code>MiniCssExtractPlugin</code> 插件，该插件由于依赖热更新，所以只能运行在线上打包环境中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>); <br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [ <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>() ],<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>且默认将引入的各 css 文件合并到同一个 css 文件里</p><p>如果你想代码分割出来的 css 文件做代码压缩，重复属性合并到一起，可以使用 <code>OptimizeCSSAssetsPlugin</code> 插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>); <br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">minimizer</span>: [<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>(&#123;&#125;)<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [ <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>() ],<br>    <span class="hljs-attr">module</span>: &#123;<br>      <span class="hljs-attr">rules</span>: [<br>        &#123;<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,<br>          <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>        &#125;,<br>      ],<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果想多入口引入的 css文件也合并在一起，同样需要用到代码分割</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>); <br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">splitChunks</span>: &#123;<br>            <span class="hljs-attr">cacheGroups</span>: &#123;<br>                <span class="hljs-attr">styles</span>: &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;styles&#x27;</span>, <span class="hljs-comment">// 都打包进 styles.css 的文件里</span><br>                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,<br>                    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>                    <span class="hljs-attr">enforce</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 无视默认参数，如果你在代码分割时设置过一些参数，当你对css文件进行代码分割时可以无视</span><br>                &#125;<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">plugins</span>: [ <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>() ],<br>        <span class="hljs-attr">module</span>: &#123;<br>          <span class="hljs-attr">rules</span>: [<br>            &#123;<br>              <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,<br>              <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<br>            &#125;,<br>          ],<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="Webpack-与浏览器缓存-Cache"><a href="#Webpack-与浏览器缓存-Cache" class="headerlink" title="Webpack 与浏览器缓存(Cache)"></a>Webpack 与浏览器缓存(Cache)</h2><blockquote><p><strong>当浏览器加载过某项资源时会在本地进行缓存记忆，这样当用户下次再重新访问该页面加载该资源时，浏览器可以根据缓存过的文件快速加载该资源，直到该文件名发生改变，浏览器才知道该文件发生改变，需要重新渲染。</strong></p></blockquote><p><strong>浏览器该特性的作用</strong></p><p>可以加快加载速度，当该页面某个部分发生改变时，可以只重新渲染改变的部分，做到局部渲染</p><p>问题：如何保证每次打包时只有做了更改的文件的文件名发生更改，没做更改的文件的文件名不变？</p><p>如果在 <code>webpack</code> 配置文件中的 <code>output</code> 属性设置为如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">output: &#123;<br>    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    chunkFilename: <span class="hljs-string">&#x27;[name].chunk.js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果对项目中文件做了更改，而文件名没变，打包的 filename 没变，由于浏览器已经加载过该文件，缓存了这个文件名，当你该文件发生更改而文件名没改变时，浏览器不会重新渲染，为了让每次文件更改后文件名都发生改变，可以使用<strong>哈希值命名</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">output: &#123;<br>    filename: <span class="hljs-string">&#x27;[name].[contenthash].js&#x27;</span>,<br>    chunkFilename: <span class="hljs-string">&#x27;[name].chunk.js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>让 <code>webpack</code> 根据文件内容创建对应独立的一个哈希值，同时在文件内容发生改变时，由于哈希值也会改变，所以文件名也会改变</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在老版本 <code>webpack</code> 中(webpack 4.0 以下)，如果在每次运行 <code>npm run build</code> 进行打包时，发现即使文件没变更，每次重新打包他们的哈希值都会变，可以通过配置 <code>runtimeChunk</code> 解决</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">optimization: &#123;<br>    runtimeChunk: &#123;<br>        name: <span class="hljs-string">&#x27;runtime&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 同时打包后会多生成一个 runtime.hash.js 的文件，hash每次都不一样</span><br></code></pre></td></tr></table></figure><h4 id="runtimeChunk-原理"><a href="#runtimeChunk-原理" class="headerlink" title="runtimeChunk 原理"></a>runtimeChunk 原理</h4><p>假设我通过 <code>webpack</code> 打包出来有两个 js文件，A文件是业务逻辑相关代码，B文件是作代码分割时的库代码(例如 lodash)，由于业务逻辑中有引入库的操作，所以他们之间会有关联，而这个关联的相关代码同时存在于A和B文件(这种关联我们一般称之为 <code>manifest</code>)，而在每次打包时，<code>manifest</code> 内置的包和包的关系、js和js文件的嵌套关系会发生微小改变，所以即使A和B文件没做更改时，打包出来的哈希值还是会发生变化。</p><p>通过配置 <code>runtimeChunk</code> ，可以将这些 <code>manifest</code> 相关的代码抽离出来单独放在 <code>runtimeChunk</code> 中，因此每次重新打包，改变的只有<code>runtime.hash.js</code>，A文件只有业务逻辑，B文件只有库文件，A和B文件内都不会有任何 <code>manifest</code> 的代码了，这样A和B文件都不会发生改变了，因此哈希值就不会变了<br><br></br></p><h2 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h2><p>打包兼容，自动引入</p><p>在你页面使用到某个库，但没进行引入时，<code>webpack</code> 打包后的代码会帮你自动、”偷偷”进行引入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">plugins: [<br>    new webpack.ProvidePlugin(&#123;<br>        $: <span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-regexp">//</span> 当使用 $ 时，会自动在那个页面引入 jquery 库<br>        _: <span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-regexp">//</span> 当使用 _ 时，会自动在那个页面引入 lodash 库<br>        _join: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;join&#x27;</span>] <span class="hljs-regexp">//</span> 当输入 _join 时，会引入 lodash库的 join 方法<br>    &#125;)<br>]<br></code></pre></td></tr></table></figure><p><br></br></p><h2 id="更多-2"><a href="#更多-2" class="headerlink" title="更多"></a>更多</h2><h3 id="环境变量的使用"><a href="#环境变量的使用" class="headerlink" title="环境变量的使用"></a>环境变量的使用</h3><p>对于开发环境和生产环境，可能有时真的需要单独写不同的 <code>webpack</code> 配置文件进行配置</p><p>而单独写，肯定有许多属性是重复的，又不想多写，怎么办呢？</p><p>例如A和B文件是两个环境中不同的配置参数，而C文件是共同的配置文件，那么开发环境打包时希望按照 A+C 的打包规则，生产环境打包时希望按照 B+C的打包规则</p><p><strong>可以通过 <code>webpack-merge</code> 配置 开发环境 和 生产环境 的 不同配置文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.common.js</span><br><br><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> devConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.dev.js&#x27;</span>); <span class="hljs-comment">// 假设有这个文件，且导出的是开发环境的一些配置参数</span><br><span class="hljs-keyword">const</span> prodConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.prod.js&#x27;</span>); <span class="hljs-comment">// 假设有这个文件，且导出的是生产环境的一些配置参数</span><br><span class="hljs-keyword">const</span> commonConfig = &#123;<br>    <span class="hljs-comment">// 这里放开发和生产环境共有的一些配置参数</span><br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果 env 参数存在，且传进来了 production 属性，说明是生产环境</span><br>    <span class="hljs-keyword">if</span>(env &amp;&amp; env.<span class="hljs-property">production</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonConfig， prodConfig);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(commonConfig， devConfig);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>同时 <code>package.json</code> 文件中修改配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    scripts: &#123;<br>        <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --config webpack.common.js&quot;</span>,<br>        <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --env.production --config webpack.common.js&quot;</span> <span class="hljs-regexp">//</span> 通过--env.production 传递参数进文件，执行线上环境的打包配置文件<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，脚本配置时，向配置文件传入参数也可以如下方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --env production --config webpack.common.js&quot;</span><br></code></pre></td></tr></table></figure><p>同时，<code>webpack.common.js</code> 参数判断时也要改成</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = <span class="hljs-function"><span class="hljs-params">(env, production)</span> =&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span> 如果 env 参数存在，且传进来了 production 属性，说明是生产环境<br>    <span class="hljs-keyword">if</span>(env &amp;&amp; production) &#123;<br>        <span class="hljs-keyword">return</span> merge(commonConfig， prodConfig);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> merge(commonConfig， devConfig);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br></p><blockquote><p><strong>🎁 谢谢你读完本篇文章，希望对你能有所帮助，如有问题欢迎各位指正。 <br /> 🎁 我是 Smoothzjc，如果觉得写得可以的话，请点个赞吧❤<br /> 🎁 我也会在今后努力产出更多好文。<br />🎁 感兴趣的小伙伴也可以关注我的公众号：Smooth前端成长记录，公众号同步更新</strong></p></blockquote><p>写作不易，<strong>「点赞」+「收藏」+「转发」</strong> 谢谢支持❤</p><h2 id="往期推荐"><a href="#往期推荐" class="headerlink" title="往期推荐"></a>往期推荐</h2><p><a href="https://juejin.cn/post/7065882915791437855">《都2022年了还不考虑来学React Hook吗？6k字带你从入门到吃透》</a></p><p><a href="https://juejin.cn/post/7064515729298554887">《Github + hexo 实现自己的个人博客、配置主题（超详细）》</a></p><p><a href="https://juejin.cn/post/7064024606276845581">《10分钟让你彻底理解如何配置子域名来部署多个项目》</a></p><p><a href="https://juejin.cn/post/7064005333437382670">《一文理解配置伪静态解决 部署项目刷新页面404问题</a></p><p><a href="https://juejin.cn/post/7060803746560737293">《带你3分钟掌握常见的水平垂直居中面试题》</a></p><p><a href="https://juejin.cn/post/7056073706564648968">《React实战：使用Antd+EMOJIALL 实现emoji表情符号的输入》</a></p><p><a href="https://juejin.cn/post/6993934486954049550">《【建议收藏】长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群》</a></p><p><a href="https://juejin.cn/post/6993350461172482078">《浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)》</a></p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6k字带你从入门到吃透 React Hook</title>
    <link href="/2022/02/18/6k%E5%AD%97%E5%B8%A6%E4%BD%A0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%90%83%E9%80%8F%20React%20Hook/"/>
    <url>/2022/02/18/6k%E5%AD%97%E5%B8%A6%E4%BD%A0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%90%83%E9%80%8F%20React%20Hook/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 文章会为你讲述 React 11种 Hook 的日常用法以及进阶操作，由浅入深带你彻底掌握 React Hook！<br /> 🙌 如文章有误，恳请评论区指正，谢谢！</strong></p></blockquote><h2 id="React-Hooks-是什么"><a href="#React-Hooks-是什么" class="headerlink" title="React Hooks 是什么"></a>React Hooks 是什么</h2><p><code>React Hooks</code> 是 <code>React V16.8</code> 中推出的新特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p><code>React Hooks</code> 的设计初衷，就是用于加强函数组件（原有函数组件无法存在状态），让你能够在不使用”类”的前提下写出一个全功能的组件。</p><p>顾名思义 <code>Hooks</code> 在中文中是“钩子”的意思，Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。<br><br></br></p><h2 id="React-Hooks-的特点"><a href="#React-Hooks-的特点" class="headerlink" title="React Hooks 的特点"></a>React Hooks 的特点</h2><ol><li>代码更清晰，解决了类组件难维护、逻辑不易复用的问题</li><li>hooks 之间的状态是独立的，有自己独立的上下文，不会出现混淆状态的情况，解决了类组件中 this指针指向不明确或由于使用不当而造成不必要的错误</li><li>让函数有了<strong>状态管理</strong></li><li>避免函数重复执行的副作用（通过相关 hook 进行限制）</li><li>Hooks 可以引用其他 Hooks，通过组合可以<strong>更方便复用</strong>。</li><li>更容易将组件的<strong>视图与状态分离</strong>。<br><br></br><h2 id="使用-Hook-的条件"><a href="#使用-Hook-的条件" class="headerlink" title="使用 Hook 的条件"></a>使用 Hook 的条件</h2>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则：<h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3></li></ol><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong>  确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p><h3 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h3><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong> 你可以：</p><ul><li>✅ 在 React 的函数组件中调用 Hook</li><li>✅ 在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p><p>同时，React 官方提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks 插件</a>来强制执行这些规则，不按规则使用直接给你进行警告或报错<br><br></br></p><h2 id="React-Hooks-的使用"><a href="#React-Hooks-的使用" class="headerlink" title="React Hooks 的使用"></a>React Hooks 的使用</h2><p>重点来了！</p><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>给函数组件添加初始状态（变量初始化），它和 Class Component 中的 this.setState 类似。</p><blockquote><p>当我们使用 <code>useState</code> 定义 state 变量时候，它返回一个有两个值的数组。第一个值是当前的 state，第二个值是更新 state 的函数<br>和闭包差不多，暴露函数内部的值和一个修改该值的函数，只不过要注意的是，该函数对数据的更新是异步的</p></blockquote><h4 id="下面是一个实现计数器的简易-demo"><a href="#下面是一个实现计数器的简易-demo" class="headerlink" title="下面是一个实现计数器的简易 demo"></a>下面是一个实现计数器的简易 demo</h4><p>需求：点击 Click me，计数进行 + 1</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b37f7c1572a5a64f935a5d19fc7020cf.png" alt="image.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/82de877194c2a8ce7c978e04bc9ed936.png" alt="image.png"></p><p>如图可知，useState 对 count 进行初始化为0，以及提供了一个可修改 count 值的函数 setCount，每次点击按钮都触发 onClick 事件调用 setCount 函数，在 count 的基础上进行 +1</p><h4 id="所谓批量更新原则"><a href="#所谓批量更新原则" class="headerlink" title="所谓批量更新原则"></a>所谓批量更新原则</h4><p>熟悉 React 的同学都清楚所谓 state 的变化 React 内部遵循的是<strong>批量更新</strong>原则。</p><blockquote><p><strong>所谓异步批量是指在一次页面更新中如果涉及多次 state 修改时，会合并多次 state 修改的结果得到最终结果从而进行一次页面更新。</strong></p></blockquote><h5 id="为什么-React-Hook-采取批量更新原则？"><a href="#为什么-React-Hook-采取批量更新原则？" class="headerlink" title="为什么 React Hook 采取批量更新原则？"></a>为什么 React Hook 采取批量更新原则？</h5><p>官方解释：如果不在当前屏幕，我们可以延迟执行相关逻辑。如果数据数据到达的速度快过帧速，我们可以合并、批量更新。我们优先执行用户交互（例如按钮点击形成的动画）的工作，延后执行相对不那么重要的后台工作（例如渲染刚从网络上下载的新内容），从而避免掉帧。</p><h5 id="关于如何辨别异步批量更新"><a href="#关于如何辨别异步批量更新" class="headerlink" title="关于如何辨别异步批量更新"></a>关于如何辨别异步批量更新</h5><ol><li><p><strong>凡是<code>React</code>可以管控的地方，他就是异步批量更新</strong>。比如事件函数，生命周期函数中，组件内部同步代码。</p></li><li><p><strong>凡是<code>React</code>不能管控的地方，就是同步批量更新</strong>。比如<code>setTimeout</code>,<code>setInterval</code>,<code>源生DOM</code>事件中，<strong>包括<code>Promise</code>中</strong>都是同步批量更新。</p></li></ol><blockquote><p><strong>在 React 18 中通过 createRoot 中对外部事件处理程序进行批量处理，换句话说最新的 React 中关于 setTimeout、setInterval 等不能管控的地方都变为了批量更新。</strong></p></blockquote><p><br></br></p><h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <br>    <span class="hljs-comment">//此处编写 组件挂载之后和组件重新渲染之后执行的代码 ... </span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <br>        <span class="hljs-comment">//此处编写 组件即将被卸载前执行的代码 ... </span><br>    &#125; <br>&#125;, [])<br></code></pre></td></tr></table></figure><p>useEffect 被称为副作用钩子，这个 Hook 和 useState 一样是一个基础钩子。Effect Hook 可以让你在函数组件中执行副作用操作，修改了数据获取、设置订阅、手动更改 React 组件中的 DOM、<code>console.log()</code> 、ajax 操作等等都是副作用。同时，可以使用多个 Effect 实现关注点分离。</p><p><strong>类似于 Vue 中的计算属性</strong></p><blockquote><p><strong>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</strong></p></blockquote><p>useEffect 支持三个参数</p><ul><li><p>第一个参数为一个函数，表示副作用效应函数，默认情况下它在第一次渲染之后和每次更新之后都会执行。</p></li><li><p>第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项。只有该数组中的变量发生变化时，副效应函数才会执行，如果数组为空，则代表该 useEffect 不随任何变量发生变化，即只渲染一次。</p></li><li><p>第三个参数是 <code>useEffect</code> 的返回值，返回一个函数，在 <code>useEffect</code> 执行之前，都会先执行里面返回的函数，一般用于添加销毁事件</p></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p><code>useEffect</code> 是在 render（浏览器完成画面渲染） 之后才执行，所以该 Hook 可接受第二个参数来控制跳过执行，下次 render 后如果指定的值没有变化就不会执行。</p></li><li><p><code>useEffect</code> 监听某个特定值时，不能对其进行 <code>setValue</code> 否则就会陷入死循环，直到页面卡死。</p></li></ol><p><br></br></p><h3 id="3-useLayoutEffect"><a href="#3-useLayoutEffect" class="headerlink" title="3. useLayoutEffect"></a>3. useLayoutEffect</h3><p>useLayoutEffect 与 useEffect 使用方式是完全一致的，useLayoutEffect 的区别在于它会在<strong>所有的DOM 变更之后同步</strong>调用 effect。</p><h5 id="useEffect：执行时机在-render-之后"><a href="#useEffect：执行时机在-render-之后" class="headerlink" title="useEffect：执行时机在 render 之后"></a>useEffect：执行时机在 render 之后</h5><h5 id="useLayoutEffect：执行时机在所有的-DOM-更新之后"><a href="#useLayoutEffect：执行时机在所有的-DOM-更新之后" class="headerlink" title="useLayoutEffect：执行时机在所有的 DOM 更新之后"></a>useLayoutEffect：执行时机在所有的 DOM 更新之后</h5><p>可以使用它来读取 DOM 布局并同步触发重渲染。在<strong>浏览器执行绘制之前</strong>， useLayoutEffect 内部的更新计划将被同步刷新。</p><p>当然，有时你可能需要使用另外一个情况下，如果你要更新的值（像 ref ），此时你需要确保它是在<strong>最新的任何其他代码运行之前</strong>，此时可以考虑使用 useLayoutEffect ，而不是 useEffect，</p><blockquote><p><strong>通常对于一些通过 JS 计算的布局，如果你想减少 useEffect 带来的「页面抖动」,你可以考虑使用 useLayoutEffect 来代替它。</strong></p></blockquote><p><br></br></p><h3 id="4-useContext"><a href="#4-useContext" class="headerlink" title="4. useContext"></a>4. useContext</h3><p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><p>熟悉 React 中Context Api 和 Vue 中的 provide&#x2F;inject Api 的同学可能会对这个钩子的作用深有体会。</p><h5 id="如果还不是很能理解作用，请看以下-demo"><a href="#如果还不是很能理解作用，请看以下-demo" class="headerlink" title="如果还不是很能理解作用，请看以下 demo"></a>如果还不是很能理解作用，请看以下 demo</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/dab92ab48dce084a84f663756612ddfa.png" alt="image.png"></p><p>在根组件上我们需要向下传递一个 count 属性给第三层子组件 H 使用</p><p>此时，如果使用 props 的方法进行<strong>层层传递</strong>那么无疑是一种噩梦。而且如果我们的 H 组件需要使用 count 但是 B、E 并不需要，如果使用 props 的方法难免在 B、E 组件内部也要<strong>显式声明 count</strong>。</p><p>React 中正是为了解决这样的场景提出来 Context Api。</p><p><strong>可以通过 React.createContext 创建 context 对象，在根组件中通过 Context.Provider 的 value 属性进行 count 变量的分发，从而在 Function Component 中使用 useContext(Context) 获取对应的值。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7b6d22d171635be6e01c611750ef619b.png" alt="image.png"></p><blockquote><p><strong>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context。</strong></p></blockquote><p>如果你想传递多个数据给子组件可以进行多个 <code>Context.Provider</code> 的嵌套</p><p><br></br></p><h3 id="5-useReducer"><a href="#5-useReducer" class="headerlink" title="5. useReducer"></a>5. useReducer</h3><p>React Hook 中还提供了一个关于状态管理的 useReducer，类似于 <strong>Vue 的 Vuex</strong>，全局状态管理工具</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init);<br></code></pre></td></tr></table></figure><p>useReducer 接受三个参数</p><ul><li>reducer 函数</li><li>初始值 initialArg</li><li>（可选）惰性初始化的 init 函数，它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</li></ul><p>本篇文章先不讲第三个函数（惰性初始化的 init 函数）的使用，有兴趣的同学可以去<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">官方文档</a>进行食用。</p><h5 id="useReducer-的使用"><a href="#useReducer-的使用" class="headerlink" title="useReducer 的使用"></a>useReducer 的使用</h5><ol><li>创建变量初始仓库 <code>initialArg</code> 和管理者 <code>reducer</code></li><li>通过 <code>useReducer(reducer, initialArg)</code> 来获取 <code>state</code> 和 <code>dispatch</code></li></ol><p>让我们通过一个简单的计数器例子来了解一下它的基础用法:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/51541fb9de27c589659708b1d9dd06cd.png" alt="image.png"></p><p><strong>demo 解释</strong></p><ol><li>先创建数据仓库 <code>initialArg</code>，并设置一个管理者 <code>reducerExample</code></li><li>通过 <code>useReducer</code> 来新建该 demo 的 <code>state</code> 和 <code>dispatch</code></li><li>给点击事件套上 <code>dispatch</code> 事件，并传递对应参数</li><li>管理者 <code>reducerExample</code> 接收到对应参数后，通过 switch 执行特定行为，比如说对 state 做出改变</li></ol><p><strong>通过 <code>dispatch</code> 去派发 <code>action</code>，比如说上图的 type，payload</strong></p><h5 id="什么时候用-useReducer，什么时候用-useState？"><a href="#什么时候用-useReducer，什么时候用-useState？" class="headerlink" title="什么时候用 useReducer，什么时候用 useState？"></a>什么时候用 useReducer，什么时候用 useState？</h5><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <strong>state 逻辑较复杂且包含多个子值</strong>，或者<strong>下一个 state 依赖于之前的 state</strong> 等。</p><h4 id="深更新的组件做性能优化"><a href="#深更新的组件做性能优化" class="headerlink" title="深更新的组件做性能优化"></a>深更新的组件做性能优化</h4><p>在 useReducer 的官方文档中存在这样一句介绍:</p><blockquote><p>使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数。</p></blockquote><p>在某些场景下我们通常会将<strong>函数作为 props</strong> 传递到 child component 中去，这样的话，每次父组件 re-render 时即使我们并没有修改当作 props 的函数，子组件也会重新渲染。例子如下：</p><p><strong>父组件</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1a8b0ebec613042b343fa4aea9df7271.png" alt="image.png"></p><p><strong>子组件</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/dda8548f28da86d8a95821e8129ae028.png" alt="image.png"></p><p><strong>演示动画</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b9a224ee1732a26b6825a200d9268403.gif" alt="useReducer.gif"></p><p>每次点击父组件的 button 时，子组件中的 effect 中被执行了。</p><p>此时其实我们传入子组件的 callback 并没有做什么改变，我们自然期望子组件中的 Effect 不会执行。</p><p><strong>产生这个原因的机制是 React 每次渲染都会重新执行组件函数，当重新执行父组件时会重新生成一个 callback 函数。因为 React 内部使用 Object.is 判断，所以 React 会认为子组件的 props 发生了变化。</strong></p><blockquote><p><strong>而在 useReduce 中返回的 dispatch 正是一个函数，但是 useReducer 的好处之一便是， dispatch 不会随着 re-render 而重新分配记忆位置，比方上述我们将 dispatch 作为 props 传入 child component 中时子组件中的 Effect 也并不会被执行。</strong></p></blockquote><p>至于解决这个子组件函数重新渲染问题，除了 dispatch 还有另一种方法，可以查看下方的 useCallback 板块</p><p><br></br></p><h3 id="6-useCallback"><a href="#6-useCallback" class="headerlink" title="6. useCallback"></a>6. useCallback</h3><p>接下来我们来聊一聊 useCallback ，它的最大作用体现在 React 中的性能优化。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const memoizedCallback = useCallback(<br>  <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; doSomething(a) &#125;, <br>  [a]);<br></code></pre></td></tr></table></figure><p>useCallback 接受两个参数:</p><ul><li>第一个参数是一个函数，这个函数仅会在对应依赖项发生变化之后才会被重新生成，或者说这个函数被产生「记忆」。</li><li>第二个参数是一个数组，它表示第一个参数所依赖的依赖项，仅在该数组中某一项发生变化时第一个参数的函数才会「清除记忆」重新生成。</li></ul><p>也许大多数接触 React 的朋友会好奇这个 Hook 的使用场景，此时让我们来回忆一下上面在 useReducer 板块的例子。</p><p>我们在父组件中传递了一个 callback 函数作为 props 传递给了子组件，每次渲染中我们并没有改变 callback 但是每次父组件 re-render ，React 仍然会认为 callback 发生变化从而造成多余的子组件 re-render 。</p><p>此时，使用 useCallback 就可以很好的解决这个例子，如下：</p><p><strong>对上面 useReducer 的父组件进行更改，包裹上 useCallback</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8bd3523f92b5e1f8c9c2e1091f2e4707.png" alt="image.png"></p><p>可以看到我们使用 useCallback 包裹了传入子组件的回调函数，同时第二个依赖项参数传递一个空数组。</p><p><strong>更改后演示动画</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f20f1b6b74d4328a616ad245caaf9a7e.gif" alt="useCallback.gif"></p><p>此时即使我们多次点击按钮，子组件的 Effect 也并不会执行了。</p><p><br></br></p><h3 id="7-useMemo"><a href="#7-useMemo" class="headerlink" title="7. useMemo"></a>7. useMemo</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useMemo( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fn, deps)<br></code></pre></td></tr></table></figure><p>useMemo 同样是作为性能优化提供的 Hook ，它相比 useCallback 来说支持<strong>任意类型的值</strong>都可以被记忆。而对于这个值，我们更常用的其实是一个个函数组件，不想某个函数组件一直渲染 （例如该函数组件涉及很多的 DOM 操作）导致花费额外的性能开销时就可以考虑使用 useMemo，例如后面示例的 <code>renderExample</code> 组件。</p><p>如果说 useCallback 是 React 团队提供给开发者作为对于 <strong>函数</strong> 的优化手段，那么 useMemo 就可以看作用于「记忆」 <strong>值</strong> 从而带来性能优化。</p><p>同样它支持两个参数:</p><ul><li>第一个参数接受传入一个函数，传入的函数调用返回值会被「记忆」。仅仅当依赖项发生变化时，传入的函数才会重新执行计算新的返回结果。</li><li>第二个参数同样也是一个数组，它表示第一个参数对应的依赖项。</li></ul><blockquote><p><code>useMemo( () =&gt; fn, deps)</code> 相当于 <code>useCallback(fn, deps)</code></p></blockquote><p>useMemo 跟 useCallback 的差别</p><ol><li><code>useMemo</code> 返回的是一个值，不仅仅限于函数</li><li><code>useMemo</code> 缓存的是一个值，<code>useCallback</code> 缓存的是一个函数</li></ol><p><strong>惯例，下面来看这个例子</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/01d027e10a062d0f28ab202c47089cb9.png" alt="image.png"></p><p>当我们每次点击 button 组件 re-render 时，renderSubject 的值都会重新计算也就是说每次都会打印出 <code>重新渲染啦！</code>。<br><img src="https://img-blog.csdnimg.cn/img_convert/37f9fd01b158a40b3dcf7b9b02f53cff.gif" alt="useMemo1.gif"></p><p>此时让我们再换成 useMemo 包裹 renderExample ,告诉 React 「记忆」 renderExample 的值再重新试一试</p><p><img src="https://img-blog.csdnimg.cn/img_convert/56146856f98fb208a6adf07b09f74d03.png" alt="image.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/206d8818fd0ec38529a0048be2e2bdbd.gif" alt="useMemo2.gif"></p><p>此时当我们点击页面上的 button 时，count 发生变化页面 re-render 时，因为我们使用 useMemo 传入的函数中返回 <code>data.map((item) =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)</code> 并且第二个参数是一个空数组。</p><p><strong>无论页面如何 re-render ，只要依赖项不发生变化那么 useMemo 中返回的值就不会重新计算。</strong></p><p>此时我们再再将依赖项由空数组，变为 count</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6de1fc6302c230e070524e3674e6206d.png" alt="image.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9aa773f61fc1334b12ea1d6b39c1c612.gif" alt="useMemo3.gif"></p><p>不出意外，随着依赖项 count 的改变，renderExample 这个值也重新渲染了</p><h4 id="关于性能优化"><a href="#关于性能优化" class="headerlink" title="关于性能优化"></a>关于性能优化</h4><p>关于 useCallback 以及 useMemo 这两个 Hook 都是 React 提供给开发者作为性能优化手段的方法。</p><p><strong>但是大多数时候，你不需要考虑去优化不必要的重新渲染</strong>。React 是非常快的，我能想到你可以利用时间去做很多事情，比起做这些类似的优化要好得多。</p><p>对于 useCallback 和 useMemo 来说，我个人认为不合理的利用这两个 Hook 不仅仅会使代码更加复杂，同时有可能会通过调用内置的 Hook 防止依赖项和 memoized 的值被垃圾回收从而导致性能变差。</p><p>如果说，有些情况下比如交互特别复杂的图表、动画之类，使用这两个 Hook 可以使你获得了必要的性能收益，那么这些成本都是值得承担的，但<strong>最好使用之前先测量一下</strong>。</p><blockquote><p><strong>官方文档指出，无需担心创建函数会导致性能问题。我们上述提供的例子仅仅是为了向大家展示它们的用法，实际场景下非常不建议这样使用。</strong></p></blockquote><p><br></br></p><h3 id="8-useRef"><a href="#8-useRef" class="headerlink" title="8. useRef"></a>8. useRef</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const refContainer <span class="hljs-operator">=</span> useRef(initialValue)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>类似于 useState，也是创建并保存一个变量</p><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。</p><p>useRef Hook 的作用主要有两个:</p><ul><li><p>获取 Dom 元素，在 Function Component 中我们可以通过 useRef 来获取对应的 Dom 元素。</p></li><li><p>多次渲染之间保证唯一值的纽带。</p></li></ul><p><strong>我们来详细讲讲第二点</strong></p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p><ul><li><p>useRef 相当于创建了一个变量并进行保存，不会因为组件重新渲染而重新初始化值（跟 useState 的不同处）</p></li><li><p>重新赋值 <code>ref.current</code> 不会触发组件重新渲染</p></li></ul><blockquote><p><strong>请记住，当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用 <a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node">回调 ref</a> 来实现。</strong></p></blockquote><p><strong>老规矩，下面来看个例子</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed3e5a55bef3977a15fcec62215ccfdd.png" alt="image.png"></p><p>在 useMemo 示例的基础上，新增了一个 useRef，对 ref.current 进行不断赋值，直到 count 的值等于5时，再 clearInterval 清除，通过 console.log() 查看变化过程</p><p><strong>演示过程</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/b4dca5a58c3f324d215307e65a520543.gif" alt="useRef.gif"></p><p>可以看到，符合预期，useRef 创建的变量，在不断对 ref.current 进行重新赋值时，组件并没有重新渲染，而是按照规则慢慢改变。</p><p><br></br></p><h3 id="9-useImperativeHandle"><a href="#9-useImperativeHandle" class="headerlink" title="9. useImperativeHandle"></a>9. useImperativeHandle</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">ImperativeHandle(<span class="hljs-params">ref</span>, <span class="hljs-params">createHandle</span>, [<span class="hljs-params">deps</span>])</span><br></code></pre></td></tr></table></figure><p>useImperativeHandle 这个 Hook 很多同学日常可能用的不是很多，但是在某些情况下它会帮助我们实现一些意向不到的效果。</p><ul><li>ref 表示需要被赋值的 ref 对象。</li><li>createHandle 函数的返回值作为 ref.current 的值。</li><li>deps 依赖数组，依赖发生变化会重新执行 createHandle 函数。</li></ul><blockquote><p><strong><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用</strong></p></blockquote><p><strong>demo</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bba1b5c5977134f79db35435cf3b3e77.png" alt="image.png"></p><p>本例中,渲染 <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 <code>inputRef.current.focus()</code></p><p><br></br></p><h3 id="10-useDebugValue"><a href="#10-useDebugValue" class="headerlink" title="10. useDebugValue"></a>10. useDebugValue</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">DebugValue(<span class="hljs-params">value</span> , <span class="hljs-params">fn</span>)</span><br></code></pre></td></tr></table></figure><p>useDebugValue  可用于在 React 开发者工具中显示自定义 hook 的标签，它接受两个参数:</p><ul><li>value 为我们要重点关注的变量，该参数表示在 DevTools 中显示的 hook 标志。</li><li>fn 表明如何格式化变量 value , 该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。</li></ul><p>例如，一个返回 <code>Date</code> 值的自定义 Hook 可以通过格式化函数来避免不必要的 <code>toDateString</code> 函数调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">DebugValue(<span class="hljs-params">date</span>, <span class="hljs-params">date</span> =&gt; <span class="hljs-params">date</span>.<span class="hljs-params">toDateString</span>()</span>);<br></code></pre></td></tr></table></figure><p>当我们自定义一些 Hook 时，可以通过 useDebugValue 配合 React DevTools 快速定位我们自己定义的 Hook。</p><p><strong>案例</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4bfc397c666c87e2adf96fc464175963.png" alt="image.png"></p><p>这段代码中我通过 useDebug 定义了一个 hello React 的标示，此时我们来查看一下 React DevTools 的 Components 板块:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1a9e0960502014bdc4078feb296ad48e.png" alt="image.png"></p><h5 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h5><ul><li><p>useDebugValue应该在自定义hook中使用，如果直接在组件内使用是无效的。</p></li><li><p>大部分情况下你不需要使用这个 Hook ，除非你在编写一些公共库的 Hook 时，显式标志该 Hook 。</p></li></ul><p><br></br></p><h3 id="11-自定义-Hook"><a href="#11-自定义-Hook" class="headerlink" title="11. 自定义 Hook"></a>11. 自定义 Hook</h3><p><strong>自定义 Hook 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 Hook。</strong>  </p><p>更浅显易懂的理解，自定义 Hook 是将我们需要的业务逻辑进行抽离整合到一起（组件抽离），类似 <strong>Vue3 的 Composition API</strong>，一个个自定义 Hook 可以理解为 **setup()**，我们只是将两个函数之间一些共同的代码提取到单独的函数中。自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</p><h5 id="如何自定义-Hook"><a href="#如何自定义-Hook" class="headerlink" title="如何自定义 Hook"></a>如何自定义 Hook</h5><ol><li>自定义一个 hook 函数</li><li>在该 Hook 函数内写你需要的业务逻辑（例如引入其他 Hook 等等）</li><li>返回值是一个数组，数组中第一个值是变量，第二个值是修改该变量的函数</li><li>将自定义 hook 函数 export（暴露）出去</li><li>在需要用到该自定义 Hook 的地方对该 Hook 进行引入</li></ol><p>例如，上面第十点里的 <code>useName</code> 和下面的 <code>useFriendStatus</code> 是都是自定义的 Hook</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b00d15751dcb29106eb6815ce424b424.png" alt="image.png"></p><p>与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它就像一个正常的函数。但是它的名字应该始终以 <code>use</code> 开头，这样可以一眼看出其符合 <a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 的规则</a>。</p><br /><blockquote><p><strong>🎁 以上便是文章的全部内容啦 <br /> 🎁 觉得有用的小伙伴们可以点个赞支持鼓励一下我<br /> 🎁 我也会在今后努力产出更多好文</strong></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程，期待你的关注~</p><p>我的个人博客最近也在加紧同步中，欢迎参观：<a href="http://blog.zhangjiancong.top/">Smooth的个人博客</a></p><p><a href="https://gitee.com/zjc13544361063/leet-code">leetCode</a> 这是我建的力扣刷题仓库，会逐渐推出阿里云天池计划、HOT100、剑指offer等等系列，可以给个 <strong>star</strong> 支持一下，久更不易</p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5082841488024cdce02f8bc89a301b16.bmp"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们的项目源码开放啦！</title>
    <link href="/2022/02/17/%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%BC%80%E6%94%BE%E5%95%A6%EF%BC%81/"/>
    <url>/2022/02/17/%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%BC%80%E6%94%BE%E5%95%A6%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名高级前端开发工程师</strong></p></blockquote><p><strong>字节第二届寒假青训营也算正式落幕啦，在这其中收获良多。</strong></p><h1 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h1><p>44支队伍经过初审 + 终审，最终获得了第五名，成绩还算不错hh，也获得了评委老师一定的评价。<br><img src="https://gitee.com/zjc13544361063/zjc-markdown-picture/raw/master/image-20220218121056458.png" alt="image-20220218121056458"></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><strong>20天，112次 commit</strong><br><img src="https://gitee.com/zjc13544361063/zjc-markdown-picture/raw/master/image-20220218121029575.png" alt="image-20220218121029575"></p><p><strong>项目做到一半突然想着下一个TIME MASTER记录一下哈哈，可惜之前那一半代码量记录不进来咯</strong><br><img src="https://gitee.com/zjc13544361063/zjc-markdown-picture/raw/master/image-20220218121014907.png" alt="image-20220218121014907"></p><p>同时呢，结识到了很多厉害的人，眼界开阔了很多，也激起了自己更加努力的热情</p><h5 id="下面就对我们的项目做个简单的介绍吧"><a href="#下面就对我们的项目做个简单的介绍吧" class="headerlink" title="下面就对我们的项目做个简单的介绍吧"></a>下面就对我们的项目做个简单的介绍吧</h5><p><br></br></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>本项目名为摸鱼学社，是一个基于 React + Egg 的类掘金的社区网站，主要面向程序员这一群体，故我们保留了与掘金的大部分功能，并在此基础之上增加了唠嗑圈、力扣专区，满足程序员在摸鱼的同时不忘学习，我们在后期也会根据程序员这一群体的特殊性增加一些开发工具、自定义网站等功能。</p><p><strong>目标：致力于打造一个信息覆盖面广、体验良好、找到家一般的功能社区网站</strong><br><br></br></p><h2 id="项目灵感"><a href="#项目灵感" class="headerlink" title="项目灵感"></a>项目灵感</h2><p>作为掘金忠实用户，在平日浏览掘金社区时可能会因为一直看着蓝色而神经感到疲倦，所以有了想法可不可以不仅限于蓝色，然后再定制一个自己舒服的字体大小便于慢慢浏览，即用户可以自定义来丰富自己的体验</p><p><strong>对标产品：微博、Twitter、掘金社区、鱼塘热榜、清华摸鱼导学论</strong><br><br></br></p><h2 id="项目分工"><a href="#项目分工" class="headerlink" title="项目分工"></a>项目分工</h2><ul><li><p>黄馨莹：后端项目整体架构+Egg后端部署+MySql数据库设计+API接口文档设计</p></li><li><p>张健聪：前端项目整体架构 + 前端部署 + 开发首页、力扣专区、唠嗑圈、个人主页、个人设置、注册登录、文章撰写、文章详情、话题详情，年度报告页面，并进行用户体验优化、性能优化</p></li><li><p>刘轶贝：原型图、标签管理、草稿箱、回到顶部组件</p></li><li><p>曹泽：文章撰写页 的需求调研</p></li><li><p>于童：文章详情页-热点文章模块<br><br></br></p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3></li><li><p>主框架：React(全面拥抱 Hook )、React-Router v6</p></li><li><p>脚手架：create-react-app</p></li><li><p>CSS解决方案：styled-components</p></li><li><p>UI框架：Ant Design</p></li><li><p>登录鉴权：JWT</p></li><li><p>动画库：animate.css、react-transition-group、particles-bg</p></li><li><p>网络请求：axios</p></li><li><p>异步解决方案：promise、async&#x2F;await</p></li><li><p>协作工具：Git</p></li><li><p>打包工具：Webpack</p></li><li><p>包管理工具：yarn</p></li><li><p>规范：eslint-plugin-react-hooks </p></li><li><p>函数工具库：echarts、moment、lodash、mo.js、vditor<br><br></br></p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3></li></ul><ul><li>主框架：Egg</li><li>数据库：MySql</li><li>插件：egg-mysql  egg-validate  egg-jwt  egg-cors</li><li>API设计风格：RESTful API<br><br></br><h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h3></li></ul><ol><li>根据程序员这一群体的特殊性，我们集合了社区、力扣、markdown拓展、自定义工具库等等功能</li><li>定制化个人设置，让每个用户都有一个不一样的体验（例如主题色、文章字体大小）</li><li>提供年度报告等统计数据，采用echarts进行可视化函数，直观展示出数据</li><li>提供单次阅读时长提醒，让您在浏览社区的同时同时注意休息</li><li>提供文章稍后再看的缓存功能，让您可以记录下自己想看的文章</li><li>页面中增加动画过渡，更符合视觉感受<br><br></br></li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>使用React官方的Suspense及lazy组件实现路由懒加载及组件按需加载，减少首屏加载时间</li><li>使用魔法注释webpackChunkName减少打包时包体积</li><li>利用缓存，不重复加载相同资源且加快资源访问速度，提升用户体验(配置 runtimeChunk 和 利用浏览器缓存)</li><li>通过webpack本地对js和css文件做gzip压缩，减轻服务器压力</li><li>使用分页和图片懒加载减少页面同时加载多个DOM节点的压力</li><li>防抖和节流，限制了短时间内页面滚动次数和图标点击次数，减少前端多次请求js和后端多次请求数据的压力<br><br></br><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><h4 id="空白时使用加载中图标、骨架屏作视觉上的过渡"><a href="#空白时使用加载中图标、骨架屏作视觉上的过渡" class="headerlink" title="空白时使用加载中图标、骨架屏作视觉上的过渡"></a>空白时使用加载中图标、骨架屏作视觉上的过渡</h4><h4 id="页头、文章详情页实现视差滚动"><a href="#页头、文章详情页实现视差滚动" class="headerlink" title="页头、文章详情页实现视差滚动"></a>页头、文章详情页实现视差滚动</h4><h4 id="右下角提供返回顶部组件"><a href="#右下角提供返回顶部组件" class="headerlink" title="右下角提供返回顶部组件"></a>右下角提供返回顶部组件</h4><h4 id="设置隐藏彩蛋，文章详情处点赞可触发"><a href="#设置隐藏彩蛋，文章详情处点赞可触发" class="headerlink" title="设置隐藏彩蛋，文章详情处点赞可触发"></a>设置隐藏彩蛋，文章详情处点赞可触发</h4><br></br><blockquote><p><strong>具体信息可以查看开发文档链接</strong><br>内有前后端源码，以及api文档</p></blockquote></li></ol><p><strong>摸鱼学社开发文档</strong><br><a href="https://lhcgmmdf97.feishu.cn/docs/doccnYqYVMI4JMLmANnXKGCwdKe#">https://lhcgmmdf97.feishu.cn/docs/doccnYqYVMI4JMLmANnXKGCwdKe#</a></p><p><strong>项目预览地址</strong><br>loaf.zhangjiancong.top</p><br /><blockquote><p><strong>🎁 以上便是文章的全部内容啦 <br /> 🎁 觉得有用的小伙伴们可以点个赞支持鼓励一下我<br /> 🎁 我也会在今后努力产出更多好文</strong></p></blockquote><br /><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程，期待你的关注~</p><p>我的个人博客最近也在加紧同步中，欢迎参观：<a href="http://blog.zhangjiancong.top/">Smooth的个人博客</a></p><p><a href="https://gitee.com/zjc13544361063/leet-code">leetCode</a> 这是我建的力扣刷题仓库，会逐渐推出阿里云天池计划、HOT100、剑指offer等等系列，可以给个 <strong>star</strong> 支持一下，久更不易</p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟让你彻底理解如何配置子域名来部署多个项目</title>
    <link href="/2022/02/16/10%E5%88%86%E9%92%9F%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9D%A5%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/02/16/10%E5%88%86%E9%92%9F%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9D%A5%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名前端开发工程师</strong></p></blockquote><p><strong>配置子域名让你一台服务器可以同时部署多个项目</strong></p><p>本篇文章将详细为你讲解如何配置子域名让你一台服务器可以同时部署多个项目，新手都能看懂的教程哈哈</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有如下需求：</p><p>我有一个域名 zhangjiancong.top，我想在上面搭几个web应用，分别是 </p><ul><li>个人博客：myblog.zhangjiancong.top</li><li>娱乐项目：xxx.zhangjiancong.top</li></ul><p>一种办法就是在nginx的document myblog、xxx目录，访问方式就是<strong>zhangjiancong.top&#x2F;myblog</strong></p><p><strong>zhangjiancong.top&#x2F;xxx</strong></p><p>但这样有几个缺点</p><ol><li>某些web应用可能本身就不支持非根目录的方式访问，导致不可用</li><li>因为各个应用可能需要进行location的特殊配置，而这些应用不在根路径的时候，location配置可能有所不同，更加复杂</li><li>不够酷，太丑了</li></ol><p>需要让 myblog、xxx 都拥有自己的子域名（myblog.zhangjiancong.top、xxx.zhangjiancong.top），可以这么做：</p><ol><li>在域名服务商那里，加一个CNAME记录，把需要配置的子域名指向根域对应的主机名即可。</li><li>然后在宝塔界面修改 Nginx 配置</li><li>添加新站点<br>具体如下：</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-添加-CNAME-记录"><a href="#1-添加-CNAME-记录" class="headerlink" title="1. 添加 CNAME 记录"></a>1. 添加 CNAME 记录</h3><p>我是阿里云，所以就用阿里云做示例，无论是啥服务商，打开域名解析界面即可</p><p><strong>进入到域名解析界面</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134b207c5d8c4d44950941b88ba9e916~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>点击添加记录</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd8fa4c898c4392b2dbbb4083cb118c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h5><p><strong>CNAME记录</strong></p><p>什么情况下会用到CNAME记录？</p><p>［如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录］<br>最常用到CNAME的情况包括：做CDN，配置子域名</p><p><strong>CNAME记录的添加说明</strong></p><p>解析线路一栏记得改成 默认，中国联通只是后文举例说明该配置项作用<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9156780b28ed4d6090e11b13817098b5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><p>记录类型：选择 <code>CNAME</code></p></li><li><p>主机记录：填子域名（比如需要添加 myblog.zhangjiancong.top的解析，只需要在主机记录处填写 myblog 即可；如果添加 zhangjiancong.top的解析 的解析，主机记录直接留空，系统会自动填一个“@”到输入框内）。</p></li><li><p>解析线路：默认即可（如果不选默认会导致部分特定用户无法解析；在上图中的作用为：除了联通用户之外的所有用户都可正常解析）</p></li><li><p>记录值：CNAME 指向的域名，只可以填写域名，记录生成后会自动在域名后面补一个“.”，这是正常现象</p></li><li><p>TTL：添加时系统会自动生成，默认为600秒（TTL为缓存时间，数值越小，修改记录各地生效时间越快）。</p></li></ul><p><strong>点击确认即可</strong><br><br></br></p><h3 id="2-修改-Nginx-配置文件"><a href="#2-修改-Nginx-配置文件" class="headerlink" title="2. 修改 Nginx 配置文件"></a>2. 修改 Nginx 配置文件</h3><p><strong>找到宝塔界面该项</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b7c6538e744e61a96294e055a0cd29~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>找到配置入口</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba0f32f20e8c430f8b96207d134131ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>对配置文件的 server 字段进行如上图的修改</strong></p><ul><li>由于我主域名放的是我另一个资源 loaf-community，所以我 <code>$doc</code> 初始值为 <code>&quot;loaf-community&quot;</code>，否则为 <code>&quot;&quot;</code> 即可</li><li>if 为匹配规则，root 为服务器对应路径资源，我资源都放在 <code>/www/wwwroot/</code> 的目录下，大家根据自己服务器真实路径进行配置即可<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 设置子域名目录</span><br><span class="hljs-attribute">set</span> <span class="hljs-variable">$doc</span> <span class="hljs-string">&quot;loaf-community&quot;</span>;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> <span class="hljs-regexp">~ ^(\w+)\.zhangjiancong\.top)</span> &#123;<br>    <span class="hljs-attribute">set</span> <span class="hljs-variable">$doc</span> <span class="hljs-variable">$1</span>;<br>&#125;<br><br><span class="hljs-comment"># 设置此时域名对应的root</span><br><span class="hljs-attribute">root</span> /www/wwwroot/<span class="hljs-variable">$doc</span>;<br></code></pre></td></tr></table></figure></li></ul><p>这样做的好处就是，之后要加个子域名，只要我在 <code>/www/wwwroot</code> 目录中新建一个子目录放新增的项目，取子域名作为目录名，然后在域名服务商新增一条字域名的CNAME记录就搞定了，非常方便。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c30b109d9b846aaa4729037474655f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br></p><h3 id="3-添加新站点"><a href="#3-添加新站点" class="headerlink" title="3. 添加新站点"></a>3. 添加新站点</h3><p><strong>找到入口</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19c647f0a574caf821017071f0ef03d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>配置子域名及其对应项目资源路径</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1010db29cc0460a811de4baa6b17e70~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>配置完重启服务器即可</strong></p><blockquote><p><strong>配置过第二步后，之后每次添加新子域名和项目，只用进行第一和第三步即可</strong></p></blockquote><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文理解配置伪静态解决 部署项目刷新页面404问题</title>
    <link href="/2022/02/15/%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3%E9%85%8D%E7%BD%AE%E4%BC%AA%E9%9D%99%E6%80%81%E8%A7%A3%E5%86%B3%20%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2404%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/15/%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3%E9%85%8D%E7%BD%AE%E4%BC%AA%E9%9D%99%E6%80%81%E8%A7%A3%E5%86%B3%20%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2404%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名前端开发工程师</strong></p></blockquote><p><strong>配置伪静态解决部署项目后页面刷新404问题</strong></p><p>网上看了很多如何解决 <code>项目部署后刷新页面报404</code> 的文章，解决的方式无非只有两个：</p><ol><li>将 historyRouter 变为 hashRouter （治标不治本）</li><li>配置无论任何路径，都返回index.html，剩下的事情交给 React Router</li></ol><p>但第二种不知为何我一直不奏效，直到使用了 <code>配置伪静态</code> 这种方法，所以本篇文章我想向很多跟我遇到同样问题的小伙伴分享一下我的解决方法</p><h2 id="普及基本概念-Q-amp-A"><a href="#普及基本概念-Q-amp-A" class="headerlink" title="普及基本概念 Q&amp;A"></a>普及基本概念 Q&amp;A</h2><h3 id="为什么会404-？"><a href="#为什么会404-？" class="headerlink" title="为什么会404 ？"></a>为什么会404 ？</h3><p>原因很简单：当你刷新时，你首先是根据url访问的服务器资源地址，然后返回的页面内加载了对应资源，最后在浏览器进行渲染；也就是说如果这个时候报404，是因为你后台并没有针对这个路由给出返回HTML内容，也谈不上执行React Router了。</p><p><strong>简单来说就是，没在服务器对应url路径匹配到你需要的资源</strong><br><br></br></p><h3 id="为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？"><a href="#为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？" class="headerlink" title="为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？"></a>为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？</h3><p>你在浏览器内可以由首页跳转到其他路由地址，是因为这是由前端自行渲染的，你在React Router定义了对应的路由，脚本并没有刷新网页访问后台，是JS动态更改了location。<br><br></br></p><h3 id="为什么-hashRouter-可以，historyRouter-不行？"><a href="#为什么-hashRouter-可以，historyRouter-不行？" class="headerlink" title="为什么 hashRouter 可以，historyRouter 不行？"></a>为什么 hashRouter 可以，historyRouter 不行？</h3><p><code>React</code>是属于单页应用（single-page application）</p><p>而<code>SPA</code>是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个<code>index.html</code>。当我们在地址栏输入 <a href="http://www.xxx.com/">www.xxx.com</a> 时，这时会打开我们 <code>nginx</code> 配置的目录下的 index.html 文件，然后我们在跳转路由进入到 <a href="http://www.xxx.com/login">www.xxx.com/login</a></p><p>关键在这里，当我们在 <a href="http://www.xxx.com/login">www.xxx.com/login</a> 页执行刷新操作，nginx location 是没有根据这路径做相关的资源返回配置的，所以就会出现 404 的情况</p><p><strong>hashRouter</strong></p><p>router hash 模式我们都知道是用符号#表示的，如  <a href="http://www.xxx.com/#/login">www.xxx.com/#/login</a>, hash 的值为 #&#x2F;login。</p><p>它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面</p><p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com/#/login">www.xxx.com/#/login</a> 只有 <a href="http://www.xxx.com/">www.xxx.com</a> 会被包含在请求中 ，因此对于服务端来说，即使没有配置location，也不会返回404错误</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>好，说了那么多，现在就阐述解决方案<br><strong>以下示例为宝塔面板</strong></p><h3 id="配置伪静态资源"><a href="#配置伪静态资源" class="headerlink" title="配置伪静态资源"></a>配置伪静态资源</h3><p><strong>第一步</strong>找到配置项入口</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ff6ba724b4c46d5a971b5932a929d00~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db83bb6f5cdb4a659974bd6a9ebf4ff7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><br></br><br><strong>第二步</strong> 进行伪静态配置</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5815f3a5d4d0432e8219b600ff79e8cd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ <span class="hljs-variable">@router</span>;<br>    <span class="hljs-attribute">index</span>  index.html;<br>&#125;<br><br><span class="hljs-section">location</span> <span class="hljs-variable">@router</span>&#123;<br>      <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^.*$</span> /index.html <span class="hljs-literal">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br><br><strong>第三步</strong> 重启服务器即可<br><br></br></p><h3 id="其他解决"><a href="#其他解决" class="headerlink" title="其他解决"></a>其他解决</h3><p>可以使用文头所说的方法</p><ol><li>将 historyRouter 变为 hashRouter （治标不治本）</li><li>配置无论任何路径，都返回index.html，剩下的事情交给React Router</li></ol><p>只不过我对于第二种方法一直配置不生效</p><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带你3分钟掌握常见的水平垂直居中面试题</title>
    <link href="/2022/02/14/%E5%B8%A6%E4%BD%A03%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/02/14/%E5%B8%A6%E4%BD%A03%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名前端开发工程师</strong></p></blockquote><h4 id="这是一篇关于css-居中知识的总结，只要这些都了解了，居中这方面面试就没问题了"><a href="#这是一篇关于css-居中知识的总结，只要这些都了解了，居中这方面面试就没问题了" class="headerlink" title="这是一篇关于css 居中知识的总结，只要这些都了解了，居中这方面面试就没问题了"></a>这是一篇关于<code>css</code> 居中知识的总结，只要这些都了解了，居中这方面面试就没问题了</h4><p>只要涉及到CSS就绕不开定位问题，尤其是盒子居中。居中又分为水平居中和垂直居中，有多种实现方式，下面我便一一列出来。</p><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h5 id="1-inline元素：text-align-center"><a href="#1-inline元素：text-align-center" class="headerlink" title="1.  inline元素：text-align: center"></a>1.  inline元素：text-align: center</h5><h5 id="2-block元素：margin-0-auto"><a href="#2-block元素：margin-0-auto" class="headerlink" title="2.  block元素：margin: 0 auto"></a>2.  block元素：margin: 0 auto</h5><h5 id="3-absolute元素：left-50-margin-left负值-值为该元素宽度的一半"><a href="#3-absolute元素：left-50-margin-left负值-值为该元素宽度的一半" class="headerlink" title="3.  absolute元素：left: 50% + margin-left负值(值为该元素宽度的一半)"></a>3.  absolute元素：left: 50% + margin-left负值(值为该元素宽度的一半)</h5><h5 id="4-absolute元素：left-50-transform-translateX（-50"><a href="#4-absolute元素：left-50-transform-translateX（-50" class="headerlink" title="4.  absolute元素：left: 50% + transform: translateX（-50%)"></a>4.  absolute元素：left: 50% + transform: translateX（-50%)</h5><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h5 id="1-inline元素：line-height的值等于height值"><a href="#1-inline元素：line-height的值等于height值" class="headerlink" title="1.  inline元素：line-height的值等于height值"></a>1.  inline元素：line-height的值等于height值</h5><h5 id="2-absolute元素：top：50-margin-top负值-值为该元素高度的一半"><a href="#2-absolute元素：top：50-margin-top负值-值为该元素高度的一半" class="headerlink" title="2.  absolute元素：top：50%+margin-top负值(值为该元素高度的一半)"></a>2.  absolute元素：top：50%+margin-top负值(值为该元素高度的一半)</h5><h5 id="3-absolute元素：top：50-transform-translateY（-50"><a href="#3-absolute元素：top：50-transform-translateY（-50" class="headerlink" title="3.  absolute元素：top：50%+transform: translateY（-50%)"></a>3.  absolute元素：top：50%+transform: translateY（-50%)</h5><h5 id="4-absolute元素：有固定宽高度-top，left，bottom，right-x3D-0-margin-auto"><a href="#4-absolute元素：有固定宽高度-top，left，bottom，right-x3D-0-margin-auto" class="headerlink" title="4.  absolute元素：有固定宽高度+top，left，bottom，right&#x3D;0  +  margin:auto"></a>4.  absolute元素：有固定宽高度+top，left，bottom，right&#x3D;0  <strong>+</strong>  margin:auto</h5><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>就是上述的水平居中+垂直居中合起来<br>这里我举几个常用的例子：</p><h3 id="1-放在定位是relative盒子内的absolute盒子："><a href="#1-放在定位是relative盒子内的absolute盒子：" class="headerlink" title="1. 放在定位是relative盒子内的absolute盒子："></a>1. 放在定位是relative盒子内的absolute盒子：</h3><h4 id="top-50-left-50-transform-translate-50-50"><a href="#top-50-left-50-transform-translate-50-50" class="headerlink" title="top: 50%;left: 50%;transform: translate(-50%,-50%);"></a><code>top: 50%;left: 50%;transform: translate(-50%,-50%);</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e70cab9a6a74837bf5fb60488a5ee13~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ace512ca45f4c2fa7d6f6dc9d519c1a~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="2-知道盒子的宽度和高度"><a href="#2-知道盒子的宽度和高度" class="headerlink" title="2. 知道盒子的宽度和高度"></a>2. 知道盒子的宽度和高度</h3><h4 id="top-50-left-50"><a href="#top-50-left-50" class="headerlink" title="top: 50%;left: 50%;"></a><code>top: 50%;left: 50%;</code></h4><h4 id="加上-margin-left-负值-值为该元素宽度的一半-margin-top负值-值为该元素高度的一半"><a href="#加上-margin-left-负值-值为该元素宽度的一半-margin-top负值-值为该元素高度的一半" class="headerlink" title="加上 margin-left 负值(值为该元素宽度的一半);margin-top负值(值为该元素高度的一半)"></a><code>加上 margin-left 负值(值为该元素宽度的一半);margin-top负值(值为该元素高度的一半)</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24637a30c2e4d3a9a8b8e1dd8ed0253~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/799ae7a0a74841a8b44d15087af1d0b2~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="3-放在定位是relative盒子内的absolute盒子且该盒子有固定宽高："><a href="#3-放在定位是relative盒子内的absolute盒子且该盒子有固定宽高：" class="headerlink" title="3. 放在定位是relative盒子内的absolute盒子且该盒子有固定宽高："></a>3. 放在定位是relative盒子内的absolute盒子且该盒子有固定宽高：</h3><h4 id="top，left，bottom，right-0-margin-auto"><a href="#top，left，bottom，right-0-margin-auto" class="headerlink" title="top，left，bottom，right=0 + margin:auto"></a><code>top，left，bottom，right=0 + margin:auto</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3414379e55104acdae89ca46ee9c90e0~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd9ff4f33ae4a32a3a7aadaa3770e11~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="4-CSS3弹性布局（flex）"><a href="#4-CSS3弹性布局（flex）" class="headerlink" title="4. CSS3弹性布局（flex）"></a>4. CSS3弹性布局（flex）</h3><p>如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素设置成以下属性即可</p><h4 id="display-flex-x2F-x2F-flex布局"><a href="#display-flex-x2F-x2F-flex布局" class="headerlink" title="display:flex &#x2F;&#x2F; flex布局"></a>display:flex &#x2F;&#x2F; flex布局</h4><h4 id="align-items-center；-x2F-x2F-元素水平居中"><a href="#align-items-center；-x2F-x2F-元素水平居中" class="headerlink" title="align-items:center；&#x2F;&#x2F; 元素水平居中"></a>align-items:center；&#x2F;&#x2F; 元素水平居中</h4><h4 id="justify-content-center；-x2F-x2F-元素垂直居中"><a href="#justify-content-center；-x2F-x2F-元素垂直居中" class="headerlink" title="justify-content:center；&#x2F;&#x2F; 元素垂直居中"></a>justify-content:center；&#x2F;&#x2F; 元素垂直居中</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87848c375b948ceb9380571733c19a2~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c25f1c8d3b248fa8aca1d147d0c6f23~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水平居中</tag>
      
      <tag>垂直居中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React实战：使用Antd+EMOJIALL 实现emoji表情符号的输入</title>
    <link href="/2022/02/13/React%E5%AE%9E%E6%88%98/"/>
    <url>/2022/02/13/React%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名高级前端开发工程师</strong></p></blockquote><p>本文是我在进行一个React项目的开发时，发表内容方面有输入表情符号的拓展需求，通过一段时间的查找及实践后，完成了此需求，同时也借此机会向大家分享我的思路。</p><h2 id="一、确定需求"><a href="#一、确定需求" class="headerlink" title="一、确定需求"></a>一、确定需求</h2><h3 id="首先我们要明确我们实现的大概思路是什么"><a href="#首先我们要明确我们实现的大概思路是什么" class="headerlink" title="首先我们要明确我们实现的大概思路是什么"></a>首先我们要明确我们实现的大概思路是什么</h3><p>在点击输入框下方的<code>表情</code>键后弹出选择表情的弹窗，选择表情后关闭弹窗，选择的表情自动追加到文本域的最后一位。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b23eee3664499a9150715b3f536333~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="二、书写样式"><a href="#二、书写样式" class="headerlink" title="二、书写样式"></a>二、书写样式</h2><h4 id="1-使用antd的Textarea、Space、Button组件以及-ant-design-icons实现样式"><a href="#1-使用antd的Textarea、Space、Button组件以及-ant-design-icons实现样式" class="headerlink" title="1. 使用antd的Textarea、Space、Button组件以及@ant-design/icons实现样式"></a>1. 使用antd的<code>Textarea</code>、<code>Space</code>、<code>Button</code>组件以及<code>@ant-design/icons</code>实现样式</h4><h5 id="Textarea：规定文本输入框的值、输入触发的回调函数等等。"><a href="#Textarea：规定文本输入框的值、输入触发的回调函数等等。" class="headerlink" title="Textarea：规定文本输入框的值、输入触发的回调函数等等。"></a><code>Textarea</code>：规定文本输入框的值、输入触发的回调函数等等。</h5><h5 id="Space：美化行内间距。"><a href="#Space：美化行内间距。" class="headerlink" title="Space：美化行内间距。"></a><code>Space</code>：美化行内间距。</h5><h5 id="Button：定义发送的按钮。"><a href="#Button：定义发送的按钮。" class="headerlink" title="Button：定义发送的按钮。"></a><code>Button</code>：定义发送的按钮。</h5><h5 id="（1）先从antd导入需要的组件和图标"><a href="#（1）先从antd导入需要的组件和图标" class="headerlink" title="（1）先从antd导入需要的组件和图标"></a>（1）先从antd导入需要的组件和图标</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592bc562a1d7448692be8482a22fced1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="（2）对组件进行排版"><a href="#（2）对组件进行排版" class="headerlink" title="（2）对组件进行排版"></a>（2）对组件进行排版</h5><ol><li>给<code>表情</code>添加<code>showModal</code>事件来打开弹窗</li><li>给文本域添加<code>onChange</code>事件，每次键盘输入文字或选择表情进行输入都可以监听到</li><li>给<code>Button</code>发送按钮添加<code>sendMessage</code>事件<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1365ee6d16aa46b7b26ccd89aad37c91~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><h5 id="其中-smileHover-类定义为鼠标放上去字体变蓝即可实现上图的效果"><a href="#其中-smileHover-类定义为鼠标放上去字体变蓝即可实现上图的效果" class="headerlink" title="其中 smileHover 类定义为鼠标放上去字体变蓝即可实现上图的效果"></a>其中 smileHover 类定义为鼠标放上去字体变蓝即可实现上图的效果</h5></li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f576d17e184e41d08d7d87e705450224~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="三、核心代码"><a href="#三、核心代码" class="headerlink" title="三、核心代码"></a>三、核心代码</h2><h4 id="1-从antd导入Modal组件并在其内部的Row组件动态渲染Col组件"><a href="#1-从antd导入Modal组件并在其内部的Row组件动态渲染Col组件" class="headerlink" title="1. 从antd导入Modal组件并在其内部的Row组件动态渲染Col组件"></a>1. 从antd导入<code>Modal</code>组件并在其内部的<code>Row</code>组件动态渲染<code>Col</code>组件</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd44f2a2ff25496c9e19b3cdb478cfe5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="其中-lt-Row-gt-组件动态渲染，数组为emojiList，渲染一列列-lt-Col-gt-组件"><a href="#其中-lt-Row-gt-组件动态渲染，数组为emojiList，渲染一列列-lt-Col-gt-组件" class="headerlink" title="其中&lt;Row&gt;组件动态渲染，数组为emojiList，渲染一列列&lt;Col&gt;组件"></a>其中<code>&lt;Row&gt;</code>组件动态渲染，数组为<code>emojiList</code>，渲染一列列<code>&lt;Col&gt;</code>组件</h5><h5 id="emojiList数组自定义，想放哪些表情就放哪些进去"><a href="#emojiList数组自定义，想放哪些表情就放哪些进去" class="headerlink" title="emojiList数组自定义，想放哪些表情就放哪些进去"></a><code>emojiList</code>数组自定义，想放哪些表情就放哪些进去</h5><h5 id="表情可通过下面EMOJIALL网址进行查找，复制黏贴即可"><a href="#表情可通过下面EMOJIALL网址进行查找，复制黏贴即可" class="headerlink" title="表情可通过下面EMOJIALL网址进行查找，复制黏贴即可"></a>表情可通过下面EMOJIALL网址进行查找，复制黏贴即可</h5><p><a href="https://www.emojiall.com/zh-hans/all-emojis">全部Emoji | EmojiAll</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7f4f6c11214137aad556a1b832c4bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="2-进行核心代码的编写"><a href="#2-进行核心代码的编写" class="headerlink" title="2. 进行核心代码的编写"></a>2. 进行核心代码的编写</h4><p>思路：</p><h5 id="1-点击表情触发showModal事件打开弹窗。"><a href="#1-点击表情触发showModal事件打开弹窗。" class="headerlink" title="1. 点击表情触发showModal事件打开弹窗。"></a>1. 点击<code>表情</code>触发<code>showModal</code>事件打开弹窗。</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08be9c3fe09f4519a58d2667a8805f9e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="2-点击你要选择的表情后触发handleOk事件，关闭弹窗并将表情添加到文本域内。"><a href="#2-点击你要选择的表情后触发handleOk事件，关闭弹窗并将表情添加到文本域内。" class="headerlink" title="2. 点击你要选择的表情后触发handleOk事件，关闭弹窗并将表情添加到文本域内。"></a>2. 点击你要选择的表情后触发<code>handleOk</code>事件，关闭弹窗并将表情添加到文本域内。</h5><h5 id="3-由于在Col组件渲染时给每个表情都添加了handleOk的点击事件并传入对应的表情。"><a href="#3-由于在Col组件渲染时给每个表情都添加了handleOk的点击事件并传入对应的表情。" class="headerlink" title="3. 由于在Col组件渲染时给每个表情都添加了handleOk的点击事件并传入对应的表情。"></a>3. 由于在<code>Col</code>组件渲染时给每个表情都添加了<code>handleOk</code>的点击事件并传入对应的表情。</h5><h5 id="4-点击Button发送按钮触发sendMessage事件即可"><a href="#4-点击Button发送按钮触发sendMessage事件即可" class="headerlink" title="4. 点击Button发送按钮触发sendMessage事件即可"></a>4. 点击<code>Button</code>发送按钮触发<code>sendMessage</code>事件即可</h5><h4 id="关于Modal组件及实现的关键代码，已进行了注释说明"><a href="#关于Modal组件及实现的关键代码，已进行了注释说明" class="headerlink" title="关于Modal组件及实现的关键代码，已进行了注释说明"></a>关于<code>Modal</code>组件及实现的关键代码，已进行了注释说明</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9ae84908ec4bc08ce2fc7215e33053~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React实战</tag>
      
      <tag>Antd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群(建议收藏)</title>
    <link href="/2022/02/12/%E9%95%BF%E8%BE%BE%E4%B8%87%E5%AD%97%E7%9A%84git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/12/%E9%95%BF%E8%BE%BE%E4%B8%87%E5%AD%97%E7%9A%84git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标成为一名高级前端开发工程师</strong></p></blockquote><p><strong>本篇文章将对git在工作和学习中需要用到的大部分常用指令作详细解答</strong></p><p>本文总结自廖雪峰老师的文档<br/><br/><br/></p><p><a href="#1">1.git的初步认识</a></p><p><a href="#2">2.git add与git commit</a></p><p><a href="#3">3.git status和git diff</a></p><p><a href="#4">4.版本回退git reset与查看日志git log&#x2F;git relog</a></p><p><a href="#5">5.撤销修改git checkout及git reset(再提及)</a></p><p><a href="#6">6.删除文件</a></p><p><a href="#7">7.分支管理 branch与switch</a></p><p><a href="#8">8.标签的使用 git tag与git show</a></p><ul><li><a href="#11">创建标签</a></li><li><a href="#12">查看标签</a></li><li><a href="#13">删除标签</a></li><li><a href="#14">推送标签到远程库</a></li></ul><p><a href="#9">9.远程仓库的连接</a></p><ul><li><a href="#15">与远程库建立连接</a></li><li><a href="#16">向远程库输出本地库中的文件</a></li><li><a href="#17">删除远程库</a></li></ul><p><a href="#10">10.与Github或Gitee建立文件传输机制</a><br><br></br><br><br></br></p><h1 id="1-git的初步认识"><a href="#1-git的初步认识" class="headerlink" title="1.git的初步认识"></a><div id="1">1.git的初步认识</div></h1><p>首先，Git在本地中具有工作区、暂存区与本地仓库区<br>平时我们修改代码时叫做<strong>工作区</strong>，当你完成项目到某个进度想保存时，那么便可将代码存到<strong>暂存区</strong>，暂存区类似于word文件中的自动保存功能，当你确认暂存区中的代码没问题要保存时，便可将代码由<strong>暂存区</strong>转到<strong>本地仓库区</strong>。</p><p>那么对于一个目录，如何将它变成Git可以管理的仓库呢？(本地仓库，还不是远程仓库)<br>答案是：在当前目录下运行<code>git init</code>指令创建一个版本库，然后这个目录里面的所有文件就可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了，如果你没有看到.git目录，那是因为这个目录默认是隐藏的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/800f0baaf4684330b96abd5d325f6133~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h1 id="2-git-add与git-commit"><a href="#2-git-add与git-commit" class="headerlink" title="2.git add与git commit"></a><div id="2">2.git add与git commit</div></h1><p>由于Github使用面更广，后续演示都是针对Github来展开</p><p>总体来说，把一个文件放到本地Git仓库只需要两步。</p><ul><li><p>第一步，用命令<code>git add</code>告诉Git，把某个文件从工作区添加到暂存区。</p></li><li><p><code>git add &lt;file&gt;</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ git <span class="hljs-keyword">add</span> readme.txt<span class="hljs-comment">//将readme.txt文件添加到暂存区</span><br></code></pre></td></tr></table></figure><p>执行上面的命令，如果没有任何显示，代表正确运行。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a3e424388784d748551d0fb09b86588~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p></li><li><p>第二步，用命令<code>git commit</code>告诉Git，将暂存区中所有文件一次性从暂存区添加到本地仓库区。</p></li><li><p><code>git commit -m &lt;message&gt;</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><span class="hljs-regexp">//</span>将readme.txt文件添加到本地仓库<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2759aacb994ccdab5573ed8dbb0b64~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p></li></ul><p>:boom:<strong>详解</strong>:boom:<br>.<br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git add file1.txt<br><span class="hljs-symbol">$</span> git add file2.txt file3.txt<span class="hljs-comment">//一次add命令可以有多个文件，用空格分隔</span><br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br></code></pre></td></tr></table></figure><p><br></br></p><h1 id="3-git-status和git-diff"><a href="#3-git-status和git-diff" class="headerlink" title="3.git status和git diff"></a><div id="3">3.git status和git diff</div></h1><p><code>git status</code>命令能查看当前目录中所有文件的代码状态，如果文件是<strong>红色</strong>那说明文件被修改过但还没将此次修改提交。<br><code>git diff</code>命令顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，<code>git diff</code>后面<strong>跟文件名称</strong>是是查看工作区（working tree）与暂存区（index）的差别的</p><p><br></br></p><h1 id="4-版本回退git-reset与查看日志git-log-x2F-git-relog"><a href="#4-版本回退git-reset与查看日志git-log-x2F-git-relog" class="headerlink" title="4.版本回退git reset与查看日志git log&#x2F;git relog"></a><div id="4">4.版本回退git reset与查看日志git log&#x2F;git relog</div></h1><p>你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择<strong>读取前一关的状态</strong>。有些时候，在打Boss之前，你会<strong>手动存盘</strong>，以便万一打Boss失败了，可以从<strong>最近的地方</strong>重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，<strong>这个快照在Git中被称为commit</strong>。一旦你把文件改乱了，或者误删了文件，还可以<strong>从最近的一个commit恢复</strong>，然后继续工作，而不是把几个月的工作成果全部丢失，这就是版本回退。</p><p>假设对于readme.txt文件，我已经提交了三个版本的修改，而对于<code>git commit -m &lt;message&gt;</code>，-m后面输入的本次提交说明如下：</p><p>版本1：wrote a readme file<br>版本2：add distributed<br>版本3：append GPL(最新版本)</p><ul><li>git log<br>当然，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统Git干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log<br>commit <span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master)//最新的一次修改<br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    append GPL<br><br>commit e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> distributed<br><br>commit eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">18</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    wrote a readme file<br></code></pre></td></tr></table></figure>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL//最新的一次修改<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure></li></ul><p>:boom:友情提示：你看到的一大串类似1094adb…的是<strong>commit id（版本号）</strong>，你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。<strong>版本号没必要写全，前几位就可以了，Git会自动去找</strong><br><br></br><br>打算把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？<br>首先，<strong>Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本</strong>，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><ul><li>git reset</li></ul><p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用<code>git reset</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^//去上一个版本</span><br>HEAD <span class="hljs-keyword">is</span> now at e475afc <span class="hljs-keyword">add</span> distributed<br></code></pre></td></tr></table></figure><p>也可以指定某个commit版本进行还原</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">reset</span> --hard 1094a//指定commit版本前五位数为1094a的进行还原<br>HEAD <span class="hljs-built_in">is</span> now <span class="hljs-built_in">at</span> 83b0afe <span class="hljs-built_in">append</span> GPL<br></code></pre></td></tr></table></figure><p>如果你忘记了commit版本号，可以通过<code>git reflog</code>来找，<code>git reflog</code>记录了你的每一次命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br>e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br>eaadf4e HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme file<br></code></pre></td></tr></table></figure><p>:boom:过程图示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c24650a5651e4811b10f1a851a2c2ba1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>总结：</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<br><code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><p><br></br></p><h1 id="5-撤销修改git-checkout及git-reset-再提及"><a href="#5-撤销修改git-checkout及git-reset-再提及" class="headerlink" title="5.撤销修改git checkout及git reset(再提及)"></a><div id="5">5.撤销修改git checkout及git reset(再提及)</div></h1><ul><li>撤销工作区的修改</li></ul><p>当你对工作区文件完成修改时，你可以选择<code>git add</code>提交到暂存区，也可以选择<code>git checkout</code>撤销此次修改</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，<br>这里有两种情况：<br>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到上次提交到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><ul><li>撤销暂存区的修改</li></ul><p>当你对工作区文件完成修改且已经提交到了暂存区，你可以选择<code>git commit</code>提交到本地仓库区，也可以选择<code>git reset</code>把暂存区的修改撤销掉</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">$ git reset HEAD readme.txt<span class="hljs-comment">//前文讲过，HEAD代表当前最新版本的文件</span><br>Unstaged changes <span class="hljs-keyword">after</span> reset:<br>Mreadme.txt<br></code></pre></td></tr></table></figure><h4 id="可知，git-reset命令既可以回退版本，也可以把暂存区的修改撤销到工作区。"><a href="#可知，git-reset命令既可以回退版本，也可以把暂存区的修改撤销到工作区。" class="headerlink" title="可知，git reset命令既可以回退版本，也可以把暂存区的修改撤销到工作区。"></a>可知，<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改撤销到工作区。</h4><ul><li>撤销本地仓库区的修改</li></ul><p>什么时候需要撤销本地仓库区的修改呢？那便是已经<code>git commit</code>到本地仓库了，那便回到前文的版本回退章节进行查阅，<code>git reset --hard 指定版本</code>即可</p><p><br></br></p><h1 id="6-删除文件"><a href="#6-删除文件" class="headerlink" title="6.删除文件"></a><div id="6">6.删除文件</div></h1><p>在Git中，删除也是一个修改操作<br>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm &lt;file&gt;</code>命令删了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">rm</span> test.txt<br></code></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，<strong>工作区和版本库</strong>就不一致了</p><ul><li>如果你只是误删文件，那么可以通过<code>git checkout</code>指令恢复(撤销本次修改)<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- test.txt</span><br></code></pre></td></tr></table></figure></li><li>如果你确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，再<code>git commit</code>提交本次修改<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">test</span>.txt<br><span class="hljs-keyword">rm</span> &#x27;<span class="hljs-keyword">test</span>.txt&#x27;<br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;remove test.txt&quot;</span><br>[master d46f35e] remove <span class="hljs-keyword">test</span>.txt<br> 1 <span class="hljs-keyword">file</span> changed, 1 deletion(-)<br> delete mode 100644 <span class="hljs-keyword">test</span>.txt<br></code></pre></td></tr></table></figure><font color="blue">小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</font></li></ul><p><br></br></p><h1 id="7-分支管理-branch与switch"><a href="#7-分支管理-branch与switch" class="headerlink" title="7.分支管理 branch与switch"></a><div id="7">7.分支管理 branch与switch</div></h1><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，<strong>由于代码还没写完，不完整的代码库会导致别人不能干活了</strong>。如果等代码全部写完再一次提交，又存在<strong>丢失每天进度的巨大风险</strong>。<br>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再<strong>一次性合并到原来的分支上</strong>，这样，既安全，又不影响别人工作。<br><br></br></p><p>:boom:<strong>用<code>branch</code>系列指令进行分支相关操作</strong></p><ul><li>查看分支</li></ul><p>用<code>git branch</code>命令列出本地仓库中所有分支，当前分支前面会标一个<code>*</code>号</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* dev</span><br>  master<br></code></pre></td></tr></table></figure><ul><li>创建与合并分支</li><li>创建</li></ul><p><code>git branch dev</code>创建dev分支<br><code>git checkout dev</code>将HEAD指针切换到dev分支</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git branch dev<br><span class="hljs-variable">$ </span>git checkout dev<br>Switched to branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><p><code>git checkout -b dev</code>  git checkout命令加上-b参数表示创建并切换，相当于上面两条命令<br>先创建dev分支，然后切换到dev分支</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b dev<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><p><br></br></p><ul><li>合并</li></ul><p>当你在<code>dev</code>分支上对<code>readme.txt</code>文件进行修改后，想将该修改合并到<code>master</code>主分支上时，两步：</p><p>先<code>git checkout 分支名</code>切换到<code>master</code>分支</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>再<code>git merge 需要被合并的分支名</code>合并dev分支</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git merge dev<br><span class="hljs-function"><span class="hljs-title">Updating</span></span> d46f35e..b17d20e<br>Fast-forward<br> readme.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>合并完成后，就可以删除dev分支了，相较于<code>git checkout dev</code>添加分支，加个参数<code>-d</code>代表<code>delete</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ git <span class="hljs-keyword">branch </span>-d dev<br>Deleted <span class="hljs-keyword">branch </span>dev (was <span class="hljs-keyword">b17d20e).</span><br></code></pre></td></tr></table></figure><p><br></br><br>:boom:<strong>用<code>switch</code>系列指令进行分支相关操作</strong></p><p>注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更容易理解。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ git <span class="hljs-keyword">switch</span> -c dev<span class="hljs-comment">//代替git checkout -b dev</span><br></code></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ git <span class="hljs-keyword">switch</span> master<span class="hljs-comment">//代替git branch dev</span><br></code></pre></td></tr></table></figure><p><br></br><br>:boom:<strong>总结：</strong></p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code><br><br></br><br><br></br></p><h1 id="8-标签的使用-git-tag与git-show"><a href="#8-标签的使用-git-tag与git-show" class="headerlink" title="8.标签的使用 git tag与git show"></a><div id="8">8.标签的使用 git tag与git show</div></h1><p>前言：为什么要使用标签？</p><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的commit版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br><strong>Git有commit版本号，为什么还要引入tag？</strong><br>因为commit版本是类似<code>6a5819e...</code>的一大串字符，不好找、辨别<br>如果将<code>6a5819e...</code>变成<code>v1.2</code>，就容易了很多<br><strong>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit版本号绑在一起。</strong><br><br></br></p><p><br></br></p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><div id="11">创建标签</div></h2><p><code>git tag &lt;tagname&gt;</code><br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code><br><br></br></p><ul><li><p>给整个分支打标签<br>首先，<code>git branch</code>切换到需要打标签的分支上</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>然后<code>git tag &lt;tagname&gt;</code>打标签即可</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>给过去的某个commit版本打标签<br><code>git tag &lt;tagname&gt; &lt;commid id&gt;</code></p></li></ul><p><strong>默认标签是打在最新提交的commit上的，历史的找到历史提交的commit id，然后打上就可以了</strong></p><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">9</span> f52c633<br></code></pre></td></tr></table></figure><p><br></br><br><strong>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong><br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; &lt;commit id&gt;</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v0.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><p><br></br><br></br></p><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a><div id="12">查看标签</div></h2><p><code>git tag</code><br>可以用命令git tag查看所有标签</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><code>git show &lt;tagname&gt;</code><br>标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span> v0<span class="hljs-number">.9</span><br><span class="hljs-keyword">commit</span> f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0<span class="hljs-number">.9</span>)<br>Author: Michael Liao <span class="hljs-operator">&lt;</span>askxuefeng<span class="hljs-variable">@gmail</span>.com<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">56</span>:<span class="hljs-number">54</span> <span class="hljs-number">2018</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">merge</span><br><br>diff <span class="hljs-comment">--git a/readme.txt b/readme.txt</span><br>...<br></code></pre></td></tr></table></figure><p><br></br><br></br></p><h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><div id="13">删除标签</div></h2><ul><li><p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p></li><li><p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p></li></ul><p><br></br></p><h2 id="推送标签到远程库"><a href="#推送标签到远程库" class="headerlink" title="推送标签到远程库"></a><div id="14">推送标签到远程库</div></h2><ul><li><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p></li><li><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p></li></ul><p><br></br><br></br></p><h1 id="9-远程仓库的连接"><a href="#9-远程仓库的连接" class="headerlink" title="9.远程仓库的连接"></a><div id="9">9.远程仓库的连接</div></h1><p>目前广为人知的两个远程仓库有Github和Gitee(码云)</p><p>Github：人气最高，人们普遍使用的一个国际化代码管理平台</p><p>Gitee：使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况<br>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）</p><p><strong>目标：<br>在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步。</strong></p><p><br></br></p><h3 id="与远程库建立连接"><a href="#与远程库建立连接" class="headerlink" title="与远程库建立连接"></a><div id="15">与远程库建立连接</div></h3><p><code>git remote add 远程仓库名字 git@github.com:远程仓库路径//远程仓库路径如下图</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>michaelliao/learngit.git<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc0ec8b103c4adc815373b73711e01f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>建立好连接后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。<br><br></br></p><h3 id="向远程库输出本地库中的文件"><a href="#向远程库输出本地库中的文件" class="headerlink" title="向远程库输出本地库中的文件"></a><div id="16">向远程库输出本地库中的文件</div></h3><p><code>git push -u 远程仓库名称 要推送的本地分支名称</code></p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">$ git push -u origin master<br><span class="hljs-type">Counting</span> objects: <span class="hljs-number">20</span>, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Delta</span> compression using up <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> threads.<br><span class="hljs-type">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">15</span>/<span class="hljs-number">15</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">20</span>/<span class="hljs-number">20</span>), <span class="hljs-number">1.64</span> <span class="hljs-type">KiB</span> | <span class="hljs-number">560.00</span> <span class="hljs-type">KiB</span>/s, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Total</span> <span class="hljs-number">20</span> (delta <span class="hljs-number">5</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>remote: <span class="hljs-type">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">To</span> github.com:michaelliao/learngit.git<br> * [<span class="hljs-keyword">new</span> branch]      master -&gt; master<br><span class="hljs-type">Branch</span> <span class="hljs-symbol">&#x27;master&#x27;</span> set up <span class="hljs-keyword">to</span> track remote branch <span class="hljs-symbol">&#x27;master&#x27;</span> from <span class="hljs-symbol">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p><strong>从现在起，只要本地作了提交，就可以通过命令：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master//<span class="hljs-built_in">origin</span>依旧为远程库名称，master为要推送的分支名称<br></code></pre></td></tr></table></figure><p><br></br><br></br></p><h3 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a><div id="17">删除远程库</div></h3><p>在删除前，建议先用<code>git remote -v</code>查看远程库信息</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (push)<br></code></pre></td></tr></table></figure><p><code>git remote rm &lt;name&gt;</code> 删除远程库，name为远程库名称<br>比如删除前文创建的名为origin的远程库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p><br></br><br><strong>温馨提示：此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</strong><br><br></br><br>:boom:<strong>总结：</strong></p><ul><li><p>要关联一个远程库，使用命令<code>git remote add 远程仓库名字 git@github.com:远程仓库路径</code></p></li><li><p>关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；</p></li><li><p>关联后，使用命令<code>git push -u 远程仓库名称 要推送的本地分支名称</code> 第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push -u 远程仓库名称 要推送的本地分支名称</code>推送最新修改；</p></li></ul><p><br></br><br></br></p><h1 id="10-与Github或Gitee建立文件传输机制"><a href="#10-与Github或Gitee建立文件传输机制" class="headerlink" title="10.与Github或Gitee建立文件传输机制"></a><div id="10">10.与Github或Gitee建立文件传输机制</div></h1><p>你的本地Git仓库和GitHub仓库之间的传输方式有两种，一种是通过https，另一种是通过SSH加密的</p><p>HTTPS：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码<strong>都需要输入账号和密码</strong>，这也是https方式的麻烦之处(发现了https免密登录的方式)。</p><p>SSH：使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的<strong>拥有者或管理员</strong>，否则你是无法添加<strong>SSH key</strong>的。另外ssh默认是每次fetch和push代码<strong>都不需要输入账号和密码</strong><br><br></br><br>至于如何将本机与Github和Gitee建立SSH连接，方便推送不用输入邮箱密码，请参考下面链接：</p><ul><li>Github如何实现SSH加密传输：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">Github平台的SSH</a></li><li>Github如何实现SSH加密传输：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712">Gitee平台的SSH</a></li></ul><p><br></br><br></br></p><p><strong>这是我的第一篇万字博客！希望大家能够喜欢并从中收获到知识</strong></p><p><strong>以上便是这篇文章的全部内容啦</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profilehttp://blog.zhangjiancong.top">https://i.csdn.net/#/user-center/profilehttp://blog.zhangjiancong.top</a>)</p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>协作工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)</title>
    <link href="/2022/02/11/%E6%B5%85%E8%B0%88javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/02/11/%E6%B5%85%E8%B0%88javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>本篇文章我将从概念和对应题目知识点讲起，希望大家能有所收获</strong><br><br/><br/></p><h2 id="一、原型"><a href="#一、原型" class="headerlink" title="一、原型"></a>一、原型</h2><p>①所有引用类型都有一个_proto_(隐式原型)属性(类似链表中的next指针)， 链表可以通过.next访问下个元素，原型中可通过._proto_访问上一级元素。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093ea1edf14e4f5d8de22bb5ac8f10a7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>②所有类都有一个prototype(原型)属性，例如：Object,Function,Array</p><p>③所有引用类型的_proto_属性指向它构造函数的prototype<br>例如：arr是一个数组实例，那么arr._proto_&#x3D;Array.prototype<br><br/><br/></p><h2 id="二、原型链"><a href="#二、原型链" class="headerlink" title="二、原型链"></a>二、原型链</h2><p>当访问一个对象的某个属性时，会先在这个对象本身上查找，如果没有找到，则会去它的_proto_上查找，即它的构造函数的prototype，如果还没有找到就会继续在构造函数prototype的_proto_中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p><p>下面例子有助于你对原型链的理解：</p><p>arr为Array数组的实例</p><p>arr._proto_&#x3D;Array.prototype</p><p>Array._proto_&#x3D;Object.prototype</p><p><strong>分析：arr这个数组实例，沿着原型链找，找到数组的原型对象，数组这个类沿着原型链找，找到对象的原型对象(最高级)，因此也可以用arr._proto_._proto_来找到Object.prototype，类似链表中的next指针，只不过_proto_是往上找。</strong><br><br/><br/></p><h2 id="面试真题："><a href="#面试真题：" class="headerlink" title="面试真题："></a>面试真题：</h2><p><strong>题目一：<br>instanceof的原理，并用代码实现</strong><br><br/><br>分析：如果A沿着原型链能找到B.prototype，那么A instanceof B 为true(用_proto_来找)</p><p><strong>解法：遍历A的原型链，如果找到B.prototype，返回true，否则返回false</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">instanceof</span> =(<span class="hljs-params">A,B</span>)=&gt;&#123;<br>    <span class="hljs-keyword">let</span> p = A;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(p === B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        p = p.<span class="hljs-property">_proto_</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p><strong>题目二：</strong></p><p>var foo &#x3D; {},        F &#x3D; function(){};</p><p>Object.prototype.a &#x3D; ‘value a’;</p><p>Function.prototype.b &#x3D; ‘value b’;</p><p>console.log(foo.a);<br>console.log(foo.b);<br>console.log(F.a);<br>console.log(F.b);<br><br/><br>分析：如果在A对象上没找到x属性，那么会沿着原型链找x属性。(如果A为函数实例，那么A上面找不到，就去找Function这个类上有没有挂载x属性，如果没有就继续往上找到Object原型对象上有没有x属性)</p><p><strong>解法：明确foo和F变量的原型链，沿着原型链找a属性和b属性</strong></p><p>因此答案为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;value a&#x27;</span><br><span class="hljs-string">&#x27;undefined&#x27;</span><br><span class="hljs-string">&#x27;value a&#x27;</span><br><span class="hljs-string">&#x27;value b&#x27;</span><br></code></pre></td></tr></table></figure><p>foo这个对象实例上没有b属性，是因为原型链不能往下找，只能一层一层往上找，<strong>即对象实例不能腆着脸问他的下级Function有没有挂载b这个属性</strong></p><br/><br/><br/><p><strong>觉得本篇文章对你有帮助的请不要忘记一键三连加关注~~<br/><br>你的支持就是对我最大的动力！！<br/><br>会继续努力码更多的精品文章！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>原型</tag>
      
      <tag>原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 搭建自己的个人博客</title>
    <link href="/2022/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标成为一名高级前端开发工程师</strong></p></blockquote><p><strong>一文从头到尾教你通过 hexo 搭建自己的个人博客以及配置喜欢的主题</strong></p><p>本篇文章将从头到尾详细地教你如何通过 hexo 搭建自己的个人博客，新手都能看懂的教程哈哈</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。</p><p>而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。</p><p>那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。<br><br></br></p><h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。<br><br></br></p><h2 id="Hexo-搭建教程"><a href="#Hexo-搭建教程" class="headerlink" title="Hexo 搭建教程"></a>Hexo 搭建教程</h2><p><strong>本次教程主要分为8个部分，看完便可搭建自己喜欢的个人博客</strong></p><ol><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>将hexo部署到GitHub</li><li>设置个人域名</li><li>更改主题（fluid）</li><li>发布文章</li></ol><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li>Windows：到 <a href="https://git-scm.com/download/win">git</a>官网下载并安装即可，下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</li><li>Mac：<a href="http://www.macports.org/">MacPorts</a> 或 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><h3 id="安装-NodeJs"><a href="#安装-NodeJs" class="headerlink" title="安装 NodeJs"></a>安装 NodeJs</h3><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/">官方安装</a>，选择LTS版本就行。</p><p>Linux：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install nodejs<br>sudo apt-<span class="hljs-built_in">get</span> install npm<br></code></pre></td></tr></table></figure><p>安装完后，打开命令行，输入以下两行检查安装是否成功</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装好git之后，选择你想要安装hexo的地方（比如新建文件夹）</p><p>进入文件夹后，我们可以右击选择 <code>Git Bash here</code> 可以打开一个命令行窗口，输入：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>输入 <code>hexo -v</code> 查看一下版本</p><p><strong>至此环境准备完成，开始使用 hexo 搭个人博客</strong><br><br></br></p><h3 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init 文件夹名<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> 文件夹名<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>会生成很多文件夹，看不懂没关系，知道怎么配置就可以了。</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li><strong>_config.yml: 博客的配置文件</strong></li></ul><p>接着输入以下指令进行本地启动查看，指令意思后面会讲</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>这三个命令非常重要，在下文<strong>hexo 部署到 github</strong>会讲到</p><p>接着，在浏览器中输入 <code>localhost:4000</code> 就可以看到生成的博客页面了</p><p><code>ctrl + c</code> 可以关掉服务<br><br></br></p><h3 id="创建-github-仓库"><a href="#创建-github-仓库" class="headerlink" title="创建 github 仓库"></a>创建 github 仓库</h3><ol><li><p>首先，你先要有一个GitHub账户，去注册一个吧。</p></li><li><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库。</p></li><li><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我github用户名是 zjc2782171149，所以我的叫 <code>zjc2782171149.github.io</code></p></li></ol><h3 id="生成-SSH-添加到-github-仓库"><a href="#生成-SSH-添加到-github-仓库" class="headerlink" title="生成 SSH 添加到 github 仓库"></a>生成 SSH 添加到 github 仓库</h3><p>由于后续都是通过 SSH 进行仓库代码的快速部署，所以这一步很有必要，如果之前有在你的电脑本地进行过你的 github 仓库的 SSH 绑定，那此步可跳过</p><p><strong>回到你的git bash中，输入以下</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span><br>git config <span class="hljs-literal">user</span>.email<br></code></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><h5 id="ssh，简单来讲，就是一个秘钥，其中，id-rsa-是你这台电脑的私人秘钥，不能给别人看的，id-rsa-pub-是公共秘钥，可以随便给别人看。把这个公钥放在-GitHub-上，这样当你链接-GitHub-自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过-git-上传你的文件到-GitHub-上。"><a href="#ssh，简单来讲，就是一个秘钥，其中，id-rsa-是你这台电脑的私人秘钥，不能给别人看的，id-rsa-pub-是公共秘钥，可以随便给别人看。把这个公钥放在-GitHub-上，这样当你链接-GitHub-自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过-git-上传你的文件到-GitHub-上。" class="headerlink" title="ssh，简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。"></a>ssh，简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。</h5><p>而后在 github 的 setting 中，找到 SSH keys 的设置选项，点击 New SSH key 把你的 id_rsa.pub 里面的信息复制进去。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/020af2c8de394bed881c37d8591f08a8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>之后，在 gitbash 中输入以下指令，查看是否 SSH 是否已绑定成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><p>这一步，我们就可以将 hexo 和 github 关联起来，也就是将 hexo 生成的文章部署到 github 上，打开站点配置文件 <code>_config.yml</code>，翻到最后，进行如下修改即可，<code>zjc2782171149</code> 改为你的 github 账户用户名</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:zjc2782171149/zjc2782171149.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>修改完配置文件 <code>_config.yml</code> 并保存后，回到 gitbash</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后进行部署</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p><code>hexo clean</code> 清除了你之前生成的东西。</p><p><code>hexo generate</code> 生成静态文章，可以用 hexo g 缩写</p><p><code>hexo deploy</code> 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入 username 和 password，但设置了 SSH 一般不用。</p><p>得到下图就说明部署成功了，过一会儿就可以在 http:&#x2F;&#x2F;你的用户名.github.io 这个网站看到你的博客了！！<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc2715a6a154e4b923f6c76a1f39412~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br></p><h3 id="个人域名配置"><a href="#个人域名配置" class="headerlink" title="个人域名配置"></a>个人域名配置</h3><p>现在你的个人网站的地址是 <code>yourname.github.io</code>，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱购买域名，由于我是使用阿里云，所以以此作为示例。</p><p>注册一个阿里云账户,在阿里云上买一个域名，我买的是 zhangjiancong.top，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。</p><p>你需要先去进行实名认证,然后在域名控制台中，看到你购买的域名。</p><p><strong>来到域名解析页面，点击解析设置</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80dfa7213ecd475fb3d877b0ee925fa3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>点击添加记录</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398823dec9bd44ef87590ee2384a05b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48774bee367453b9a05955813f1bfd3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><p>主机记录：我想在我域名 <code>zhangjiancong.top</code> 的基础上，配置成子域名 <code>blog</code>，所以主机记录一栏写个 blog，如果你想直接将你的域名作为解析，不填即可</p></li><li><p>记录值：改为你自己的用户名</p></li><li><p>其他跟我一样就行</p></li></ul><p>点击确认后，域名 <code>blog.zhangjiancong.top</code> 到 <code>zjc2782171149.github.io</code> 的解析就完成了</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3643bc10ec84c2a949218844502f9f8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来，还要进行 <code>zjc2782171149.github.io</code>到 <code>blog.zhangjiancong.top</code> 的解析</p><p><br></br><br><strong>设置 githubPage 的解析</strong></p><p>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你刚刚的域名<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa2d15f38d1413a90907c2167084f0a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>如果你 <code>主机记录</code> 留空，此处直接写你的域名即可，即 <code>zhangjiancong.top</code></p><p>点击 <code>Save</code>，出现如上图的绿色成功标志即可</p><p>接着，你在你的博客文件 source 文件夹中创建一个名为<code>CNAME</code>文件，不用后缀，写上你的域名</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8645cba13cd2435480916aa9f37975ca~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><br></br><br><strong>更改 master 分支</strong></p><p>由于域名默认展示你的 github 仓库的默认分支，仓库默认分支是 main，但</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:zjc2782171149/zjc2782171149.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>设置的是部署到 <code>master</code> 分支，所以需要修改仓库的默认分支为 <code>master</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85c7ad4276744067b036d91f8c22ec2b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>点击编辑按钮，更改为 <code>master</code> 分支后，保存即可</p><p><strong>最后</strong></p><p>在 gitbash 中，输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！<br><br></br></p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>这里我以 <code>fluid</code> 主题作为示例</p><p>来到主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid">github</a> 仓库，下载最新的压缩包</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e98c0042e14e4426a89a3b5d468647c4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>下载完后，将压缩包解压到你博客项目的 <code>themes</code> 文件夹下，并将解压出来文件夹更名为 <code>fluid</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2cb0ad71174298812e456728c11856~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>然后打开根目录的 <code>_config.yml</code> 文件，拉到最下面找到 <code>theme</code> 属性，修改为 fluid</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb7cd9c115a42dabb9e98391086c4bc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>同时，找到文件上方的 <code>language</code> 属性，修改为 <code>zh-CN</code> 即可</p><p>然后，输入以下三个指令进行重新部署，过一会儿即可看到主题发生改变</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>发布新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> newpapername<br></code></pre></td></tr></table></figure><p>然后在source&#x2F;_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>就可以通过域名看到更新了。</p><p><br></br><br><strong>每次更新完文章或配置文件，都要输入以上三个指令进行重新部署，而不要缺某条指令，当然也可以输入简化版指令，如下</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo g --d<br></code></pre></td></tr></table></figure><p><strong>如果有小伙伴觉得每次重新部署都要输入以上指令麻烦，可在空余功夫研究下 <code>GitHub page</code> 的自动部署功能，此文便不展开了</strong><br><br></br></p><h1 id="以上便是这篇文章的全部内容啦"><a href="#以上便是这篇文章的全部内容啦" class="headerlink" title="以上便是这篇文章的全部内容啦"></a>以上便是这篇文章的全部内容啦</h1><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
