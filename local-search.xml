<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6k字带你从入门到吃透 React Hook</title>
    <link href="/2022/02/18/6k%E5%AD%97%E5%B8%A6%E4%BD%A0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%90%83%E9%80%8F%20React%20Hook/"/>
    <url>/2022/02/18/6k%E5%AD%97%E5%B8%A6%E4%BD%A0%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%90%83%E9%80%8F%20React%20Hook/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>🧨 大家好，我是 Smooth，一名大二的 SCAU 前端er <br /> 🏆 文章会为你讲述 React 11种 Hook 的日常用法以及进阶操作，由浅入深带你彻底掌握 React Hook！<br /> 🙌 如文章有误，恳请评论区指正，谢谢！</strong></p></blockquote><h2 id="React-Hooks-是什么"><a href="#React-Hooks-是什么" class="headerlink" title="React Hooks 是什么"></a>React Hooks 是什么</h2><p><code>React Hooks</code> 是 <code>React V16.8</code> 中推出的新特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p><code>React Hooks</code> 的设计初衷，就是用于加强函数组件（原有函数组件无法存在状态），让你能够在不使用”类”的前提下写出一个全功能的组件。</p><p>顾名思义 <code>Hooks</code> 在中文中是“钩子”的意思，Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。<br><br></br></p><h2 id="React-Hooks-的特点"><a href="#React-Hooks-的特点" class="headerlink" title="React Hooks 的特点"></a>React Hooks 的特点</h2><ol><li>代码更清晰，解决了类组件难维护、逻辑不易复用的问题</li><li>hooks 之间的状态是独立的，有自己独立的上下文，不会出现混淆状态的情况，解决了类组件中 this指针指向不明确或由于使用不当而造成不必要的错误</li><li>让函数有了<strong>状态管理</strong></li><li>避免函数重复执行的副作用（通过相关 hook 进行限制）</li><li>Hooks 可以引用其他 Hooks，通过组合可以<strong>更方便复用</strong>。</li><li>更容易将组件的<strong>视图与状态分离</strong>。<br><br></br><h2 id="使用-Hook-的条件"><a href="#使用-Hook-的条件" class="headerlink" title="使用 Hook 的条件"></a>使用 Hook 的条件</h2>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则：<h3 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h3></li></ol><p><strong>不要在循环，条件或嵌套函数中调用 Hook，</strong>  确保总是在你的 React 函数的最顶层调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。</p><h3 id="只在-React-函数中调用-Hook"><a href="#只在-React-函数中调用-Hook" class="headerlink" title="只在 React 函数中调用 Hook"></a>只在 React 函数中调用 Hook</h3><p><strong>不要在普通的 JavaScript 函数中调用 Hook。</strong> 你可以：</p><ul><li>✅ 在 React 的函数组件中调用 Hook</li><li>✅ 在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p><p>同时，React 官方提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks 插件</a>来强制执行这些规则，不按规则使用直接给你进行警告或报错<br><br></br></p><h2 id="React-Hooks-的使用"><a href="#React-Hooks-的使用" class="headerlink" title="React Hooks 的使用"></a>React Hooks 的使用</h2><p>重点来了！</p><h3 id="1-useState"><a href="#1-useState" class="headerlink" title="1. useState"></a>1. useState</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>给函数组件添加初始状态（变量初始化），它和 Class Component 中的 this.setState 类似。</p><blockquote><p>当我们使用 <code>useState</code> 定义 state 变量时候，它返回一个有两个值的数组。第一个值是当前的 state，第二个值是更新 state 的函数<br>和闭包差不多，暴露函数内部的值和一个修改该值的函数，只不过要注意的是，该函数对数据的更新是异步的</p></blockquote><h4 id="下面是一个实现计数器的简易-demo"><a href="#下面是一个实现计数器的简易-demo" class="headerlink" title="下面是一个实现计数器的简易 demo"></a>下面是一个实现计数器的简易 demo</h4><p>需求：点击 Click me，计数进行 + 1</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b37f7c1572a5a64f935a5d19fc7020cf.png" alt="image.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/82de877194c2a8ce7c978e04bc9ed936.png" alt="image.png"></p><p>如图可知，useState 对 count 进行初始化为0，以及提供了一个可修改 count 值的函数 setCount，每次点击按钮都触发 onClick 事件调用 setCount 函数，在 count 的基础上进行 +1</p><h4 id="所谓批量更新原则"><a href="#所谓批量更新原则" class="headerlink" title="所谓批量更新原则"></a>所谓批量更新原则</h4><p>熟悉 React 的同学都清楚所谓 state 的变化 React 内部遵循的是<strong>批量更新</strong>原则。</p><blockquote><p><strong>所谓异步批量是指在一次页面更新中如果涉及多次 state 修改时，会合并多次 state 修改的结果得到最终结果从而进行一次页面更新。</strong></p></blockquote><h5 id="为什么-React-Hook-采取批量更新原则？"><a href="#为什么-React-Hook-采取批量更新原则？" class="headerlink" title="为什么 React Hook 采取批量更新原则？"></a>为什么 React Hook 采取批量更新原则？</h5><p>官方解释：如果不在当前屏幕，我们可以延迟执行相关逻辑。如果数据数据到达的速度快过帧速，我们可以合并、批量更新。我们优先执行用户交互（例如按钮点击形成的动画）的工作，延后执行相对不那么重要的后台工作（例如渲染刚从网络上下载的新内容），从而避免掉帧。</p><h5 id="关于如何辨别异步批量更新"><a href="#关于如何辨别异步批量更新" class="headerlink" title="关于如何辨别异步批量更新"></a>关于如何辨别异步批量更新</h5><ol><li><p><strong>凡是<code>React</code>可以管控的地方，他就是异步批量更新</strong>。比如事件函数，生命周期函数中，组件内部同步代码。</p></li><li><p><strong>凡是<code>React</code>不能管控的地方，就是同步批量更新</strong>。比如<code>setTimeout</code>,<code>setInterval</code>,<code>源生DOM</code>事件中，<strong>包括<code>Promise</code>中</strong>都是同步批量更新。</p></li></ol><blockquote><p><strong>在 React 18 中通过 createRoot 中对外部事件处理程序进行批量处理，换句话说最新的 React 中关于 setTimeout、setInterval 等不能管控的地方都变为了批量更新。</strong></p></blockquote><p><br></br></p><h3 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2. useEffect"></a>2. useEffect</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <br>    <span class="hljs-comment">//此处编写 组件挂载之后和组件重新渲染之后执行的代码 ... </span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <br>        <span class="hljs-comment">//此处编写 组件即将被卸载前执行的代码 ... </span><br>    &#125; <br>&#125;, [])<br></code></pre></td></tr></table></figure><p>useEffect 被称为副作用钩子，这个 Hook 和 useState 一样是一个基础钩子。Effect Hook 可以让你在函数组件中执行副作用操作，修改了数据获取、设置订阅、手动更改 React 组件中的 DOM、<code>console.log()</code> 、ajax 操作等等都是副作用。同时，可以使用多个 Effect 实现关注点分离。</p><p><strong>类似于 Vue 中的计算属性</strong></p><blockquote><p><strong>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</strong></p></blockquote><p>useEffect 支持三个参数</p><ul><li><p>第一个参数为一个函数，表示副作用效应函数，默认情况下它在第一次渲染之后和每次更新之后都会执行。</p></li><li><p>第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项。只有该数组中的变量发生变化时，副效应函数才会执行，如果数组为空，则代表该 useEffect 不随任何变量发生变化，即只渲染一次。</p></li><li><p>第三个参数是 <code>useEffect</code> 的返回值，返回一个函数，在 <code>useEffect</code> 执行之前，都会先执行里面返回的函数，一般用于添加销毁事件</p></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p><code>useEffect</code> 是在 render（浏览器完成画面渲染） 之后才执行，所以该 Hook 可接受第二个参数来控制跳过执行，下次 render 后如果指定的值没有变化就不会执行。</p></li><li><p><code>useEffect</code> 监听某个特定值时，不能对其进行 <code>setValue</code> 否则就会陷入死循环，直到页面卡死。</p></li></ol><p><br></br></p><h3 id="3-useLayoutEffect"><a href="#3-useLayoutEffect" class="headerlink" title="3. useLayoutEffect"></a>3. useLayoutEffect</h3><p>useLayoutEffect 与 useEffect 使用方式是完全一致的，useLayoutEffect 的区别在于它会在<strong>所有的DOM 变更之后同步</strong>调用 effect。</p><h5 id="useEffect：执行时机在-render-之后"><a href="#useEffect：执行时机在-render-之后" class="headerlink" title="useEffect：执行时机在 render 之后"></a>useEffect：执行时机在 render 之后</h5><h5 id="useLayoutEffect：执行时机在所有的-DOM-更新之后"><a href="#useLayoutEffect：执行时机在所有的-DOM-更新之后" class="headerlink" title="useLayoutEffect：执行时机在所有的 DOM 更新之后"></a>useLayoutEffect：执行时机在所有的 DOM 更新之后</h5><p>可以使用它来读取 DOM 布局并同步触发重渲染。在<strong>浏览器执行绘制之前</strong>， useLayoutEffect 内部的更新计划将被同步刷新。</p><p>当然，有时你可能需要使用另外一个情况下，如果你要更新的值（像 ref ），此时你需要确保它是在<strong>最新的任何其他代码运行之前</strong>，此时可以考虑使用 useLayoutEffect ，而不是 useEffect，</p><blockquote><p><strong>通常对于一些通过 JS 计算的布局，如果你想减少 useEffect 带来的「页面抖动」,你可以考虑使用 useLayoutEffect 来代替它。</strong></p></blockquote><p><br></br></p><h3 id="4-useContext"><a href="#4-useContext" class="headerlink" title="4. useContext"></a>4. useContext</h3><p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><p>熟悉 React 中Context Api 和 Vue 中的 provide&#x2F;inject Api 的同学可能会对这个钩子的作用深有体会。</p><h5 id="如果还不是很能理解作用，请看以下-demo"><a href="#如果还不是很能理解作用，请看以下-demo" class="headerlink" title="如果还不是很能理解作用，请看以下 demo"></a>如果还不是很能理解作用，请看以下 demo</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/dab92ab48dce084a84f663756612ddfa.png" alt="image.png"></p><p>在根组件上我们需要向下传递一个 count 属性给第三层子组件 H 使用</p><p>此时，如果使用 props 的方法进行<strong>层层传递</strong>那么无疑是一种噩梦。而且如果我们的 H 组件需要使用 count 但是 B、E 并不需要，如果使用 props 的方法难免在 B、E 组件内部也要<strong>显式声明 count</strong>。</p><p>React 中正是为了解决这样的场景提出来 Context Api。</p><p><strong>可以通过 React.createContext 创建 context 对象，在根组件中通过 Context.Provider 的 value 属性进行 count 变量的分发，从而在 Function Component 中使用 useContext(Context) 获取对应的值。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7b6d22d171635be6e01c611750ef619b.png" alt="image.png"></p><blockquote><p><strong>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 &lt;MyContext.Provider&gt; 来为下层组件提供 context。</strong></p></blockquote><p>如果你想传递多个数据给子组件可以进行多个 <code>Context.Provider</code> 的嵌套</p><p><br></br></p><h3 id="5-useReducer"><a href="#5-useReducer" class="headerlink" title="5. useReducer"></a>5. useReducer</h3><p>React Hook 中还提供了一个关于状态管理的 useReducer，类似于 <strong>Vue 的 Vuex</strong>，全局状态管理工具</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init);<br></code></pre></td></tr></table></figure><p>useReducer 接受三个参数</p><ul><li>reducer 函数</li><li>初始值 initialArg</li><li>（可选）惰性初始化的 init 函数，它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</li></ul><p>本篇文章先不讲第三个函数（惰性初始化的 init 函数）的使用，有兴趣的同学可以去<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer">官方文档</a>进行食用。</p><h5 id="useReducer-的使用"><a href="#useReducer-的使用" class="headerlink" title="useReducer 的使用"></a>useReducer 的使用</h5><ol><li>创建变量初始仓库 <code>initialArg</code> 和管理者 <code>reducer</code></li><li>通过 <code>useReducer(reducer, initialArg)</code> 来获取 <code>state</code> 和 <code>dispatch</code></li></ol><p>让我们通过一个简单的计数器例子来了解一下它的基础用法:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/51541fb9de27c589659708b1d9dd06cd.png" alt="image.png"></p><p><strong>demo 解释</strong></p><ol><li>先创建数据仓库 <code>initialArg</code>，并设置一个管理者 <code>reducerExample</code></li><li>通过 <code>useReducer</code> 来新建该 demo 的 <code>state</code> 和 <code>dispatch</code></li><li>给点击事件套上 <code>dispatch</code> 事件，并传递对应参数</li><li>管理者 <code>reducerExample</code> 接收到对应参数后，通过 switch 执行特定行为，比如说对 state 做出改变</li></ol><p><strong>通过 <code>dispatch</code> 去派发 <code>action</code>，比如说上图的 type，payload</strong></p><h5 id="什么时候用-useReducer，什么时候用-useState？"><a href="#什么时候用-useReducer，什么时候用-useState？" class="headerlink" title="什么时候用 useReducer，什么时候用 useState？"></a>什么时候用 useReducer，什么时候用 useState？</h5><p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <strong>state 逻辑较复杂且包含多个子值</strong>，或者<strong>下一个 state 依赖于之前的 state</strong> 等。</p><h4 id="深更新的组件做性能优化"><a href="#深更新的组件做性能优化" class="headerlink" title="深更新的组件做性能优化"></a>深更新的组件做性能优化</h4><p>在 useReducer 的官方文档中存在这样一句介绍:</p><blockquote><p>使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 <code>dispatch</code> 而不是回调函数。</p></blockquote><p>在某些场景下我们通常会将<strong>函数作为 props</strong> 传递到 child component 中去，这样的话，每次父组件 re-render 时即使我们并没有修改当作 props 的函数，子组件也会重新渲染。例子如下：</p><p><strong>父组件</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1a8b0ebec613042b343fa4aea9df7271.png" alt="image.png"></p><p><strong>子组件</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/dda8548f28da86d8a95821e8129ae028.png" alt="image.png"></p><p><strong>演示动画</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b9a224ee1732a26b6825a200d9268403.gif" alt="useReducer.gif"></p><p>每次点击父组件的 button 时，子组件中的 effect 中被执行了。</p><p>此时其实我们传入子组件的 callback 并没有做什么改变，我们自然期望子组件中的 Effect 不会执行。</p><p><strong>产生这个原因的机制是 React 每次渲染都会重新执行组件函数，当重新执行父组件时会重新生成一个 callback 函数。因为 React 内部使用 Object.is 判断，所以 React 会认为子组件的 props 发生了变化。</strong></p><blockquote><p><strong>而在 useReduce 中返回的 dispatch 正是一个函数，但是 useReducer 的好处之一便是， dispatch 不会随着 re-render 而重新分配记忆位置，比方上述我们将 dispatch 作为 props 传入 child component 中时子组件中的 Effect 也并不会被执行。</strong></p></blockquote><p>至于解决这个子组件函数重新渲染问题，除了 dispatch 还有另一种方法，可以查看下方的 useCallback 板块</p><p><br></br></p><h3 id="6-useCallback"><a href="#6-useCallback" class="headerlink" title="6. useCallback"></a>6. useCallback</h3><p>接下来我们来聊一聊 useCallback ，它的最大作用体现在 React 中的性能优化。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const memoizedCallback = useCallback(<br>  <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; doSomething(a) &#125;, <br>  [a]);<br></code></pre></td></tr></table></figure><p>useCallback 接受两个参数:</p><ul><li>第一个参数是一个函数，这个函数仅会在对应依赖项发生变化之后才会被重新生成，或者说这个函数被产生「记忆」。</li><li>第二个参数是一个数组，它表示第一个参数所依赖的依赖项，仅在该数组中某一项发生变化时第一个参数的函数才会「清除记忆」重新生成。</li></ul><p>也许大多数接触 React 的朋友会好奇这个 Hook 的使用场景，此时让我们来回忆一下上面在 useReducer 板块的例子。</p><p>我们在父组件中传递了一个 callback 函数作为 props 传递给了子组件，每次渲染中我们并没有改变 callback 但是每次父组件 re-render ，React 仍然会认为 callback 发生变化从而造成多余的子组件 re-render 。</p><p>此时，使用 useCallback 就可以很好的解决这个例子，如下：</p><p><strong>对上面 useReducer 的父组件进行更改，包裹上 useCallback</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8bd3523f92b5e1f8c9c2e1091f2e4707.png" alt="image.png"></p><p>可以看到我们使用 useCallback 包裹了传入子组件的回调函数，同时第二个依赖项参数传递一个空数组。</p><p><strong>更改后演示动画</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f20f1b6b74d4328a616ad245caaf9a7e.gif" alt="useCallback.gif"></p><p>此时即使我们多次点击按钮，子组件的 Effect 也并不会执行了。</p><p><br></br></p><h3 id="7-useMemo"><a href="#7-useMemo" class="headerlink" title="7. useMemo"></a>7. useMemo</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useMemo( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fn, deps)<br></code></pre></td></tr></table></figure><p>useMemo 同样是作为性能优化提供的 Hook ，它相比 useCallback 来说支持<strong>任意类型的值</strong>都可以被记忆。而对于这个值，我们更常用的其实是一个个函数组件，不想某个函数组件一直渲染 （例如该函数组件涉及很多的 DOM 操作）导致花费额外的性能开销时就可以考虑使用 useMemo，例如后面示例的 <code>renderExample</code> 组件。</p><p>如果说 useCallback 是 React 团队提供给开发者作为对于 <strong>函数</strong> 的优化手段，那么 useMemo 就可以看作用于「记忆」 <strong>值</strong> 从而带来性能优化。</p><p>同样它支持两个参数:</p><ul><li>第一个参数接受传入一个函数，传入的函数调用返回值会被「记忆」。仅仅当依赖项发生变化时，传入的函数才会重新执行计算新的返回结果。</li><li>第二个参数同样也是一个数组，它表示第一个参数对应的依赖项。</li></ul><blockquote><p><code>useMemo( () =&gt; fn, deps)</code> 相当于 <code>useCallback(fn, deps)</code></p></blockquote><p>useMemo 跟 useCallback 的差别</p><ol><li><code>useMemo</code> 返回的是一个值，不仅仅限于函数</li><li><code>useMemo</code> 缓存的是一个值，<code>useCallback</code> 缓存的是一个函数</li></ol><p><strong>惯例，下面来看这个例子</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/01d027e10a062d0f28ab202c47089cb9.png" alt="image.png"></p><p>当我们每次点击 button 组件 re-render 时，renderSubject 的值都会重新计算也就是说每次都会打印出 <code>重新渲染啦！</code>。<br><img src="https://img-blog.csdnimg.cn/img_convert/37f9fd01b158a40b3dcf7b9b02f53cff.gif" alt="useMemo1.gif"></p><p>此时让我们再换成 useMemo 包裹 renderExample ,告诉 React 「记忆」 renderExample 的值再重新试一试</p><p><img src="https://img-blog.csdnimg.cn/img_convert/56146856f98fb208a6adf07b09f74d03.png" alt="image.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/206d8818fd0ec38529a0048be2e2bdbd.gif" alt="useMemo2.gif"></p><p>此时当我们点击页面上的 button 时，count 发生变化页面 re-render 时，因为我们使用 useMemo 传入的函数中返回 <code>data.map((item) =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)</code> 并且第二个参数是一个空数组。</p><p><strong>无论页面如何 re-render ，只要依赖项不发生变化那么 useMemo 中返回的值就不会重新计算。</strong></p><p>此时我们再再将依赖项由空数组，变为 count</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6de1fc6302c230e070524e3674e6206d.png" alt="image.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9aa773f61fc1334b12ea1d6b39c1c612.gif" alt="useMemo3.gif"></p><p>不出意外，随着依赖项 count 的改变，renderExample 这个值也重新渲染了</p><h4 id="关于性能优化"><a href="#关于性能优化" class="headerlink" title="关于性能优化"></a>关于性能优化</h4><p>关于 useCallback 以及 useMemo 这两个 Hook 都是 React 提供给开发者作为性能优化手段的方法。</p><p><strong>但是大多数时候，你不需要考虑去优化不必要的重新渲染</strong>。React 是非常快的，我能想到你可以利用时间去做很多事情，比起做这些类似的优化要好得多。</p><p>对于 useCallback 和 useMemo 来说，我个人认为不合理的利用这两个 Hook 不仅仅会使代码更加复杂，同时有可能会通过调用内置的 Hook 防止依赖项和 memoized 的值被垃圾回收从而导致性能变差。</p><p>如果说，有些情况下比如交互特别复杂的图表、动画之类，使用这两个 Hook 可以使你获得了必要的性能收益，那么这些成本都是值得承担的，但<strong>最好使用之前先测量一下</strong>。</p><blockquote><p><strong>官方文档指出，无需担心创建函数会导致性能问题。我们上述提供的例子仅仅是为了向大家展示它们的用法，实际场景下非常不建议这样使用。</strong></p></blockquote><p><br></br></p><h3 id="8-useRef"><a href="#8-useRef" class="headerlink" title="8. useRef"></a>8. useRef</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const refContainer <span class="hljs-operator">=</span> useRef(initialValue)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>类似于 useState，也是创建并保存一个变量</p><p><code>useRef</code> 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内持续存在。</p><p>useRef Hook 的作用主要有两个:</p><ul><li><p>获取 Dom 元素，在 Function Component 中我们可以通过 useRef 来获取对应的 Dom 元素。</p></li><li><p>多次渲染之间保证唯一值的纽带。</p></li></ul><p><strong>我们来详细讲讲第二点</strong></p><p>useRef 会在所有的 render 中保持对返回值的唯一引用。因为所有对<code>ref</code>的赋值和取值拿到的都是最终的状态，并不会因为不同的 render 中存在不同的隔离。</p><ul><li><p>useRef 相当于创建了一个变量并进行保存，不会因为组件重新渲染而重新初始化值（跟 useState 的不同处）</p></li><li><p>重新赋值 <code>ref.current</code> 不会触发组件重新渲染</p></li></ul><blockquote><p><strong>请记住，当 ref 对象内容发生变化时，<code>useRef</code> 并<em>不会</em>通知你。变更 <code>.current</code> 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用 <a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node">回调 ref</a> 来实现。</strong></p></blockquote><p><strong>老规矩，下面来看个例子</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed3e5a55bef3977a15fcec62215ccfdd.png" alt="image.png"></p><p>在 useMemo 示例的基础上，新增了一个 useRef，对 ref.current 进行不断赋值，直到 count 的值等于5时，再 clearInterval 清除，通过 console.log() 查看变化过程</p><p><strong>演示过程</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/b4dca5a58c3f324d215307e65a520543.gif" alt="useRef.gif"></p><p>可以看到，符合预期，useRef 创建的变量，在不断对 ref.current 进行重新赋值时，组件并没有重新渲染，而是按照规则慢慢改变。</p><p><br></br></p><h3 id="9-useImperativeHandle"><a href="#9-useImperativeHandle" class="headerlink" title="9. useImperativeHandle"></a>9. useImperativeHandle</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">ImperativeHandle(<span class="hljs-params">ref</span>, <span class="hljs-params">createHandle</span>, [<span class="hljs-params">deps</span>])</span><br></code></pre></td></tr></table></figure><p>useImperativeHandle 这个 Hook 很多同学日常可能用的不是很多，但是在某些情况下它会帮助我们实现一些意向不到的效果。</p><ul><li>ref 表示需要被赋值的 ref 对象。</li><li>createHandle 函数的返回值作为 ref.current 的值。</li><li>deps 依赖数组，依赖发生变化会重新执行 createHandle 函数。</li></ul><blockquote><p><strong><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用</strong></p></blockquote><p><strong>demo</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bba1b5c5977134f79db35435cf3b3e77.png" alt="image.png"></p><p>本例中,渲染 <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 <code>inputRef.current.focus()</code></p><p><br></br></p><h3 id="10-useDebugValue"><a href="#10-useDebugValue" class="headerlink" title="10. useDebugValue"></a>10. useDebugValue</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">DebugValue(<span class="hljs-params">value</span> , <span class="hljs-params">fn</span>)</span><br></code></pre></td></tr></table></figure><p>useDebugValue  可用于在 React 开发者工具中显示自定义 hook 的标签，它接受两个参数:</p><ul><li>value 为我们要重点关注的变量，该参数表示在 DevTools 中显示的 hook 标志。</li><li>fn 表明如何格式化变量 value , 该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。</li></ul><p>例如，一个返回 <code>Date</code> 值的自定义 Hook 可以通过格式化函数来避免不必要的 <code>toDateString</code> 函数调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">DebugValue(<span class="hljs-params">date</span>, <span class="hljs-params">date</span> =&gt; <span class="hljs-params">date</span>.<span class="hljs-params">toDateString</span>()</span>);<br></code></pre></td></tr></table></figure><p>当我们自定义一些 Hook 时，可以通过 useDebugValue 配合 React DevTools 快速定位我们自己定义的 Hook。</p><p><strong>案例</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4bfc397c666c87e2adf96fc464175963.png" alt="image.png"></p><p>这段代码中我通过 useDebug 定义了一个 hello React 的标示，此时我们来查看一下 React DevTools 的 Components 板块:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1a9e0960502014bdc4078feb296ad48e.png" alt="image.png"></p><h5 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h5><ul><li><p>useDebugValue应该在自定义hook中使用，如果直接在组件内使用是无效的。</p></li><li><p>大部分情况下你不需要使用这个 Hook ，除非你在编写一些公共库的 Hook 时，显式标志该 Hook 。</p></li></ul><p><br></br></p><h3 id="11-自定义-Hook"><a href="#11-自定义-Hook" class="headerlink" title="11. 自定义 Hook"></a>11. 自定义 Hook</h3><p><strong>自定义 Hook 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 Hook。</strong>  </p><p>更浅显易懂的理解，自定义 Hook 是将我们需要的业务逻辑进行抽离整合到一起（组件抽离），类似 <strong>Vue3 的 Composition API</strong>，一个个自定义 Hook 可以理解为 **setup()**，我们只是将两个函数之间一些共同的代码提取到单独的函数中。自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</p><h5 id="如何自定义-Hook"><a href="#如何自定义-Hook" class="headerlink" title="如何自定义 Hook"></a>如何自定义 Hook</h5><ol><li>自定义一个 hook 函数</li><li>在该 Hook 函数内写你需要的业务逻辑（例如引入其他 Hook 等等）</li><li>返回值是一个数组，数组中第一个值是变量，第二个值是修改该变量的函数</li><li>将自定义 hook 函数 export（暴露）出去</li><li>在需要用到该自定义 Hook 的地方对该 Hook 进行引入</li></ol><p>例如，上面第十点里的 <code>useName</code> 和下面的 <code>useFriendStatus</code> 是都是自定义的 Hook</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b00d15751dcb29106eb6815ce424b424.png" alt="image.png"></p><p>与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它就像一个正常的函数。但是它的名字应该始终以 <code>use</code> 开头，这样可以一眼看出其符合 <a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 的规则</a>。</p><br /><blockquote><p><strong>🎁 以上便是文章的全部内容啦 <br /> 🎁 觉得有用的小伙伴们可以点个赞支持鼓励一下我<br /> 🎁 我也会在今后努力产出更多好文</strong></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程，期待你的关注~</p><p>我的个人博客最近也在加紧同步中，欢迎参观：<a href="http://blog.zhangjiancong.top/">Smooth的个人博客</a></p><p><a href="https://gitee.com/zjc13544361063/leet-code">leetCode</a> 这是我建的力扣刷题仓库，会逐渐推出阿里云天池计划、HOT100、剑指offer等等系列，可以给个 <strong>star</strong> 支持一下，久更不易</p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5082841488024cdce02f8bc89a301b16.bmp"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们的项目源码开放啦！</title>
    <link href="/2022/02/17/%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%BC%80%E6%94%BE%E5%95%A6%EF%BC%81/"/>
    <url>/2022/02/17/%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E5%BC%80%E6%94%BE%E5%95%A6%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名高级前端开发工程师</strong></p></blockquote><p><strong>字节第二届寒假青训营也算正式落幕啦，在这其中收获良多。</strong></p><h1 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h1><p>44支队伍经过初审 + 终审，最终获得了第五名，成绩还算不错hh，也获得了评委老师一定的评价。<br><img src="https://gitee.com/zjc13544361063/zjc-markdown-picture/raw/master/image-20220218121056458.png" alt="image-20220218121056458"></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><strong>20天，112次 commit</strong><br><img src="https://gitee.com/zjc13544361063/zjc-markdown-picture/raw/master/image-20220218121029575.png" alt="image-20220218121029575"></p><p><strong>项目做到一半突然想着下一个TIME MASTER记录一下哈哈，可惜之前那一半代码量记录不进来咯</strong><br><img src="https://gitee.com/zjc13544361063/zjc-markdown-picture/raw/master/image-20220218121014907.png" alt="image-20220218121014907"></p><p>同时呢，结识到了很多厉害的人，眼界开阔了很多，也激起了自己更加努力的热情</p><h5 id="下面就对我们的项目做个简单的介绍吧"><a href="#下面就对我们的项目做个简单的介绍吧" class="headerlink" title="下面就对我们的项目做个简单的介绍吧"></a>下面就对我们的项目做个简单的介绍吧</h5><p><br></br></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>本项目名为摸鱼学社，是一个基于 React + Egg 的类掘金的社区网站，主要面向程序员这一群体，故我们保留了与掘金的大部分功能，并在此基础之上增加了唠嗑圈、力扣专区，满足程序员在摸鱼的同时不忘学习，我们在后期也会根据程序员这一群体的特殊性增加一些开发工具、自定义网站等功能。</p><p><strong>目标：致力于打造一个信息覆盖面广、体验良好、找到家一般的功能社区网站</strong><br><br></br></p><h2 id="项目灵感"><a href="#项目灵感" class="headerlink" title="项目灵感"></a>项目灵感</h2><p>作为掘金忠实用户，在平日浏览掘金社区时可能会因为一直看着蓝色而神经感到疲倦，所以有了想法可不可以不仅限于蓝色，然后再定制一个自己舒服的字体大小便于慢慢浏览，即用户可以自定义来丰富自己的体验</p><p><strong>对标产品：微博、Twitter、掘金社区、鱼塘热榜、清华摸鱼导学论</strong><br><br></br></p><h2 id="项目分工"><a href="#项目分工" class="headerlink" title="项目分工"></a>项目分工</h2><ul><li><p>黄馨莹：后端项目整体架构+Egg后端部署+MySql数据库设计+API接口文档设计</p></li><li><p>张健聪：前端项目整体架构 + 前端部署 + 开发首页、力扣专区、唠嗑圈、个人主页、个人设置、注册登录、文章撰写、文章详情、话题详情，年度报告页面，并进行用户体验优化、性能优化</p></li><li><p>刘轶贝：原型图、标签管理、草稿箱、回到顶部组件</p></li><li><p>曹泽：文章撰写页 的需求调研</p></li><li><p>于童：文章详情页-热点文章模块<br><br></br></p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3></li><li><p>主框架：React(全面拥抱 Hook )、React-Router v6</p></li><li><p>脚手架：create-react-app</p></li><li><p>CSS解决方案：styled-components</p></li><li><p>UI框架：Ant Design</p></li><li><p>登录鉴权：JWT</p></li><li><p>动画库：animate.css、react-transition-group、particles-bg</p></li><li><p>网络请求：axios</p></li><li><p>异步解决方案：promise、async&#x2F;await</p></li><li><p>协作工具：Git</p></li><li><p>打包工具：Webpack</p></li><li><p>包管理工具：yarn</p></li><li><p>规范：eslint-plugin-react-hooks </p></li><li><p>函数工具库：echarts、moment、lodash、mo.js、vditor<br><br></br></p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3></li></ul><ul><li>主框架：Egg</li><li>数据库：MySql</li><li>插件：egg-mysql  egg-validate  egg-jwt  egg-cors</li><li>API设计风格：RESTful API<br><br></br><h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h3></li></ul><ol><li>根据程序员这一群体的特殊性，我们集合了社区、力扣、markdown拓展、自定义工具库等等功能</li><li>定制化个人设置，让每个用户都有一个不一样的体验（例如主题色、文章字体大小）</li><li>提供年度报告等统计数据，采用echarts进行可视化函数，直观展示出数据</li><li>提供单次阅读时长提醒，让您在浏览社区的同时同时注意休息</li><li>提供文章稍后再看的缓存功能，让您可以记录下自己想看的文章</li><li>页面中增加动画过渡，更符合视觉感受<br><br></br></li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>使用React官方的Suspense及lazy组件实现路由懒加载及组件按需加载，减少首屏加载时间</li><li>使用魔法注释webpackChunkName减少打包时包体积</li><li>利用缓存，不重复加载相同资源且加快资源访问速度，提升用户体验(配置 runtimeChunk 和 利用浏览器缓存)</li><li>通过webpack本地对js和css文件做gzip压缩，减轻服务器压力</li><li>使用分页和图片懒加载减少页面同时加载多个DOM节点的压力</li><li>防抖和节流，限制了短时间内页面滚动次数和图标点击次数，减少前端多次请求js和后端多次请求数据的压力<br><br></br><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><h4 id="空白时使用加载中图标、骨架屏作视觉上的过渡"><a href="#空白时使用加载中图标、骨架屏作视觉上的过渡" class="headerlink" title="空白时使用加载中图标、骨架屏作视觉上的过渡"></a>空白时使用加载中图标、骨架屏作视觉上的过渡</h4><h4 id="页头、文章详情页实现视差滚动"><a href="#页头、文章详情页实现视差滚动" class="headerlink" title="页头、文章详情页实现视差滚动"></a>页头、文章详情页实现视差滚动</h4><h4 id="右下角提供返回顶部组件"><a href="#右下角提供返回顶部组件" class="headerlink" title="右下角提供返回顶部组件"></a>右下角提供返回顶部组件</h4><h4 id="设置隐藏彩蛋，文章详情处点赞可触发"><a href="#设置隐藏彩蛋，文章详情处点赞可触发" class="headerlink" title="设置隐藏彩蛋，文章详情处点赞可触发"></a>设置隐藏彩蛋，文章详情处点赞可触发</h4><br></br><blockquote><p><strong>具体信息可以查看开发文档链接</strong><br>内有前后端源码，以及api文档</p></blockquote></li></ol><p><strong>摸鱼学社开发文档</strong><br><a href="https://lhcgmmdf97.feishu.cn/docs/doccnYqYVMI4JMLmANnXKGCwdKe#">https://lhcgmmdf97.feishu.cn/docs/doccnYqYVMI4JMLmANnXKGCwdKe#</a></p><p><strong>项目预览地址</strong><br>loaf.zhangjiancong.top</p><br /><blockquote><p><strong>🎁 以上便是文章的全部内容啦 <br /> 🎁 觉得有用的小伙伴们可以点个赞支持鼓励一下我<br /> 🎁 我也会在今后努力产出更多好文</strong></p></blockquote><br /><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程，期待你的关注~</p><p>我的个人博客最近也在加紧同步中，欢迎参观：<a href="http://blog.zhangjiancong.top/">Smooth的个人博客</a></p><p><a href="https://gitee.com/zjc13544361063/leet-code">leetCode</a> 这是我建的力扣刷题仓库，会逐渐推出阿里云天池计划、HOT100、剑指offer等等系列，可以给个 <strong>star</strong> 支持一下，久更不易</p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟让你彻底理解如何配置子域名来部署多个项目</title>
    <link href="/2022/02/16/10%E5%88%86%E9%92%9F%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9D%A5%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/02/16/10%E5%88%86%E9%92%9F%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9D%A5%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名前端开发工程师</strong></p></blockquote><p><strong>配置子域名让你一台服务器可以同时部署多个项目</strong></p><p>本篇文章将详细为你讲解如何配置子域名让你一台服务器可以同时部署多个项目，新手都能看懂的教程哈哈</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有如下需求：</p><p>我有一个域名 zhangjiancong.top，我想在上面搭几个web应用，分别是 </p><ul><li>个人博客：myblog.zhangjiancong.top</li><li>娱乐项目：xxx.zhangjiancong.top</li></ul><p>一种办法就是在nginx的document myblog、xxx目录，访问方式就是<strong>zhangjiancong.top&#x2F;myblog</strong></p><p><strong>zhangjiancong.top&#x2F;xxx</strong></p><p>但这样有几个缺点</p><ol><li>某些web应用可能本身就不支持非根目录的方式访问，导致不可用</li><li>因为各个应用可能需要进行location的特殊配置，而这些应用不在根路径的时候，location配置可能有所不同，更加复杂</li><li>不够酷，太丑了</li></ol><p>需要让 myblog、xxx 都拥有自己的子域名（myblog.zhangjiancong.top、xxx.zhangjiancong.top），可以这么做：</p><ol><li>在域名服务商那里，加一个CNAME记录，把需要配置的子域名指向根域对应的主机名即可。</li><li>然后在宝塔界面修改 Nginx 配置</li><li>添加新站点<br>具体如下：</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-添加-CNAME-记录"><a href="#1-添加-CNAME-记录" class="headerlink" title="1. 添加 CNAME 记录"></a>1. 添加 CNAME 记录</h3><p>我是阿里云，所以就用阿里云做示例，无论是啥服务商，打开域名解析界面即可</p><p><strong>进入到域名解析界面</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/134b207c5d8c4d44950941b88ba9e916~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>点击添加记录</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd8fa4c898c4392b2dbbb4083cb118c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h5><p><strong>CNAME记录</strong></p><p>什么情况下会用到CNAME记录？</p><p>［如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录］<br>最常用到CNAME的情况包括：做CDN，配置子域名</p><p><strong>CNAME记录的添加说明</strong></p><p>解析线路一栏记得改成 默认，中国联通只是后文举例说明该配置项作用<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9156780b28ed4d6090e11b13817098b5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><p>记录类型：选择 <code>CNAME</code></p></li><li><p>主机记录：填子域名（比如需要添加 myblog.zhangjiancong.top的解析，只需要在主机记录处填写 myblog 即可；如果添加 zhangjiancong.top的解析 的解析，主机记录直接留空，系统会自动填一个“@”到输入框内）。</p></li><li><p>解析线路：默认即可（如果不选默认会导致部分特定用户无法解析；在上图中的作用为：除了联通用户之外的所有用户都可正常解析）</p></li><li><p>记录值：CNAME 指向的域名，只可以填写域名，记录生成后会自动在域名后面补一个“.”，这是正常现象</p></li><li><p>TTL：添加时系统会自动生成，默认为600秒（TTL为缓存时间，数值越小，修改记录各地生效时间越快）。</p></li></ul><p><strong>点击确认即可</strong><br><br></br></p><h3 id="2-修改-Nginx-配置文件"><a href="#2-修改-Nginx-配置文件" class="headerlink" title="2. 修改 Nginx 配置文件"></a>2. 修改 Nginx 配置文件</h3><p><strong>找到宝塔界面该项</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b7c6538e744e61a96294e055a0cd29~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>找到配置入口</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba0f32f20e8c430f8b96207d134131ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>对配置文件的 server 字段进行如上图的修改</strong></p><ul><li>由于我主域名放的是我另一个资源 loaf-community，所以我 <code>$doc</code> 初始值为 <code>&quot;loaf-community&quot;</code>，否则为 <code>&quot;&quot;</code> 即可</li><li>if 为匹配规则，root 为服务器对应路径资源，我资源都放在 <code>/www/wwwroot/</code> 的目录下，大家根据自己服务器真实路径进行配置即可<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 设置子域名目录</span><br><span class="hljs-attribute">set</span> <span class="hljs-variable">$doc</span> <span class="hljs-string">&quot;loaf-community&quot;</span>;<br><span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> <span class="hljs-regexp">~ ^(\w+)\.zhangjiancong\.top)</span> &#123;<br>    <span class="hljs-attribute">set</span> <span class="hljs-variable">$doc</span> <span class="hljs-variable">$1</span>;<br>&#125;<br><br><span class="hljs-comment"># 设置此时域名对应的root</span><br><span class="hljs-attribute">root</span> /www/wwwroot/<span class="hljs-variable">$doc</span>;<br></code></pre></td></tr></table></figure></li></ul><p>这样做的好处就是，之后要加个子域名，只要我在 <code>/www/wwwroot</code> 目录中新建一个子目录放新增的项目，取子域名作为目录名，然后在域名服务商新增一条字域名的CNAME记录就搞定了，非常方便。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c30b109d9b846aaa4729037474655f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br></p><h3 id="3-添加新站点"><a href="#3-添加新站点" class="headerlink" title="3. 添加新站点"></a>3. 添加新站点</h3><p><strong>找到入口</strong><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19c647f0a574caf821017071f0ef03d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>配置子域名及其对应项目资源路径</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1010db29cc0460a811de4baa6b17e70~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><strong>配置完重启服务器即可</strong></p><blockquote><p><strong>配置过第二步后，之后每次添加新子域名和项目，只用进行第一和第三步即可</strong></p></blockquote><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文理解配置伪静态解决 部署项目刷新页面404问题</title>
    <link href="/2022/02/15/%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3%E9%85%8D%E7%BD%AE%E4%BC%AA%E9%9D%99%E6%80%81%E8%A7%A3%E5%86%B3%20%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2404%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/15/%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3%E9%85%8D%E7%BD%AE%E4%BC%AA%E9%9D%99%E6%80%81%E8%A7%A3%E5%86%B3%20%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2404%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名前端开发工程师</strong></p></blockquote><p><strong>配置伪静态解决部署项目后页面刷新404问题</strong></p><p>网上看了很多如何解决 <code>项目部署后刷新页面报404</code> 的文章，解决的方式无非只有两个：</p><ol><li>将 historyRouter 变为 hashRouter （治标不治本）</li><li>配置无论任何路径，都返回index.html，剩下的事情交给 React Router</li></ol><p>但第二种不知为何我一直不奏效，直到使用了 <code>配置伪静态</code> 这种方法，所以本篇文章我想向很多跟我遇到同样问题的小伙伴分享一下我的解决方法</p><h2 id="普及基本概念-Q-amp-A"><a href="#普及基本概念-Q-amp-A" class="headerlink" title="普及基本概念 Q&amp;A"></a>普及基本概念 Q&amp;A</h2><h3 id="为什么会404-？"><a href="#为什么会404-？" class="headerlink" title="为什么会404 ？"></a>为什么会404 ？</h3><p>原因很简单：当你刷新时，你首先是根据url访问的服务器资源地址，然后返回的页面内加载了对应资源，最后在浏览器进行渲染；也就是说如果这个时候报404，是因为你后台并没有针对这个路由给出返回HTML内容，也谈不上执行React Router了。</p><p><strong>简单来说就是，没在服务器对应url路径匹配到你需要的资源</strong><br><br></br></p><h3 id="为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？"><a href="#为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？" class="headerlink" title="为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？"></a>为什么不刷新就不会404，不是说服务器根据你这个路径找不到对应资源吗？</h3><p>你在浏览器内可以由首页跳转到其他路由地址，是因为这是由前端自行渲染的，你在React Router定义了对应的路由，脚本并没有刷新网页访问后台，是JS动态更改了location。<br><br></br></p><h3 id="为什么-hashRouter-可以，historyRouter-不行？"><a href="#为什么-hashRouter-可以，historyRouter-不行？" class="headerlink" title="为什么 hashRouter 可以，historyRouter 不行？"></a>为什么 hashRouter 可以，historyRouter 不行？</h3><p><code>React</code>是属于单页应用（single-page application）</p><p>而<code>SPA</code>是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个<code>index.html</code>。当我们在地址栏输入 <a href="http://www.xxx.com/">www.xxx.com</a> 时，这时会打开我们 <code>nginx</code> 配置的目录下的 index.html 文件，然后我们在跳转路由进入到 <a href="http://www.xxx.com/login">www.xxx.com/login</a></p><p>关键在这里，当我们在 <a href="http://www.xxx.com/login">www.xxx.com/login</a> 页执行刷新操作，nginx location 是没有根据这路径做相关的资源返回配置的，所以就会出现 404 的情况</p><p><strong>hashRouter</strong></p><p>router hash 模式我们都知道是用符号#表示的，如  <a href="http://www.xxx.com/#/login">www.xxx.com/#/login</a>, hash 的值为 #&#x2F;login。</p><p>它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面</p><p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com/#/login">www.xxx.com/#/login</a> 只有 <a href="http://www.xxx.com/">www.xxx.com</a> 会被包含在请求中 ，因此对于服务端来说，即使没有配置location，也不会返回404错误</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>好，说了那么多，现在就阐述解决方案<br><strong>以下示例为宝塔面板</strong></p><h3 id="配置伪静态资源"><a href="#配置伪静态资源" class="headerlink" title="配置伪静态资源"></a>配置伪静态资源</h3><p><strong>第一步</strong>找到配置项入口</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ff6ba724b4c46d5a971b5932a929d00~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db83bb6f5cdb4a659974bd6a9ebf4ff7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><br></br><br><strong>第二步</strong> 进行伪静态配置</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5815f3a5d4d0432e8219b600ff79e8cd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ <span class="hljs-variable">@router</span>;<br>    <span class="hljs-attribute">index</span>  index.html;<br>&#125;<br><br><span class="hljs-section">location</span> <span class="hljs-variable">@router</span>&#123;<br>      <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^.*$</span> /index.html <span class="hljs-literal">last</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><br></br><br><strong>第三步</strong> 重启服务器即可<br><br></br></p><h3 id="其他解决"><a href="#其他解决" class="headerlink" title="其他解决"></a>其他解决</h3><p>可以使用文头所说的方法</p><ol><li>将 historyRouter 变为 hashRouter （治标不治本）</li><li>配置无论任何路径，都返回index.html，剩下的事情交给React Router</li></ol><p>只不过我对于第二种方法一直配置不生效</p><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>部署</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带你3分钟掌握常见的水平垂直居中面试题</title>
    <link href="/2022/02/14/%E5%B8%A6%E4%BD%A03%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/02/14/%E5%B8%A6%E4%BD%A03%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名前端开发工程师</strong></p></blockquote><h4 id="这是一篇关于css-居中知识的总结，只要这些都了解了，居中这方面面试就没问题了"><a href="#这是一篇关于css-居中知识的总结，只要这些都了解了，居中这方面面试就没问题了" class="headerlink" title="这是一篇关于css 居中知识的总结，只要这些都了解了，居中这方面面试就没问题了"></a>这是一篇关于<code>css</code> 居中知识的总结，只要这些都了解了，居中这方面面试就没问题了</h4><p>只要涉及到CSS就绕不开定位问题，尤其是盒子居中。居中又分为水平居中和垂直居中，有多种实现方式，下面我便一一列出来。</p><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h5 id="1-inline元素：text-align-center"><a href="#1-inline元素：text-align-center" class="headerlink" title="1.  inline元素：text-align: center"></a>1.  inline元素：text-align: center</h5><h5 id="2-block元素：margin-0-auto"><a href="#2-block元素：margin-0-auto" class="headerlink" title="2.  block元素：margin: 0 auto"></a>2.  block元素：margin: 0 auto</h5><h5 id="3-absolute元素：left-50-margin-left负值-值为该元素宽度的一半"><a href="#3-absolute元素：left-50-margin-left负值-值为该元素宽度的一半" class="headerlink" title="3.  absolute元素：left: 50% + margin-left负值(值为该元素宽度的一半)"></a>3.  absolute元素：left: 50% + margin-left负值(值为该元素宽度的一半)</h5><h5 id="4-absolute元素：left-50-transform-translateX（-50"><a href="#4-absolute元素：left-50-transform-translateX（-50" class="headerlink" title="4.  absolute元素：left: 50% + transform: translateX（-50%)"></a>4.  absolute元素：left: 50% + transform: translateX（-50%)</h5><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h5 id="1-inline元素：line-height的值等于height值"><a href="#1-inline元素：line-height的值等于height值" class="headerlink" title="1.  inline元素：line-height的值等于height值"></a>1.  inline元素：line-height的值等于height值</h5><h5 id="2-absolute元素：top：50-margin-top负值-值为该元素高度的一半"><a href="#2-absolute元素：top：50-margin-top负值-值为该元素高度的一半" class="headerlink" title="2.  absolute元素：top：50%+margin-top负值(值为该元素高度的一半)"></a>2.  absolute元素：top：50%+margin-top负值(值为该元素高度的一半)</h5><h5 id="3-absolute元素：top：50-transform-translateY（-50"><a href="#3-absolute元素：top：50-transform-translateY（-50" class="headerlink" title="3.  absolute元素：top：50%+transform: translateY（-50%)"></a>3.  absolute元素：top：50%+transform: translateY（-50%)</h5><h5 id="4-absolute元素：有固定宽高度-top，left，bottom，right-x3D-0-margin-auto"><a href="#4-absolute元素：有固定宽高度-top，left，bottom，right-x3D-0-margin-auto" class="headerlink" title="4.  absolute元素：有固定宽高度+top，left，bottom，right&#x3D;0  +  margin:auto"></a>4.  absolute元素：有固定宽高度+top，left，bottom，right&#x3D;0  <strong>+</strong>  margin:auto</h5><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>就是上述的水平居中+垂直居中合起来<br>这里我举几个常用的例子：</p><h3 id="1-放在定位是relative盒子内的absolute盒子："><a href="#1-放在定位是relative盒子内的absolute盒子：" class="headerlink" title="1. 放在定位是relative盒子内的absolute盒子："></a>1. 放在定位是relative盒子内的absolute盒子：</h3><h4 id="top-50-left-50-transform-translate-50-50"><a href="#top-50-left-50-transform-translate-50-50" class="headerlink" title="top: 50%;left: 50%;transform: translate(-50%,-50%);"></a><code>top: 50%;left: 50%;transform: translate(-50%,-50%);</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e70cab9a6a74837bf5fb60488a5ee13~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ace512ca45f4c2fa7d6f6dc9d519c1a~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="2-知道盒子的宽度和高度"><a href="#2-知道盒子的宽度和高度" class="headerlink" title="2. 知道盒子的宽度和高度"></a>2. 知道盒子的宽度和高度</h3><h4 id="top-50-left-50"><a href="#top-50-left-50" class="headerlink" title="top: 50%;left: 50%;"></a><code>top: 50%;left: 50%;</code></h4><h4 id="加上-margin-left-负值-值为该元素宽度的一半-margin-top负值-值为该元素高度的一半"><a href="#加上-margin-left-负值-值为该元素宽度的一半-margin-top负值-值为该元素高度的一半" class="headerlink" title="加上 margin-left 负值(值为该元素宽度的一半);margin-top负值(值为该元素高度的一半)"></a><code>加上 margin-left 负值(值为该元素宽度的一半);margin-top负值(值为该元素高度的一半)</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24637a30c2e4d3a9a8b8e1dd8ed0253~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/799ae7a0a74841a8b44d15087af1d0b2~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="3-放在定位是relative盒子内的absolute盒子且该盒子有固定宽高："><a href="#3-放在定位是relative盒子内的absolute盒子且该盒子有固定宽高：" class="headerlink" title="3. 放在定位是relative盒子内的absolute盒子且该盒子有固定宽高："></a>3. 放在定位是relative盒子内的absolute盒子且该盒子有固定宽高：</h3><h4 id="top，left，bottom，right-0-margin-auto"><a href="#top，left，bottom，right-0-margin-auto" class="headerlink" title="top，left，bottom，right=0 + margin:auto"></a><code>top，left，bottom，right=0 + margin:auto</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3414379e55104acdae89ca46ee9c90e0~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd9ff4f33ae4a32a3a7aadaa3770e11~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="4-CSS3弹性布局（flex）"><a href="#4-CSS3弹性布局（flex）" class="headerlink" title="4. CSS3弹性布局（flex）"></a>4. CSS3弹性布局（flex）</h3><p>如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素设置成以下属性即可</p><h4 id="display-flex-x2F-x2F-flex布局"><a href="#display-flex-x2F-x2F-flex布局" class="headerlink" title="display:flex &#x2F;&#x2F; flex布局"></a>display:flex &#x2F;&#x2F; flex布局</h4><h4 id="align-items-center；-x2F-x2F-元素水平居中"><a href="#align-items-center；-x2F-x2F-元素水平居中" class="headerlink" title="align-items:center；&#x2F;&#x2F; 元素水平居中"></a>align-items:center；&#x2F;&#x2F; 元素水平居中</h4><h4 id="justify-content-center；-x2F-x2F-元素垂直居中"><a href="#justify-content-center；-x2F-x2F-元素垂直居中" class="headerlink" title="justify-content:center；&#x2F;&#x2F; 元素垂直居中"></a>justify-content:center；&#x2F;&#x2F; 元素垂直居中</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87848c375b948ceb9380571733c19a2~tplv-k3u1fbpfcp-zoom-1.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c25f1c8d3b248fa8aca1d147d0c6f23~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水平居中</tag>
      
      <tag>垂直居中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React实战：使用Antd+EMOJIALL 实现emoji表情符号的输入</title>
    <link href="/2022/02/13/React%E5%AE%9E%E6%88%98/"/>
    <url>/2022/02/13/React%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标是想要成为一名高级前端开发工程师</strong></p></blockquote><p>本文是我在进行一个React项目的开发时，发表内容方面有输入表情符号的拓展需求，通过一段时间的查找及实践后，完成了此需求，同时也借此机会向大家分享我的思路。</p><h2 id="一、确定需求"><a href="#一、确定需求" class="headerlink" title="一、确定需求"></a>一、确定需求</h2><h3 id="首先我们要明确我们实现的大概思路是什么"><a href="#首先我们要明确我们实现的大概思路是什么" class="headerlink" title="首先我们要明确我们实现的大概思路是什么"></a>首先我们要明确我们实现的大概思路是什么</h3><p>在点击输入框下方的<code>表情</code>键后弹出选择表情的弹窗，选择表情后关闭弹窗，选择的表情自动追加到文本域的最后一位。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b23eee3664499a9150715b3f536333~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="二、书写样式"><a href="#二、书写样式" class="headerlink" title="二、书写样式"></a>二、书写样式</h2><h4 id="1-使用antd的Textarea、Space、Button组件以及-ant-design-icons实现样式"><a href="#1-使用antd的Textarea、Space、Button组件以及-ant-design-icons实现样式" class="headerlink" title="1. 使用antd的Textarea、Space、Button组件以及@ant-design/icons实现样式"></a>1. 使用antd的<code>Textarea</code>、<code>Space</code>、<code>Button</code>组件以及<code>@ant-design/icons</code>实现样式</h4><h5 id="Textarea：规定文本输入框的值、输入触发的回调函数等等。"><a href="#Textarea：规定文本输入框的值、输入触发的回调函数等等。" class="headerlink" title="Textarea：规定文本输入框的值、输入触发的回调函数等等。"></a><code>Textarea</code>：规定文本输入框的值、输入触发的回调函数等等。</h5><h5 id="Space：美化行内间距。"><a href="#Space：美化行内间距。" class="headerlink" title="Space：美化行内间距。"></a><code>Space</code>：美化行内间距。</h5><h5 id="Button：定义发送的按钮。"><a href="#Button：定义发送的按钮。" class="headerlink" title="Button：定义发送的按钮。"></a><code>Button</code>：定义发送的按钮。</h5><h5 id="（1）先从antd导入需要的组件和图标"><a href="#（1）先从antd导入需要的组件和图标" class="headerlink" title="（1）先从antd导入需要的组件和图标"></a>（1）先从antd导入需要的组件和图标</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592bc562a1d7448692be8482a22fced1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="（2）对组件进行排版"><a href="#（2）对组件进行排版" class="headerlink" title="（2）对组件进行排版"></a>（2）对组件进行排版</h5><ol><li>给<code>表情</code>添加<code>showModal</code>事件来打开弹窗</li><li>给文本域添加<code>onChange</code>事件，每次键盘输入文字或选择表情进行输入都可以监听到</li><li>给<code>Button</code>发送按钮添加<code>sendMessage</code>事件<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1365ee6d16aa46b7b26ccd89aad37c91~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><h5 id="其中-smileHover-类定义为鼠标放上去字体变蓝即可实现上图的效果"><a href="#其中-smileHover-类定义为鼠标放上去字体变蓝即可实现上图的效果" class="headerlink" title="其中 smileHover 类定义为鼠标放上去字体变蓝即可实现上图的效果"></a>其中 smileHover 类定义为鼠标放上去字体变蓝即可实现上图的效果</h5></li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f576d17e184e41d08d7d87e705450224~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="三、核心代码"><a href="#三、核心代码" class="headerlink" title="三、核心代码"></a>三、核心代码</h2><h4 id="1-从antd导入Modal组件并在其内部的Row组件动态渲染Col组件"><a href="#1-从antd导入Modal组件并在其内部的Row组件动态渲染Col组件" class="headerlink" title="1. 从antd导入Modal组件并在其内部的Row组件动态渲染Col组件"></a>1. 从antd导入<code>Modal</code>组件并在其内部的<code>Row</code>组件动态渲染<code>Col</code>组件</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd44f2a2ff25496c9e19b3cdb478cfe5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="其中-lt-Row-gt-组件动态渲染，数组为emojiList，渲染一列列-lt-Col-gt-组件"><a href="#其中-lt-Row-gt-组件动态渲染，数组为emojiList，渲染一列列-lt-Col-gt-组件" class="headerlink" title="其中&lt;Row&gt;组件动态渲染，数组为emojiList，渲染一列列&lt;Col&gt;组件"></a>其中<code>&lt;Row&gt;</code>组件动态渲染，数组为<code>emojiList</code>，渲染一列列<code>&lt;Col&gt;</code>组件</h5><h5 id="emojiList数组自定义，想放哪些表情就放哪些进去"><a href="#emojiList数组自定义，想放哪些表情就放哪些进去" class="headerlink" title="emojiList数组自定义，想放哪些表情就放哪些进去"></a><code>emojiList</code>数组自定义，想放哪些表情就放哪些进去</h5><h5 id="表情可通过下面EMOJIALL网址进行查找，复制黏贴即可"><a href="#表情可通过下面EMOJIALL网址进行查找，复制黏贴即可" class="headerlink" title="表情可通过下面EMOJIALL网址进行查找，复制黏贴即可"></a>表情可通过下面EMOJIALL网址进行查找，复制黏贴即可</h5><p><a href="https://www.emojiall.com/zh-hans/all-emojis">全部Emoji | EmojiAll</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7f4f6c11214137aad556a1b832c4bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="2-进行核心代码的编写"><a href="#2-进行核心代码的编写" class="headerlink" title="2. 进行核心代码的编写"></a>2. 进行核心代码的编写</h4><p>思路：</p><h5 id="1-点击表情触发showModal事件打开弹窗。"><a href="#1-点击表情触发showModal事件打开弹窗。" class="headerlink" title="1. 点击表情触发showModal事件打开弹窗。"></a>1. 点击<code>表情</code>触发<code>showModal</code>事件打开弹窗。</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08be9c3fe09f4519a58d2667a8805f9e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="2-点击你要选择的表情后触发handleOk事件，关闭弹窗并将表情添加到文本域内。"><a href="#2-点击你要选择的表情后触发handleOk事件，关闭弹窗并将表情添加到文本域内。" class="headerlink" title="2. 点击你要选择的表情后触发handleOk事件，关闭弹窗并将表情添加到文本域内。"></a>2. 点击你要选择的表情后触发<code>handleOk</code>事件，关闭弹窗并将表情添加到文本域内。</h5><h5 id="3-由于在Col组件渲染时给每个表情都添加了handleOk的点击事件并传入对应的表情。"><a href="#3-由于在Col组件渲染时给每个表情都添加了handleOk的点击事件并传入对应的表情。" class="headerlink" title="3. 由于在Col组件渲染时给每个表情都添加了handleOk的点击事件并传入对应的表情。"></a>3. 由于在<code>Col</code>组件渲染时给每个表情都添加了<code>handleOk</code>的点击事件并传入对应的表情。</h5><h5 id="4-点击Button发送按钮触发sendMessage事件即可"><a href="#4-点击Button发送按钮触发sendMessage事件即可" class="headerlink" title="4. 点击Button发送按钮触发sendMessage事件即可"></a>4. 点击<code>Button</code>发送按钮触发<code>sendMessage</code>事件即可</h5><h4 id="关于Modal组件及实现的关键代码，已进行了注释说明"><a href="#关于Modal组件及实现的关键代码，已进行了注释说明" class="headerlink" title="关于Modal组件及实现的关键代码，已进行了注释说明"></a>关于<code>Modal</code>组件及实现的关键代码，已进行了注释说明</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9ae84908ec4bc08ce2fc7215e33053~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="以上便是这篇教程的全部内容啦"><a href="#以上便是这篇教程的全部内容啦" class="headerlink" title="以上便是这篇教程的全部内容啦"></a>以上便是这篇教程的全部内容啦</h3><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React实战</tag>
      
      <tag>Antd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长达万字的git常用指令总结！！！适合小白及在工作中想要对git基本指令有所了解的人群(建议收藏)</title>
    <link href="/2022/02/12/%E9%95%BF%E8%BE%BE%E4%B8%87%E5%AD%97%E7%9A%84git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/12/%E9%95%BF%E8%BE%BE%E4%B8%87%E5%AD%97%E7%9A%84git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标成为一名高级前端开发工程师</strong></p></blockquote><p><strong>本篇文章将对git在工作和学习中需要用到的大部分常用指令作详细解答</strong></p><p>本文总结自廖雪峰老师的文档<br/><br/><br/></p><p><a href="#1">1.git的初步认识</a></p><p><a href="#2">2.git add与git commit</a></p><p><a href="#3">3.git status和git diff</a></p><p><a href="#4">4.版本回退git reset与查看日志git log&#x2F;git relog</a></p><p><a href="#5">5.撤销修改git checkout及git reset(再提及)</a></p><p><a href="#6">6.删除文件</a></p><p><a href="#7">7.分支管理 branch与switch</a></p><p><a href="#8">8.标签的使用 git tag与git show</a></p><ul><li><a href="#11">创建标签</a></li><li><a href="#12">查看标签</a></li><li><a href="#13">删除标签</a></li><li><a href="#14">推送标签到远程库</a></li></ul><p><a href="#9">9.远程仓库的连接</a></p><ul><li><a href="#15">与远程库建立连接</a></li><li><a href="#16">向远程库输出本地库中的文件</a></li><li><a href="#17">删除远程库</a></li></ul><p><a href="#10">10.与Github或Gitee建立文件传输机制</a><br><br></br><br><br></br></p><h1 id="1-git的初步认识"><a href="#1-git的初步认识" class="headerlink" title="1.git的初步认识"></a><div id="1">1.git的初步认识</div></h1><p>首先，Git在本地中具有工作区、暂存区与本地仓库区<br>平时我们修改代码时叫做<strong>工作区</strong>，当你完成项目到某个进度想保存时，那么便可将代码存到<strong>暂存区</strong>，暂存区类似于word文件中的自动保存功能，当你确认暂存区中的代码没问题要保存时，便可将代码由<strong>暂存区</strong>转到<strong>本地仓库区</strong>。</p><p>那么对于一个目录，如何将它变成Git可以管理的仓库呢？(本地仓库，还不是远程仓库)<br>答案是：在当前目录下运行<code>git init</code>指令创建一个版本库，然后这个目录里面的所有文件就可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了，如果你没有看到.git目录，那是因为这个目录默认是隐藏的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/800f0baaf4684330b96abd5d325f6133~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><h1 id="2-git-add与git-commit"><a href="#2-git-add与git-commit" class="headerlink" title="2.git add与git commit"></a><div id="2">2.git add与git commit</div></h1><p>由于Github使用面更广，后续演示都是针对Github来展开</p><p>总体来说，把一个文件放到本地Git仓库只需要两步。</p><ul><li><p>第一步，用命令<code>git add</code>告诉Git，把某个文件从工作区添加到暂存区。</p></li><li><p><code>git add &lt;file&gt;</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ git <span class="hljs-keyword">add</span> readme.txt<span class="hljs-comment">//将readme.txt文件添加到暂存区</span><br></code></pre></td></tr></table></figure><p>执行上面的命令，如果没有任何显示，代表正确运行。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a3e424388784d748551d0fb09b86588~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p></li><li><p>第二步，用命令<code>git commit</code>告诉Git，将暂存区中所有文件一次性从暂存区添加到本地仓库区。</p></li><li><p><code>git commit -m &lt;message&gt;</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><span class="hljs-regexp">//</span>将readme.txt文件添加到本地仓库<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2759aacb994ccdab5573ed8dbb0b64~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p></li></ul><p>:boom:<strong>详解</strong>:boom:<br>.<br>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git add file1.txt<br><span class="hljs-symbol">$</span> git add file2.txt file3.txt<span class="hljs-comment">//一次add命令可以有多个文件，用空格分隔</span><br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br></code></pre></td></tr></table></figure><p><br></br></p><h1 id="3-git-status和git-diff"><a href="#3-git-status和git-diff" class="headerlink" title="3.git status和git diff"></a><div id="3">3.git status和git diff</div></h1><p><code>git status</code>命令能查看当前目录中所有文件的代码状态，如果文件是<strong>红色</strong>那说明文件被修改过但还没将此次修改提交。<br><code>git diff</code>命令顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，<code>git diff</code>后面<strong>跟文件名称</strong>是是查看工作区（working tree）与暂存区（index）的差别的</p><p><br></br></p><h1 id="4-版本回退git-reset与查看日志git-log-x2F-git-relog"><a href="#4-版本回退git-reset与查看日志git-log-x2F-git-relog" class="headerlink" title="4.版本回退git reset与查看日志git log&#x2F;git relog"></a><div id="4">4.版本回退git reset与查看日志git log&#x2F;git relog</div></h1><p>你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择<strong>读取前一关的状态</strong>。有些时候，在打Boss之前，你会<strong>手动存盘</strong>，以便万一打Boss失败了，可以从<strong>最近的地方</strong>重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，<strong>这个快照在Git中被称为commit</strong>。一旦你把文件改乱了，或者误删了文件，还可以<strong>从最近的一个commit恢复</strong>，然后继续工作，而不是把几个月的工作成果全部丢失，这就是版本回退。</p><p>假设对于readme.txt文件，我已经提交了三个版本的修改，而对于<code>git commit -m &lt;message&gt;</code>，-m后面输入的本次提交说明如下：</p><p>版本1：wrote a readme file<br>版本2：add distributed<br>版本3：append GPL(最新版本)</p><ul><li>git log<br>当然，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统Git干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log<br>commit <span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master)//最新的一次修改<br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    append GPL<br><br>commit e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> distributed<br><br>commit eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">18</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    wrote a readme file<br></code></pre></td></tr></table></figure>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL//最新的一次修改<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure></li></ul><p>:boom:友情提示：你看到的一大串类似1094adb…的是<strong>commit id（版本号）</strong>，你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。<strong>版本号没必要写全，前几位就可以了，Git会自动去找</strong><br><br></br><br>打算把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？<br>首先，<strong>Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本</strong>，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><ul><li>git reset</li></ul><p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用<code>git reset</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^//去上一个版本</span><br>HEAD <span class="hljs-keyword">is</span> now at e475afc <span class="hljs-keyword">add</span> distributed<br></code></pre></td></tr></table></figure><p>也可以指定某个commit版本进行还原</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">reset</span> --hard 1094a//指定commit版本前五位数为1094a的进行还原<br>HEAD <span class="hljs-built_in">is</span> now <span class="hljs-built_in">at</span> 83b0afe <span class="hljs-built_in">append</span> GPL<br></code></pre></td></tr></table></figure><p>如果你忘记了commit版本号，可以通过<code>git reflog</code>来找，<code>git reflog</code>记录了你的每一次命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br>e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br>eaadf4e HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme file<br></code></pre></td></tr></table></figure><p>:boom:过程图示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c24650a5651e4811b10f1a851a2c2ba1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>总结：</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<br><code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><p><br></br></p><h1 id="5-撤销修改git-checkout及git-reset-再提及"><a href="#5-撤销修改git-checkout及git-reset-再提及" class="headerlink" title="5.撤销修改git checkout及git reset(再提及)"></a><div id="5">5.撤销修改git checkout及git reset(再提及)</div></h1><ul><li>撤销工作区的修改</li></ul><p>当你对工作区文件完成修改时，你可以选择<code>git add</code>提交到暂存区，也可以选择<code>git checkout</code>撤销此次修改</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，<br>这里有两种情况：<br>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到上次提交到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><ul><li>撤销暂存区的修改</li></ul><p>当你对工作区文件完成修改且已经提交到了暂存区，你可以选择<code>git commit</code>提交到本地仓库区，也可以选择<code>git reset</code>把暂存区的修改撤销掉</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">$ git reset HEAD readme.txt<span class="hljs-comment">//前文讲过，HEAD代表当前最新版本的文件</span><br>Unstaged changes <span class="hljs-keyword">after</span> reset:<br>Mreadme.txt<br></code></pre></td></tr></table></figure><h4 id="可知，git-reset命令既可以回退版本，也可以把暂存区的修改撤销到工作区。"><a href="#可知，git-reset命令既可以回退版本，也可以把暂存区的修改撤销到工作区。" class="headerlink" title="可知，git reset命令既可以回退版本，也可以把暂存区的修改撤销到工作区。"></a>可知，<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改撤销到工作区。</h4><ul><li>撤销本地仓库区的修改</li></ul><p>什么时候需要撤销本地仓库区的修改呢？那便是已经<code>git commit</code>到本地仓库了，那便回到前文的版本回退章节进行查阅，<code>git reset --hard 指定版本</code>即可</p><p><br></br></p><h1 id="6-删除文件"><a href="#6-删除文件" class="headerlink" title="6.删除文件"></a><div id="6">6.删除文件</div></h1><p>在Git中，删除也是一个修改操作<br>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm &lt;file&gt;</code>命令删了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">rm</span> test.txt<br></code></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，<strong>工作区和版本库</strong>就不一致了</p><ul><li>如果你只是误删文件，那么可以通过<code>git checkout</code>指令恢复(撤销本次修改)<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- test.txt</span><br></code></pre></td></tr></table></figure></li><li>如果你确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，再<code>git commit</code>提交本次修改<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">test</span>.txt<br><span class="hljs-keyword">rm</span> &#x27;<span class="hljs-keyword">test</span>.txt&#x27;<br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;remove test.txt&quot;</span><br>[master d46f35e] remove <span class="hljs-keyword">test</span>.txt<br> 1 <span class="hljs-keyword">file</span> changed, 1 deletion(-)<br> delete mode 100644 <span class="hljs-keyword">test</span>.txt<br></code></pre></td></tr></table></figure><font color="blue">小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</font></li></ul><p><br></br></p><h1 id="7-分支管理-branch与switch"><a href="#7-分支管理-branch与switch" class="headerlink" title="7.分支管理 branch与switch"></a><div id="7">7.分支管理 branch与switch</div></h1><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，<strong>由于代码还没写完，不完整的代码库会导致别人不能干活了</strong>。如果等代码全部写完再一次提交，又存在<strong>丢失每天进度的巨大风险</strong>。<br>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再<strong>一次性合并到原来的分支上</strong>，这样，既安全，又不影响别人工作。<br><br></br></p><p>:boom:<strong>用<code>branch</code>系列指令进行分支相关操作</strong></p><ul><li>查看分支</li></ul><p>用<code>git branch</code>命令列出本地仓库中所有分支，当前分支前面会标一个<code>*</code>号</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* dev</span><br>  master<br></code></pre></td></tr></table></figure><ul><li>创建与合并分支</li><li>创建</li></ul><p><code>git branch dev</code>创建dev分支<br><code>git checkout dev</code>将HEAD指针切换到dev分支</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git branch dev<br><span class="hljs-variable">$ </span>git checkout dev<br>Switched to branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><p><code>git checkout -b dev</code>  git checkout命令加上-b参数表示创建并切换，相当于上面两条命令<br>先创建dev分支，然后切换到dev分支</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b dev<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><p><br></br></p><ul><li>合并</li></ul><p>当你在<code>dev</code>分支上对<code>readme.txt</code>文件进行修改后，想将该修改合并到<code>master</code>主分支上时，两步：</p><p>先<code>git checkout 分支名</code>切换到<code>master</code>分支</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>再<code>git merge 需要被合并的分支名</code>合并dev分支</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git merge dev<br><span class="hljs-function"><span class="hljs-title">Updating</span></span> d46f35e..b17d20e<br>Fast-forward<br> readme.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>合并完成后，就可以删除dev分支了，相较于<code>git checkout dev</code>添加分支，加个参数<code>-d</code>代表<code>delete</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ git <span class="hljs-keyword">branch </span>-d dev<br>Deleted <span class="hljs-keyword">branch </span>dev (was <span class="hljs-keyword">b17d20e).</span><br></code></pre></td></tr></table></figure><p><br></br><br>:boom:<strong>用<code>switch</code>系列指令进行分支相关操作</strong></p><p>注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更容易理解。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ git <span class="hljs-keyword">switch</span> -c dev<span class="hljs-comment">//代替git checkout -b dev</span><br></code></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ git <span class="hljs-keyword">switch</span> master<span class="hljs-comment">//代替git branch dev</span><br></code></pre></td></tr></table></figure><p><br></br><br>:boom:<strong>总结：</strong></p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code><br><br></br><br><br></br></p><h1 id="8-标签的使用-git-tag与git-show"><a href="#8-标签的使用-git-tag与git-show" class="headerlink" title="8.标签的使用 git tag与git show"></a><div id="8">8.标签的使用 git tag与git show</div></h1><p>前言：为什么要使用标签？</p><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的commit版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br><strong>Git有commit版本号，为什么还要引入tag？</strong><br>因为commit版本是类似<code>6a5819e...</code>的一大串字符，不好找、辨别<br>如果将<code>6a5819e...</code>变成<code>v1.2</code>，就容易了很多<br><strong>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit版本号绑在一起。</strong><br><br></br></p><p><br></br></p><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><div id="11">创建标签</div></h2><p><code>git tag &lt;tagname&gt;</code><br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code><br><br></br></p><ul><li><p>给整个分支打标签<br>首先，<code>git branch</code>切换到需要打标签的分支上</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br></code></pre></td></tr></table></figure><p>然后<code>git tag &lt;tagname&gt;</code>打标签即可</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>给过去的某个commit版本打标签<br><code>git tag &lt;tagname&gt; &lt;commid id&gt;</code></p></li></ul><p><strong>默认标签是打在最新提交的commit上的，历史的找到历史提交的commit id，然后打上就可以了</strong></p><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">9</span> f52c633<br></code></pre></td></tr></table></figure><p><br></br><br><strong>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字</strong><br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; &lt;commit id&gt;</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v0.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><p><br></br><br></br></p><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a><div id="12">查看标签</div></h2><p><code>git tag</code><br>可以用命令git tag查看所有标签</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><code>git show &lt;tagname&gt;</code><br>标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span> v0<span class="hljs-number">.9</span><br><span class="hljs-keyword">commit</span> f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0<span class="hljs-number">.9</span>)<br>Author: Michael Liao <span class="hljs-operator">&lt;</span>askxuefeng<span class="hljs-variable">@gmail</span>.com<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">56</span>:<span class="hljs-number">54</span> <span class="hljs-number">2018</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> <span class="hljs-keyword">merge</span><br><br>diff <span class="hljs-comment">--git a/readme.txt b/readme.txt</span><br>...<br></code></pre></td></tr></table></figure><p><br></br><br></br></p><h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a><div id="13">删除标签</div></h2><ul><li><p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p></li><li><p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p></li></ul><p><br></br></p><h2 id="推送标签到远程库"><a href="#推送标签到远程库" class="headerlink" title="推送标签到远程库"></a><div id="14">推送标签到远程库</div></h2><ul><li><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p></li><li><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p></li></ul><p><br></br><br></br></p><h1 id="9-远程仓库的连接"><a href="#9-远程仓库的连接" class="headerlink" title="9.远程仓库的连接"></a><div id="9">9.远程仓库的连接</div></h1><p>目前广为人知的两个远程仓库有Github和Gitee(码云)</p><p>Github：人气最高，人们普遍使用的一个国际化代码管理平台</p><p>Gitee：使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况<br>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）</p><p><strong>目标：<br>在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步。</strong></p><p><br></br></p><h3 id="与远程库建立连接"><a href="#与远程库建立连接" class="headerlink" title="与远程库建立连接"></a><div id="15">与远程库建立连接</div></h3><p><code>git remote add 远程仓库名字 git@github.com:远程仓库路径//远程仓库路径如下图</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote add origin git<span class="hljs-variable">@github</span>.<span class="hljs-symbol">com:</span>michaelliao/learngit.git<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc0ec8b103c4adc815373b73711e01f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>建立好连接后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。<br><br></br></p><h3 id="向远程库输出本地库中的文件"><a href="#向远程库输出本地库中的文件" class="headerlink" title="向远程库输出本地库中的文件"></a><div id="16">向远程库输出本地库中的文件</div></h3><p><code>git push -u 远程仓库名称 要推送的本地分支名称</code></p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">$ git push -u origin master<br><span class="hljs-type">Counting</span> objects: <span class="hljs-number">20</span>, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Delta</span> compression using up <span class="hljs-keyword">to</span> <span class="hljs-number">4</span> threads.<br><span class="hljs-type">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">15</span>/<span class="hljs-number">15</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">20</span>/<span class="hljs-number">20</span>), <span class="hljs-number">1.64</span> <span class="hljs-type">KiB</span> | <span class="hljs-number">560.00</span> <span class="hljs-type">KiB</span>/s, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Total</span> <span class="hljs-number">20</span> (delta <span class="hljs-number">5</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>remote: <span class="hljs-type">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">To</span> github.com:michaelliao/learngit.git<br> * [<span class="hljs-keyword">new</span> branch]      master -&gt; master<br><span class="hljs-type">Branch</span> <span class="hljs-symbol">&#x27;master&#x27;</span> set up <span class="hljs-keyword">to</span> track remote branch <span class="hljs-symbol">&#x27;master&#x27;</span> from <span class="hljs-symbol">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p><strong>从现在起，只要本地作了提交，就可以通过命令：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master//<span class="hljs-built_in">origin</span>依旧为远程库名称，master为要推送的分支名称<br></code></pre></td></tr></table></figure><p><br></br><br></br></p><h3 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a><div id="17">删除远程库</div></h3><p>在删除前，建议先用<code>git remote -v</code>查看远程库信息</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (push)<br></code></pre></td></tr></table></figure><p><code>git remote rm &lt;name&gt;</code> 删除远程库，name为远程库名称<br>比如删除前文创建的名为origin的远程库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p><br></br><br><strong>温馨提示：此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</strong><br><br></br><br>:boom:<strong>总结：</strong></p><ul><li><p>要关联一个远程库，使用命令<code>git remote add 远程仓库名字 git@github.com:远程仓库路径</code></p></li><li><p>关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；</p></li><li><p>关联后，使用命令<code>git push -u 远程仓库名称 要推送的本地分支名称</code> 第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push -u 远程仓库名称 要推送的本地分支名称</code>推送最新修改；</p></li></ul><p><br></br><br></br></p><h1 id="10-与Github或Gitee建立文件传输机制"><a href="#10-与Github或Gitee建立文件传输机制" class="headerlink" title="10.与Github或Gitee建立文件传输机制"></a><div id="10">10.与Github或Gitee建立文件传输机制</div></h1><p>你的本地Git仓库和GitHub仓库之间的传输方式有两种，一种是通过https，另一种是通过SSH加密的</p><p>HTTPS：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码<strong>都需要输入账号和密码</strong>，这也是https方式的麻烦之处(发现了https免密登录的方式)。</p><p>SSH：使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的<strong>拥有者或管理员</strong>，否则你是无法添加<strong>SSH key</strong>的。另外ssh默认是每次fetch和push代码<strong>都不需要输入账号和密码</strong><br><br></br><br>至于如何将本机与Github和Gitee建立SSH连接，方便推送不用输入邮箱密码，请参考下面链接：</p><ul><li>Github如何实现SSH加密传输：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">Github平台的SSH</a></li><li>Github如何实现SSH加密传输：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/1163625339727712">Gitee平台的SSH</a></li></ul><p><br></br><br></br></p><p><strong>这是我的第一篇万字博客！希望大家能够喜欢并从中收获到知识</strong></p><p><strong>以上便是这篇文章的全部内容啦</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profilehttp://blog.zhangjiancong.top">https://i.csdn.net/#/user-center/profilehttp://blog.zhangjiancong.top</a>)</p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>协作工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈javascript的原型和原型链(新手懵懂想学会原型链？看这篇文章就足够啦！！！)</title>
    <link href="/2022/02/11/%E6%B5%85%E8%B0%88javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/02/11/%E6%B5%85%E8%B0%88javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>本篇文章我将从概念和对应题目知识点讲起，希望大家能有所收获</strong><br><br/><br/></p><h2 id="一、原型"><a href="#一、原型" class="headerlink" title="一、原型"></a>一、原型</h2><p>①所有引用类型都有一个_proto_(隐式原型)属性(类似链表中的next指针)， 链表可以通过.next访问下个元素，原型中可通过._proto_访问上一级元素。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093ea1edf14e4f5d8de22bb5ac8f10a7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p><p>②所有类都有一个prototype(原型)属性，例如：Object,Function,Array</p><p>③所有引用类型的_proto_属性指向它构造函数的prototype<br>例如：arr是一个数组实例，那么arr._proto_&#x3D;Array.prototype<br><br/><br/></p><h2 id="二、原型链"><a href="#二、原型链" class="headerlink" title="二、原型链"></a>二、原型链</h2><p>当访问一个对象的某个属性时，会先在这个对象本身上查找，如果没有找到，则会去它的_proto_上查找，即它的构造函数的prototype，如果还没有找到就会继续在构造函数prototype的_proto_中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。</p><p>下面例子有助于你对原型链的理解：</p><p>arr为Array数组的实例</p><p>arr._proto_&#x3D;Array.prototype</p><p>Array._proto_&#x3D;Object.prototype</p><p><strong>分析：arr这个数组实例，沿着原型链找，找到数组的原型对象，数组这个类沿着原型链找，找到对象的原型对象(最高级)，因此也可以用arr._proto_._proto_来找到Object.prototype，类似链表中的next指针，只不过_proto_是往上找。</strong><br><br/><br/></p><h2 id="面试真题："><a href="#面试真题：" class="headerlink" title="面试真题："></a>面试真题：</h2><p><strong>题目一：<br>instanceof的原理，并用代码实现</strong><br><br/><br>分析：如果A沿着原型链能找到B.prototype，那么A instanceof B 为true(用_proto_来找)</p><p><strong>解法：遍历A的原型链，如果找到B.prototype，返回true，否则返回false</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">instanceof</span> =(<span class="hljs-params">A,B</span>)=&gt;&#123;<br>    <span class="hljs-keyword">let</span> p = A;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-keyword">if</span>(p === B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        p = p.<span class="hljs-property">_proto_</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p><strong>题目二：</strong></p><p>var foo &#x3D; {},        F &#x3D; function(){};</p><p>Object.prototype.a &#x3D; ‘value a’;</p><p>Function.prototype.b &#x3D; ‘value b’;</p><p>console.log(foo.a);<br>console.log(foo.b);<br>console.log(F.a);<br>console.log(F.b);<br><br/><br>分析：如果在A对象上没找到x属性，那么会沿着原型链找x属性。(如果A为函数实例，那么A上面找不到，就去找Function这个类上有没有挂载x属性，如果没有就继续往上找到Object原型对象上有没有x属性)</p><p><strong>解法：明确foo和F变量的原型链，沿着原型链找a属性和b属性</strong></p><p>因此答案为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;value a&#x27;</span><br><span class="hljs-string">&#x27;undefined&#x27;</span><br><span class="hljs-string">&#x27;value a&#x27;</span><br><span class="hljs-string">&#x27;value b&#x27;</span><br></code></pre></td></tr></table></figure><p>foo这个对象实例上没有b属性，是因为原型链不能往下找，只能一层一层往上找，<strong>即对象实例不能腆着脸问他的下级Function有没有挂载b这个属性</strong></p><br/><br/><br/><p><strong>觉得本篇文章对你有帮助的请不要忘记一键三连加关注~~<br/><br>你的支持就是对我最大的动力！！<br/><br>会继续努力码更多的精品文章！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>原型</tag>
      
      <tag>原型链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 搭建自己的个人博客</title>
    <link href="/2022/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>大家好，我是Smooth，一名大二的前端爱好者，目标成为一名高级前端开发工程师</strong></p></blockquote><p><strong>一文从头到尾教你通过 hexo 搭建自己的个人博客以及配置喜欢的主题</strong></p><p>本篇文章将从头到尾详细地教你如何通过 hexo 搭建自己的个人博客，新手都能看懂的教程哈哈</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。</p><p>而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。</p><p>那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。<br><br></br></p><h2 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。<br><br></br></p><h2 id="Hexo-搭建教程"><a href="#Hexo-搭建教程" class="headerlink" title="Hexo 搭建教程"></a>Hexo 搭建教程</h2><p><strong>本次教程主要分为8个部分，看完便可搭建自己喜欢的个人博客</strong></p><ol><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>将hexo部署到GitHub</li><li>设置个人域名</li><li>更改主题（fluid）</li><li>发布文章</li></ol><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li>Windows：到 <a href="https://git-scm.com/download/win">git</a>官网下载并安装即可，下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</li><li>Mac：<a href="http://www.macports.org/">MacPorts</a> 或 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><h3 id="安装-NodeJs"><a href="#安装-NodeJs" class="headerlink" title="安装 NodeJs"></a>安装 NodeJs</h3><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/">官方安装</a>，选择LTS版本就行。</p><p>Linux：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install nodejs<br>sudo apt-<span class="hljs-built_in">get</span> install npm<br></code></pre></td></tr></table></figure><p>安装完后，打开命令行，输入以下两行检查安装是否成功</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装好git之后，选择你想要安装hexo的地方（比如新建文件夹）</p><p>进入文件夹后，我们可以右击选择 <code>Git Bash here</code> 可以打开一个命令行窗口，输入：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>输入 <code>hexo -v</code> 查看一下版本</p><p><strong>至此环境准备完成，开始使用 hexo 搭个人博客</strong><br><br></br></p><h3 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init 文件夹名<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> 文件夹名<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>会生成很多文件夹，看不懂没关系，知道怎么配置就可以了。</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li><strong>_config.yml: 博客的配置文件</strong></li></ul><p>接着输入以下指令进行本地启动查看，指令意思后面会讲</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>这三个命令非常重要，在下文<strong>hexo 部署到 github</strong>会讲到</p><p>接着，在浏览器中输入 <code>localhost:4000</code> 就可以看到生成的博客页面了</p><p><code>ctrl + c</code> 可以关掉服务<br><br></br></p><h3 id="创建-github-仓库"><a href="#创建-github-仓库" class="headerlink" title="创建 github 仓库"></a>创建 github 仓库</h3><ol><li><p>首先，你先要有一个GitHub账户，去注册一个吧。</p></li><li><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库。</p></li><li><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我github用户名是 zjc2782171149，所以我的叫 <code>zjc2782171149.github.io</code></p></li></ol><h3 id="生成-SSH-添加到-github-仓库"><a href="#生成-SSH-添加到-github-仓库" class="headerlink" title="生成 SSH 添加到 github 仓库"></a>生成 SSH 添加到 github 仓库</h3><p>由于后续都是通过 SSH 进行仓库代码的快速部署，所以这一步很有必要，如果之前有在你的电脑本地进行过你的 github 仓库的 SSH 绑定，那此步可跳过</p><p><strong>回到你的git bash中，输入以下</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span><br>git config <span class="hljs-literal">user</span>.email<br></code></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><h5 id="ssh，简单来讲，就是一个秘钥，其中，id-rsa-是你这台电脑的私人秘钥，不能给别人看的，id-rsa-pub-是公共秘钥，可以随便给别人看。把这个公钥放在-GitHub-上，这样当你链接-GitHub-自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过-git-上传你的文件到-GitHub-上。"><a href="#ssh，简单来讲，就是一个秘钥，其中，id-rsa-是你这台电脑的私人秘钥，不能给别人看的，id-rsa-pub-是公共秘钥，可以随便给别人看。把这个公钥放在-GitHub-上，这样当你链接-GitHub-自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过-git-上传你的文件到-GitHub-上。" class="headerlink" title="ssh，简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。"></a>ssh，简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。</h5><p>而后在 github 的 setting 中，找到 SSH keys 的设置选项，点击 New SSH key 把你的 id_rsa.pub 里面的信息复制进去。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/020af2c8de394bed881c37d8591f08a8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>之后，在 gitbash 中输入以下指令，查看是否 SSH 是否已绑定成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><p>这一步，我们就可以将 hexo 和 github 关联起来，也就是将 hexo 生成的文章部署到 github 上，打开站点配置文件 <code>_config.yml</code>，翻到最后，进行如下修改即可，<code>zjc2782171149</code> 改为你的 github 账户用户名</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:zjc2782171149/zjc2782171149.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>修改完配置文件 <code>_config.yml</code> 并保存后，回到 gitbash</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后进行部署</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p><code>hexo clean</code> 清除了你之前生成的东西。</p><p><code>hexo generate</code> 生成静态文章，可以用 hexo g 缩写</p><p><code>hexo deploy</code> 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入 username 和 password，但设置了 SSH 一般不用。</p><p>得到下图就说明部署成功了，过一会儿就可以在 http:&#x2F;&#x2F;你的用户名.github.io 这个网站看到你的博客了！！<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc2715a6a154e4b923f6c76a1f39412~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br></p><h3 id="个人域名配置"><a href="#个人域名配置" class="headerlink" title="个人域名配置"></a>个人域名配置</h3><p>现在你的个人网站的地址是 <code>yourname.github.io</code>，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱购买域名，由于我是使用阿里云，所以以此作为示例。</p><p>注册一个阿里云账户,在阿里云上买一个域名，我买的是 zhangjiancong.top，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。</p><p>你需要先去进行实名认证,然后在域名控制台中，看到你购买的域名。</p><p><strong>来到域名解析页面，点击解析设置</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80dfa7213ecd475fb3d877b0ee925fa3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><br></br><br><strong>点击添加记录</strong><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398823dec9bd44ef87590ee2384a05b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48774bee367453b9a05955813f1bfd3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li><p>主机记录：我想在我域名 <code>zhangjiancong.top</code> 的基础上，配置成子域名 <code>blog</code>，所以主机记录一栏写个 blog，如果你想直接将你的域名作为解析，不填即可</p></li><li><p>记录值：改为你自己的用户名</p></li><li><p>其他跟我一样就行</p></li></ul><p>点击确认后，域名 <code>blog.zhangjiancong.top</code> 到 <code>zjc2782171149.github.io</code> 的解析就完成了</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3643bc10ec84c2a949218844502f9f8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来，还要进行 <code>zjc2782171149.github.io</code>到 <code>blog.zhangjiancong.top</code> 的解析</p><p><br></br><br><strong>设置 githubPage 的解析</strong></p><p>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你刚刚的域名<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa2d15f38d1413a90907c2167084f0a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>如果你 <code>主机记录</code> 留空，此处直接写你的域名即可，即 <code>zhangjiancong.top</code></p><p>点击 <code>Save</code>，出现如上图的绿色成功标志即可</p><p>接着，你在你的博客文件 source 文件夹中创建一个名为<code>CNAME</code>文件，不用后缀，写上你的域名</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8645cba13cd2435480916aa9f37975ca~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><br></br><br><strong>更改 master 分支</strong></p><p>由于域名默认展示你的 github 仓库的默认分支，仓库默认分支是 main，但</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:zjc2782171149/zjc2782171149.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>设置的是部署到 <code>master</code> 分支，所以需要修改仓库的默认分支为 <code>master</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85c7ad4276744067b036d91f8c22ec2b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>点击编辑按钮，更改为 <code>master</code> 分支后，保存即可</p><p><strong>最后</strong></p><p>在 gitbash 中，输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！<br><br></br></p><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><p>这里我以 <code>fluid</code> 主题作为示例</p><p>来到主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid">github</a> 仓库，下载最新的压缩包</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e98c0042e14e4426a89a3b5d468647c4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>下载完后，将压缩包解压到你博客项目的 <code>themes</code> 文件夹下，并将解压出来文件夹更名为 <code>fluid</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2cb0ad71174298812e456728c11856~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>然后打开根目录的 <code>_config.yml</code> 文件，拉到最下面找到 <code>theme</code> 属性，修改为 fluid</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb7cd9c115a42dabb9e98391086c4bc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>同时，找到文件上方的 <code>language</code> 属性，修改为 <code>zh-CN</code> 即可</p><p>然后，输入以下三个指令进行重新部署，过一会儿即可看到主题发生改变</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p><br></br></p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>发布新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> newpapername<br></code></pre></td></tr></table></figure><p>然后在source&#x2F;_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>就可以通过域名看到更新了。</p><p><br></br><br><strong>每次更新完文章或配置文件，都要输入以上三个指令进行重新部署，而不要缺某条指令，当然也可以输入简化版指令，如下</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo g --d<br></code></pre></td></tr></table></figure><p><strong>如果有小伙伴觉得每次重新部署都要输入以上指令麻烦，可在空余功夫研究下 <code>GitHub page</code> 的自动部署功能，此文便不展开了</strong><br><br></br></p><h1 id="以上便是这篇文章的全部内容啦"><a href="#以上便是这篇文章的全部内容啦" class="headerlink" title="以上便是这篇文章的全部内容啦"></a>以上便是这篇文章的全部内容啦</h1><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后，我叫Smooth，在今年2022年我也会尽自己所能书写更多前端教程~</p><p>掘金：<a href="https://juejin.cn/user/1302297507801358">https://juejin.cn/user/1302297507801358</a></p><p>CSDN：<a href="https://i.csdn.net/#/user-center/profile">https://i.csdn.net/#/user-center/profile</a></p><p><strong>最近发文计划为 <code>Webpack</code> 以及 性能优化 知识体系</strong></p><p><strong>同时也可扫码关注我的公众号，公众号同步更新</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0d019868147a1b84e94ff8380e7b9~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
